{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/strategies", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/strategies/service_dependencies.py", "basename": "service_dependencies.py", "ext": ".py", "service_references": ["openai", "github"], "summary": "This Python script is not starting an application server. It is part of a larger application, likely a microservice architecture, and its purpose is to analyze code files and identify service dependencies.\n\nThe main function in this script is `get_service_references()`, which is an asynchronous function that takes a file path, a model, and a Github context as arguments. It returns a `ServiceGraph` object or `None`.\n\nThe function reads the contents of the file at the given path and checks if it's empty or if it matches any patterns in `CONTENT_EXCLUDES`. If either condition is met, the function returns `None`.\n\nIf the file contents pass these checks, the function generates a prompt for an OpenAI model. The prompt includes information about the Github organization and repository, the file path, and the code in the file. It also includes instructions for the model to identify services referenced in the code.\n\nThe function then sends this prompt to the OpenAI model and waits for a response. If the response is valid, it is parsed into a list of service names. Each service name is registered in `SERVICE_REGISTRY` and added to a `ServiceGraph` object, which is then returned.\n\nThe script also handles exceptions for maximum retry attempts and timeouts when waiting for the OpenAI model's response. In these cases, it logs a warning and returns `None`.\n\nOverall, this script is part of a system that uses AI to analyze code and generate a high-level system architecture diagram."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/strategies/component_name.py", "basename": "component_name.py", "ext": ".py", "service_references": [], "summary": "The provided information does not include any actual code, so it's impossible to summarize it or determine if it starts an application server like Express, Flask, Django, Gin, Rack, etc. It also cannot be determined if the code is primarily focused on setting up routes and middleware for a web application. Please provide the actual code for analysis."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/strategies/chained_queries.py", "basename": "chained_queries.py", "ext": ".py", "service_references": ["openai"], "summary": "This Python script does not start an application server like Express, Flask, Django, Gin, Rack, etc. Instead, it is a module that defines two asynchronous functions: `query_file_contents_chained` and `query_file_contents`. \n\nThe `query_file_contents_chained` function is currently set to query the contents of a specific file (`google_oauth.py`) using a specified model from the OpenAI library. The function seems to have been designed to potentially handle querying multiple files and directories, but those parts of the code are currently commented out.\n\nThe `query_file_contents` function opens a file, reads its contents, and sends a request to the OpenAI API with the file contents as part of the request parameters. The response from the OpenAI API is then logged and written to a markdown file. If the model used is GPT4, it waits for 2 seconds before proceeding.\n\nThere are also commented out sections of code that seem to be designed for handling lists of external services referenced in the application and querying whether there are any references to Google Cloud, AWS, or Azure products."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/strategies/file_queries.py", "basename": "file_queries.py", "ext": ".py", "service_references": ["openai", "github"], "summary": "The Python script in the file `file_queries.py` does not start an application server. Instead, it is a module that is part of a larger application, possibly related to analyzing code repositories.\n\nThe script imports several modules and defines a data class `FileQueryResponse` for storing API references and service information. It also defines several functions:\n\n- `query_file_contents`: This function takes a file path, a model, a GitHub context, and a parent service as arguments. It builds a prompt for the OpenAI model based on the code context in the file, makes an OpenAI request, and returns a `FileQueryResponse` object based on the response from the OpenAI model.\n- `_load_file`: This function loads the contents of a file and returns them as a string. It skips files that match certain exclusion patterns and files with no content.\n- `_build_prompt_for_code_context`: This function builds a prompt for the OpenAI model based on the code context in a file. It loads the file contents, truncates them if necessary, and constructs a prompt message.\n- `_make_openai_request`: This function makes an OpenAI request using given parameters and returns the response.\n\nThe script also defines several constants for use in constructing prompts for the OpenAI model. These prompts are used to ask the model questions about the code in a file, such as whether the code sets up an HTTP server framework or makes calls to other APIs."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/strategies/rolling_summaries.py", "basename": "rolling_summaries.py", "ext": ".py", "service_references": ["openai"], "summary": "The code in the file `rolling_summaries.py` is a Python script that uses asyncio for asynchronous operations. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe script appears to be part of a larger project and is responsible for generating summaries and connections of files and directories in a file system hierarchy. It uses OpenAI's GPT-3 model to generate these summaries and to identify if a file starts an application server. The summaries and connections are then written to markdown and JSON files.\n\nThe script defines several functions:\n\n- `_do_request`: This function makes an asynchronous request to the OpenAI API and returns the response.\n- `run`: This function is the main entry point of the script. It builds the file system hierarchy, gathers summaries of all files, and writes the summaries and connections to output files.\n- `gather_connections`: This function collects all service references from a given file system hierarchy.\n- `write_connections`: This function writes the connections between services in the file system hierarchy to a file.\n- `write_graph`: This function writes the connections between services in a graphical format to a file.\n- `gather_summaries`: This function gathers summaries of all files in a given file system hierarchy. It also identifies if a file starts an application server and references any external services or APIs.\n- `_normalize`: This function normalizes a string by replacing non-alphanumeric characters with underscores and converting it to lowercase.\n\nThe script is run asynchronously using `asyncio.run(run())` at the end of the file."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/strategies/service_info.py", "basename": "service_info.py", "ext": ".py", "service_references": ["openai", "github"], "summary": "The code in the file `service_info.py` does not start an application server. Instead, it defines a function `get_services_from_hierarchy` that takes a file system hierarchy, an OpenAI model, and a Github context as inputs. \n\nThe function renders the file system hierarchy and creates a list of chat messages that instruct an AI model to generate a short, human-readable name and description for any public services hosted in a given repository. The AI model is then used to generate a response based on these messages.\n\nIf the maximum number of retry attempts is reached, the function prints a warning message and returns an empty list. Otherwise, the function parses the response from the AI model, creates a list of `Service` objects, registers each service in the service registry, and returns the list of services.\n\nThe code also imports several modules and objects, including a `FSHierarchy` class, a `render_fs_hierarchy` function, a `SERVICE_REGISTRY` object, several constants and classes from `eave.archer.util`, a `Service` class, a `parse_service_response` function, a `MaxRetryAttemptsReachedError` exception, and an `openai_client` module."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/strategies/service_normalization.py", "basename": "service_normalization.py", "ext": ".py", "service_references": ["openai"], "summary": "The code in this file does not start an application server. Instead, it defines a function `normalize_services` that takes a list of services and an OpenAI model as input and returns a dictionary of services. \n\nThe function prepares the services by extracting their names, descriptions, and dependencies. It then converts this information into a JSON format. This JSON is used to create a chat completion parameter for the OpenAI model. The model is expected to reduce the list of services to distinct ones by combining similar services. \n\nThe response from the model is then parsed and used to create a new dictionary of services. The service names are normalized by removing any parentheses. If there is an error in parsing the response, the prepared services are used instead. \n\nThe file also defines a helper function `_normalize_service_name` that removes parentheses from a given string. \n\nThe file uses modules for logging, interacting with OpenAI, and handling service graphs and utilities."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/strategies/package_json_parsing.py", "basename": "package_json_parsing.py", "ext": ".py", "service_references": ["openai"], "summary": "The code in this file does not start an application server. Instead, it is a script that parses 'package.json' files in a project hierarchy to gather dependencies. \n\nThe script uses the tree-sitter library to parse TypeScript code and OpenAI's GPT-4 model to categorize the dependencies into four categories: internal/private packages, third-party service SDKs, others, and unsure. \n\nThe script starts by building a file system hierarchy from the project root directory. It then recursively traverses this hierarchy, looking for 'package.json' files. For each 'package.json' file found, it reads the file contents and extracts the dependencies. \n\nFor each dependency, it sends a request to the OpenAI API to categorize the dependency. The result is a JSON object that groups the dependencies into the four categories mentioned above. \n\nFinally, the script writes the resulting dependency tree to a markdown file in the output directory. \n\nThe script is designed to be run as a standalone application, as indicated by the `if __name__ == \"__main__\":` block at the end of the file."}]}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/config.py", "basename": "config.py", "ext": ".py", "service_references": ["openai"], "summary": "This Python script is a configuration file for an application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe script imports the datetime module, os module, and a module named eave.stdlib.openai_client. It then sets several global variables:\n\n- PROJECT_ROOT: This is set to the value of the environment variable \"EAVE_HOME\".\n- MODEL: This is set to the GPT4 model from the OpenAI client.\n- TIMESTAMP and TIMESTAMPF: These are set to the current date and time, with TIMESTAMPF being formatted in a specific way.\n- OUTDIR: This is set to a directory path that includes the current timestamp.\n\nThe script also defines a set of file and directory paths that should be excluded from some process (possibly related to file hierarchy or dependency collection). These paths include various system and configuration files, test directories, and image files.\n\nTwo TODO comments indicate future development plans: to automatically exclude files listed in gitignore and to parse HTML files to exclude SVG documents.\n\nFinally, it defines an empty set named CONTENT_EXCLUDES, which is meant to hold files that should be excluded from dependency collection but still shown in the hierarchy."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/render.py", "basename": "render.py", "ext": ".py", "service_references": [], "summary": "The code in the file `render.py` is part of a larger application and does not start an application server. It appears to be part of a system that manages and visualizes dependencies and services in a software project. \n\nThe code includes functions to render graphs of services and their dependencies, as well as file hierarchies. It uses the mermaid.js library for creating diagrams and flowcharts. \n\nThe code also includes functions to write various pieces of information to markdown files, such as services, file queries, dependencies, prompts, OpenAI requests and responses, file hierarchies, graphs, and run information. \n\nThe run information includes the number of tokens used in prompts and completions, the total number of tokens, the cost of the run, and the duration of the run. The cost is calculated based on the pricing for GPT4 8k: $0.03 per 1K prompt tokens and $0.06 per 1K completion tokens.\n\nThe code does not appear to start an application server like Express, Flask, Django, Gin, or Rack."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/util.py", "basename": "util.py", "ext": ".py", "service_references": ["openai"], "summary": "This Python script does not start an application server. It is a utility script for a larger application, possibly related to processing and analyzing code files. \n\nThe script imports various modules, including `ast` for abstract syntax trees, `dataclasses` for data classes, `os` and `re` for file and string operations, and `tiktoken` for tokenizing text. It also imports some custom modules, likely from the same application.\n\nThe script defines a mapping from file extensions to programming languages, a dictionary to store prompts, and another dictionary to keep track of total tokens.\n\nA data class `GithubContext` is defined with two fields: `org_name` and `repo_name`.\n\nSeveral utility functions are defined:\n\n- `get_lang(filename: str) -> str | None`: Returns the programming language of a file based on its extension.\n- `get_filename(filepath: str) -> str`: Returns the base name of a file from its path.\n- `clean_fpath(path: str, prefix: str = \"\") -> str`: Cleans a file path by removing a prefix.\n- `get_file_contents(filepath: str, strip_imports: bool = True) -> str | None`: Reads the contents of a file, optionally stripping import statements. It skips files that match certain patterns defined in `CONTENT_EXCLUDES`.\n- `remove_imports(filepath: str, contents: str) -> str`: Removes import statements from the contents of a Python file.\n- `get_tokens(content: str, model: _o.OpenAIModel) -> list[int]`: Tokenizes content using a specified model.\n- `truncate_file_contents_for_model(file_contents: str, prompt: str, model: _o.OpenAIModel, step: int = 100) -> str`: Truncates file contents to fit within a model's maximum token limit.\n- `make_prompt_content(messages: list[str]) -> str`: Joins a list of messages into a single string with newline separators.\n- `make_openai_request(params: _o.ChatCompletionParameters) -> OpenAIObject | None`: Makes a request to the OpenAI API for chat completion and returns the response. It also updates the total tokens dictionary with the token usage from the response. If the maximum retry attempts are reached or a timeout occurs, it returns None."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/__init__.py", "basename": "__init__.py", "ext": ".py", "service_references": []}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/tree_sitter_build.py", "basename": "tree_sitter_build.py", "ext": ".py", "service_references": [], "summary": "The code does not start an application server. Instead, it is a Python script that uses the Tree-sitter parsing library to build a language library for TypeScript. It does this by specifying the path to the TypeScript grammar in the Tree-sitter build directory. The built library is saved in the \".build/tree-sitter\" directory under the environment variable \"EAVE_HOME\"."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/service_registry.py", "basename": "service_registry.py", "ext": ".py", "service_references": [], "summary": "This Python code defines a class called `ServiceRegistry` which is used to manage services in an application. The services are stored in a dictionary where the key is the service id and the value is the service itself. The `ServiceRegistry` class provides methods to register a new service and to get a service by its id.\n\nThe `register` method checks if the service already exists in the dictionary using the `setdefault` method. If the service does not exist, it is added to the dictionary. The method returns the service.\n\nThe `get` method returns a service by its id. If the service does not exist, it returns None.\n\nAt the end of the code, a global instance of `ServiceRegistry` is created and assigned to `SERVICE_REGISTRY`. This instance can be used throughout the application to manage services.\n\nThis file does not start an application server like Express, Flask, Django, Gin, Rack, etc. It's a module that provides functionality for managing services in an application. It's also worth noting that there is a comment indicating a need for thread safety, which suggests that this code might not be safe to use in a multi-threaded environment."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/graph_builder.py", "basename": "graph_builder.py", "ext": ".py", "service_references": ["openai", "github"], "summary": "The code is from a Python file named graph_builder.py, which is part of an application named Archer under the Eave project. This file does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe file contains a single asynchronous function named build_graph. This function takes four arguments: a file system hierarchy (FSHierarchy), an OpenAI model, a Github context, and a parent service (Service). \n\nThe function iterates over all the files in the given hierarchy. For each file, it performs a chained query on the file contents. If the query response exists and contains a service name, it creates a new Service with the service name and description from the response and registers it in the SERVICE_REGISTRY. It then adds all API references from the response as sub-services to the newly created service.\n\nAfter processing all files, the function recursively calls itself for each subdirectory in the hierarchy, passing the same OpenAI model, Github context, and the last created or updated service as the parent service.\n\nThis function appears to be building a graph of services and their dependencies based on the contents of files in a given file system hierarchy."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/service_graph.py", "basename": "service_graph.py", "ext": ".py", "service_references": ["openai"], "summary": "The code does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThis Python script defines classes and methods for managing a graph of services. The `OpenAIResponseService` class is a TypedDict that represents a service with a name, description, and root. The `parse_service_response` function is used to parse a JSON response into a list of `OpenAIResponseService` objects.\n\nThe `Service` class represents a service with an id, name, description, root, and a subgraph of services. It also has a `visited` attribute to keep track of whether the service has been visited or not. The `Service` class also has methods to get the definition of the service and the full root path of the service.\n\nThe `ServiceGraph` class represents a graph of services. It has a dictionary to store services where the key is the service id and the value is the service object. It has methods to add a service to the graph and to merge another service graph into the current one."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/main.py", "basename": "main.py", "ext": ".py", "service_references": ["openai", "github"], "summary": "This Python script does not start an application server like Express, Flask, Django, Gin, Rack, etc. Instead, it is a command-line interface (CLI) script that uses the argparse library to parse command-line arguments.\n\nThe script imports various modules and functions from the eave.archer package and the OpenAIModel from the eave.stdlib package. It defines an asynchronous function `run` which takes an OpenAIModel as an argument. Inside this function, it creates a Service instance, a GithubContext instance, and builds a hierarchy of files from a specified directory.\n\nThe script then attempts to perform a chained query on the file contents using the OpenAIModel. If any error occurs during this process, it is caught and handled by the try/finally block. Regardless of whether an error occurs, the `write_run_info` function is called to log information about the run.\n\nThe script is designed to be run as a standalone program. If it is run directly (i.e., not imported as a module), it sets up an argument parser to accept a command-line argument for the OpenAI model to use. It then calls the `run` function with the specified model in an asyncio event loop."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/eave/archer/fs_hierarchy.py", "basename": "fs_hierarchy.py", "ext": ".py", "service_references": [], "summary": "The code in this file does not start an application server. Instead, it defines a way to represent a file system hierarchy in Python. \n\nThe `FileReference` class represents a file, with attributes for its path, basename, extension, a summary, and references to services. It has methods to read the file and get a cleaned version of the file path.\n\nThe `FSHierarchy` class represents a directory in the file system. It has attributes for its root path, subdirectories, files, a summary, and a service name. It also has methods to get a cleaned version of the directory path and to represent the directory as a string.\n\nThe `build_hierarchy` function constructs an `FSHierarchy` object for a given root directory. It recursively scans through all subdirectories and files in the root directory, excluding those that match any patterns in the `EXCLUDES` list. For each subdirectory, it constructs a new `FSHierarchy` object, and for each file, it constructs a new `FileReference` object. These are then added to the `dirs` and `files` lists of the `FSHierarchy` object for the root directory."}]}], "files": []}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/archer/hierarcy.json", "basename": "hierarcy.json", "ext": ".json", "service_references": [], "summary": "The code is a JSON file"}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/core", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/oauth", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/oauth/models.py", "basename": "models.py", "ext": ".py", "service_references": [], "summary": "The code does not start an application server. It is a Python script that defines two classes related to OAuth (Open Authorization) flow. \n\nThe first class, `OAuthFlowInfo`, is a data class that holds two string attributes: `authorization_url` and `state`. \n\nThe second class, `OAuthCallbackRequestBody`, is a Pydantic model that has three optional string attributes: `state`, `code`, and `error`. Pydantic is a data validation library in Python which is used to validate the data types and constraints of the class attributes. \n\nThese classes are likely used for handling OAuth authentication flow in the application."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/oauth/__init__.py", "basename": "__init__.py", "ext": ".py", "service_references": [], "summary": "The code in this file is importing different modules from the same directory. These modules include slack, atlassian, google, models, and state_cookies. There is no indication that this file starts an application server like Express, Flask, Django, Gin, Rack, etc. This is simply a module importation script."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/oauth/google.py", "basename": "google.py", "ext": ".py", "service_references": ["google_oauth2"], "summary": "The code in the file `google.py` is not starting an application server. Instead, it is a module that handles Google OAuth2 authentication for a Python application. \n\nThe module imports several libraries and modules, including Google's OAuth2 and API client libraries, and some internal modules from the application. It defines several classes and functions to handle different aspects of the OAuth2 flow.\n\nThe `_OAUTH_SCOPES` list defines the scopes that the application will request access to when authenticating a user with Google. The `_REDIRECT_URI` string is the URL that Google will redirect the user to after they have authenticated.\n\nThe `GoogleIdToken` class represents a Google ID token, which includes the user's unique Google ID, their given name, and their email address.\n\nThe `GoogleOAuthClientConfig` and `GoogleOAuthV2GetResponse` classes represent the configuration for the Google OAuth client and the response from Google's OAuth2 API, respectively.\n\nThe `get_userinfo` function retrieves user information from Google's OAuth2 API using a set of credentials. The `get_oauth_credentials` function creates a set of credentials using an access token and a refresh token.\n\nThe `build_flow` function creates an OAuth2 flow object, which is used to manage the OAuth2 authentication process. The `get_oauth_flow_info` function builds an OAuth2 flow and returns an authorization URL and state.\n\nThe `decode_id_token` function verifies an ID token and returns a `GoogleIdToken` object."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/oauth/atlassian.py", "basename": "atlassian.py", "ext": ".py", "service_references": ["atlassian"], "summary": "The code in this file is a Python module that handles OAuth authentication with Atlassian services. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe module imports several libraries and modules, including typing for type hints, dataclasses for creating classes with automatically added special methods, requests_oauthlib for OAuth2 functionality, and eave.stdlib.atlassian for Atlassian-specific functionality.\n\nThe AtlassianOAuthTokenResponse class is a data class that represents an OAuth token response from Atlassian. It has three attributes: access_token, expires_in, and scope.\n\nThe AtlassianOAuthSession class extends requests_oauthlib.OAuth2Session to provide OAuth2 functionality specifically for Atlassian. It overrides several methods from the parent class to provide custom behavior for authorization URL generation, token fetching, and making requests. It also provides additional methods for getting OAuth flow information, getting available resources, getting user information, getting the Atlassian cloud ID, and getting the API base URL.\n\nThe module also defines a list of OAuth scopes that the application requires.\n\nThe code uses the app_config module to get configuration values like the client ID and client secret for the Atlassian app. These values are used in the initialization of the AtlassianOAuthSession class and in the fetch_token method."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/oauth/slack.py", "basename": "slack.py", "ext": ".py", "service_references": ["slack"], "summary": "The code in the file `slack.py` is used for handling OAuth authentication with Slack. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe code includes several classes and functions:\n\n1. `SlackIdentity`: A class that represents a user's identity on Slack. It includes various attributes like user id, team id, email, name, picture, locale, and more.\n\n2. `SlackTeam`: A TypedDict that represents a Slack team with its id and name.\n\n3. `SlackAuthorizedUser`: A TypedDict that represents an authorized Slack user with their id, access token, refresh token, and expiration time.\n\n4. `SlackOAuthResponse`: A TypedDict that represents the response from Slack's OAuth process. It includes the access token, refresh token, expiration time, team information, authorized user information, and bot user id.\n\n5. `get_authenticated_client`: A function that takes an access token and returns an authenticated Slack client.\n\n6. `get_userinfo_or_exception`: An asynchronous function that takes a Slack client and returns a SlackIdentity object or raises an exception if the response is not a dictionary.\n\n7. `get_access_token_or_exception`: An asynchronous function that takes a code and returns a SlackOAuthResponse object or raises an exception if the response is not valid.\n\n8. `refresh_access_token_or_exception`: An asynchronous function that takes a refresh token and returns a SlackOAuthResponse object or raises an exception if the response is not valid.\n\nThe code also generates an authorization URL for Slack OAuth with a set of scopes for the application and user."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/oauth/state_cookies.py", "basename": "state_cookies.py", "ext": ".py", "service_references": [], "summary": "The code in the file `state_cookies.py` is not starting an application server. It is a Python module that provides functions for handling OAuth state cookies in a web application. It uses the Starlette library for handling HTTP requests and responses.\n\nThe module defines three main functions:\n\n1. `save_state_cookie(response: Response, state: str, provider: AuthProvider) -> None`: This function saves a state cookie to the HTTP response. The cookie's name is built using the `_build_cookie_name(provider: AuthProvider) -> str` function and its parameters are built using the `_build_cookie_params(provider: AuthProvider) -> dict[str, Any]` function. The comment above the function notes that it assumes the provider's value matches the path for `/oauth/{provider}/callback`, which may not always be true.\n\n2. `get_state_cookie(request: Request, provider: AuthProvider) -> str`: This function retrieves a state cookie from the HTTP request. If the cookie is not found, it raises an `UnexpectedMissingValue` exception.\n\n3. `delete_state_cookie(response: Response, provider: AuthProvider) -> None`: This function deletes a state cookie from the HTTP response.\n\nThe module also imports a configuration object (`app_config`) from a local module (`..config`). The configuration object is used to set the domain and security settings of the cookies."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/subscription.py", "basename": "subscription.py", "ext": ".py", "service_references": [], "summary": "The code does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThis Python code defines a SQLAlchemy ORM (Object-Relational Mapping) class named `SubscriptionOrm` for interacting with a database table named \"subscriptions\". The `SubscriptionOrm` class inherits from a base class named `Base`. \n\nThe \"subscriptions\" table has columns like `team_id`, `id`, `source_platform`, `source_event`, `source_id`, `document_reference_id`, `created`, and `updated`. \n\nThe class includes methods for creating a new subscription (`create`), querying the database for subscriptions based on various parameters (`query`, `one_or_none`, `one_or_exception`), and getting a document reference (`get_document_reference`). \n\nIt also includes properties for getting and setting the source of the subscription. The source is an instance of the `SubscriptionSource` class, which includes the platform, event, and id of the source. \n\nThe `QueryParams` inner class is a TypedDict that defines the types of the parameters that can be used in the query methods. \n\nThe code uses Python's asyncio library for asynchronous database operations, and it uses UUIDs for unique identifiers."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/resource_mutex.py", "basename": "resource_mutex.py", "ext": ".py", "service_references": [], "summary": "The code defines a class `ResourceMutexOrm` that represents a mutex (a locking mechanism) for resources in a database. This class is used to ensure that only one process can access a resource at a time, preventing race conditions. The class uses SQLAlchemy, an SQL toolkit and Object-Relational Mapping (ORM) system for Python, to interact with the database.\n\nThe class has four attributes: `id`, `resource_id`, `created`, and `updated`. The `id` is the primary key of the table, and `resource_id` is a unique identifier for each resource. The `created` and `updated` attributes store the timestamps when the mutex was created and last updated.\n\nThe class has two class methods: `acquire` and `release`. The `acquire` method attempts to acquire a lock on a resource. If the lock already exists and it's older than 60 seconds, it forcefully releases the lock and tries to acquire it again. If the lock is still valid (less than 60 seconds old), it denies access. If there's no lock, it creates one and returns True if successful, or logs an error and returns False if not.\n\nThe `release` method releases a lock on a resource by deleting it from the database.\n\nThis file does not start an application server like Express, Flask, Django, Gin, Rack, etc. It's a module that provides a mechanism for managing access to resources in a concurrent environment."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/github_installation.py", "basename": "github_installation.py", "ext": ".py", "service_references": [], "summary": "This Python file defines a class `GithubInstallationOrm` that maps to a database table `github_installations` using SQLAlchemy, an SQL toolkit and Object-Relational Mapping (ORM) system for Python. The table has columns like `team_id`, `id`, `github_install_id`, `created`, and `updated`.\n\nThe class contains several methods:\n\n- `create`: This asynchronous method creates a new instance of the class and adds it to the session. It then flushes the session to write changes to the database.\n- `_build_select`: This method builds a select query based on provided parameters.\n- `one_or_none`: This asynchronous method executes the select query built by `_build_select` and returns one result or None if no result is found.\n- `one_or_exception`: This asynchronous method executes the select query built by `_build_select` and returns one result or raises an exception if no result is found.\n- `api_model` and `api_model_peek`: These properties return instances of `GithubInstallation` and `GithubInstallationPeek` respectively, created from the current ORM object.\n\nThis file does not start an application server. It is a module that defines ORM mapping for a specific table in the database."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/util.py", "basename": "util.py", "ext": ".py", "service_references": [], "summary": "The code in this file does not start an application server. Instead, it defines utility functions for creating foreign key and primary key constraints in a database using SQLAlchemy, a SQL toolkit and Object-Relational Mapping (ORM) system for Python.\n\nThe `make_team_fk` function creates a foreign key constraint on the \"team_id\" field, which references the \"id\" field in the \"teams\" table. If a team is deleted, all related records will also be deleted due to the \"CASCADE\" deletion rule.\n\nThe `make_team_composite_fk` function creates a composite foreign key constraint on the \"team_id\" and another field specified by the `fk_column` parameter. This foreign key references the \"team_id\" and \"id\" fields in another table specified by the `foreign_table` parameter. The \"CASCADE\" deletion rule is also applied here.\n\nThe `UUID_DEFAULT_EXPR` is a SQLAlchemy text clause that generates a random UUID.\n\nThe `make_team_composite_pk` function creates a composite primary key constraint on the \"team_id\" and \"id\" fields."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/slack_installation.py", "basename": "slack_installation.py", "ext": ".py", "service_references": [], "summary": "The code does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe code defines a class `SlackInstallationOrm` that represents a table in a database. The table is named \"slack_sources\" and it contains columns such as `team_id`, `id`, `slack_team_name`, `slack_team_id`, `bot_token`, `bot_token_exp`, `bot_refresh_token`, `created`, and `updated`. \n\nThe class includes methods to create a new row in the table, refresh the bot token, build a select query, and retrieve a single row from the table. It also includes properties to return the data as an instance of the `SlackInstallation` or `SlackInstallationPeek` model.\n\nThe class uses SQLAlchemy for Object-Relational Mapping (ORM), which is a technique that lets you interact with your database, like you would with SQL. In other words, it's providing a method to create, retrieve, update and delete records in your table by using Python code instead of writing SQL queries. \n\nThe code also includes some error handling, specifically for cases where OAuth credentials are missing or invalid."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/__init__.py", "basename": "__init__.py", "ext": ".py", "service_references": [], "summary": "The code is a part of an ORM (Object-Relational Mapping) system in Python. It imports various ORM classes from different modules, such as AccountOrm, AtlassianInstallationOrm, DocumentReferenceOrm, GithubInstallationOrm, SlackInstallationOrm, ConnectInstallationOrm, SubscriptionOrm, TeamOrm, and ResourceMutexOrm. These classes are likely used to interact with corresponding tables in a database. \n\nThe file does not start an application server like Express, Flask, Django, Gin, Rack, etc. It's just a part of the internal structure of the application, specifically the ORM layer."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/team.py", "basename": "team.py", "ext": ".py", "service_references": [], "summary": "The provided code does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThis Python code defines an Object-Relational Mapping (ORM) class `TeamOrm` for a table named \"teams\" in a database. The class is used to interact with the database using SQLAlchemy, an SQL toolkit and ORM for Python. \n\nThe `TeamOrm` class has fields like `id`, `name`, `document_platform`, `created`, `updated`, `beta_whitelisted`, and `subscriptions`. It also has several methods for creating a new team, querying the database for a team by its ID, getting a document client based on the document platform of the team, getting integrations of the team, and getting the destination of the document platform of the team. \n\nThe code also handles different types of document platforms and throws a `NotImplementedError` if an unsupported or not yet implemented document platform is encountered. \n\nThe file imports several other modules and classes, including SQLAlchemy for database operations, various ORM classes for different installations (like Github, Slack, Atlassian), and utility functions from the eave.stdlib library."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/confluence_destination.py", "basename": "confluence_destination.py", "ext": ".py", "service_references": ["confluence"], "summary": "The code does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThis Python code defines two classes, `ConfluenceDestinationOrm` and `ConfluenceClient`, which are used to interact with a Confluence API and a database. The `ConfluenceDestinationOrm` class is an ORM (Object-Relational Mapping) model that represents a table named \"confluence_destinations\" in a database. It provides methods for creating, updating, and querying records in this table.\n\nThe `ConfluenceClient` class is used to interact with the Confluence API. It provides methods for getting available spaces, searching documents, deleting a document, creating a document, and updating a document. These methods make use of various request classes like `GetAvailableSpacesRequest`, `SearchContentRequest`, `DeleteContentRequest`, `CreateContentRequest`, and `UpdateContentRequest` to perform the actual API calls.\n\nThe code uses SQLAlchemy for database interactions and asyncio for handling asynchronous operations."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/document_reference.py", "basename": "document_reference.py", "ext": ".py", "service_references": [], "summary": "This Python code defines a SQLAlchemy ORM model for a table named \"document_references\". The model is defined in a class called `DocumentReferenceOrm` that inherits from a `Base` class. The table has columns for `team_id`, `id`, `document_id`, `document_url`, `created`, and `updated`. \n\nThe `team_id` and `id` fields are of type UUID, while `document_id` and `document_url` are strings. The `created` field is a timestamp that defaults to the current timestamp, and the `updated` field is an optional timestamp that updates to the current timestamp whenever the row is updated.\n\nThe class also includes methods to create a new document reference, and to retrieve a document reference by its team ID and ID. The retrieval methods return either the first matching document reference or None if no match is found.\n\nThis file does not start an application server. It's a module that defines a data model for a specific table in a database."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/connect_installation.py", "basename": "connect_installation.py", "ext": ".py", "service_references": [], "summary": "The code does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThis Python file defines a SQLAlchemy ORM (Object-Relational Mapping) class `ConnectInstallationOrm` for interacting with the `connect_installations` table in a database. The class includes methods for building queries, fetching single or multiple records, creating new records, and updating existing records. It also includes properties to return the data as API models.\n\nThe `ConnectInstallationOrm` class has several fields that map to columns in the `connect_installations` table, including `team_id`, `id`, `product`, `client_key`, `shared_secret`, `base_url`, `org_url`, `atlassian_actor_account_id`, `display_url`, `description`, `created`, and `updated`.\n\nThe class also defines a nested class `QueryParams` which is a TypedDict used for type checking the parameters passed to the query methods.\n\nThe `create` method is used to create a new record in the `connect_installations` table. The `update` method is used to update an existing record. The `_build_query` method is used to build a SQLAlchemy select statement based on the provided parameters.\n\nThe `one_or_exception`, `one_or_none`, and `query` methods are used to execute the built query and return the results. The `api_model` and `api_model_peek` properties are used to return the data as instances of the `ConnectInstallation` and `ConnectInstallationPeek` classes respectively."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/atlassian_installation.py", "basename": "atlassian_installation.py", "ext": ".py", "service_references": [], "summary": "The code in the file `atlassian_installation.py` defines an ORM (Object-Relational Mapping) model for Atlassian installations. The model is defined using SQLAlchemy, a Python SQL toolkit and ORM. The model, `AtlassianInstallationOrm`, represents a table in a database with the name \"atlassian_installations\". \n\nThe table has several columns including `team_id`, `id`, `atlassian_site_name`, `atlassian_cloud_id`, `confluence_space_key`, `oauth_token_encoded`, `created`, and `updated`. The table also has a unique index on the `team_id` and `atlassian_cloud_id` columns.\n\nThe model class includes several methods for querying and manipulating the data in the table. These methods include `_build_select`, `one_or_exception`, `one_or_none`, and `create`. \n\nThe class also includes methods for handling OAuth tokens, such as `oauth_token_decoded`, `build_oauth_session`, and `update_token`. \n\nFinally, the class includes properties that return representations of the data in the form of API models, `api_model` and `api_model_peek`.\n\nThis file does not start an application server. It is a module that defines a database model and related functionality."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/base.py", "basename": "base.py", "ext": ".py", "service_references": [], "summary": "The code is a Python script that defines a base class for SQLAlchemy ORM (Object-Relational Mapping) models and a function to load all modules in the same directory. \n\nThe `Base` class extends `DeclarativeBase` from SQLAlchemy, which is a base class for all declarative base classes. This class is currently empty, but there are commented out methods that suggest it might be used to define common query methods for subclasses.\n\nThe `_load_all` function is used to import all Python files in the same directory as this script. This is typically used to ensure that all ORM model classes are imported, so that their metadata is available to SQLAlchemy.\n\nThe `get_base_metadata` function returns the metadata of the `Base` class, loading all modules in the directory if the metadata has not been loaded yet.\n\nThis file does not start an application server like Express, Flask, Django, Gin, Rack, etc. It's a utility script for working with SQLAlchemy ORM models."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/orm/account.py", "basename": "account.py", "ext": ".py", "service_references": [], "summary": "The code is a Python module that defines an Object-Relational Mapping (ORM) class for an \"Account\" in a database. This class is used to interact with the \"accounts\" table in the database. The ORM class includes methods for creating an account, selecting an account based on various parameters, verifying OAuth tokens, refreshing OAuth tokens, and getting the team associated with the account. \n\nThe AccountOrm class includes fields for team_id, id, visitor_id, opaque_utm_params, auth_provider, auth_id, access_token, refresh_token, email, created, and updated. It also includes two properties that return the account data as instances of the AuthenticatedAccount and AnalyticsAccount classes.\n\nThe module does not start an application server. It is a part of the internal ORM system of an application and is likely used by other parts of the application to interact with the \"accounts\" table in the database. The application itself could be using any server technology, but this specific module does not start or interact directly with the server."}]}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/document_client.py", "basename": "document_client.py", "ext": ".py", "service_references": [], "summary": "The code defines a Python module for interacting with documents in a system. It does not start an application server.\n\nThe module defines a data class `DocumentMetadata` and an abstract base class `DocumentClient`. The `DocumentMetadata` class is a lightweight version of a document reference without the overhead of Object-Relational Mapping (ORM). It contains two fields: `id` and `url`.\n\nThe `DocumentClient` class is an interface that defines four methods: `create_document`, `update_document`, `search_documents`, and `delete_document`. These methods are designed to be asynchronous (i.e., they are defined with the `async` keyword), indicating that they are intended for use in an asynchronous context, such as in an application that uses asyncio or another event-driven framework.\n\nEach method in the `DocumentClient` class is decorated with the `@abc.abstractmethod` decorator, which means that they must be implemented by any concrete (i.e., non-abstract) subclass of `DocumentClient`. The methods all take a keyword-only argument `ctx` of type `Optional[LogContext]`, which suggests that they support optional logging of their operations."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/config.py", "basename": "config.py", "ext": ".py", "service_references": [], "summary": "The code in the file `config.py` defines a class `AppConfig` that inherits from `EaveConfig` in the `eave.stdlib.config` module. This class is used to manage the configuration of an application, specifically dealing with environment variables and secrets related to database connection and Google OAuth credentials.\n\nThe class has several properties that fetch and return various configuration values:\n\n- `eave_origin`: returns an instance of `EaveOrigin`.\n- `db_host`, `db_user`, `db_pass`, `db_name`: return the host, user, password, and database name for a database connection. The values are fetched from environment variables if the application is in development mode, or from secrets if not.\n- `eave_google_oauth_client_credentials`: returns a dictionary of Google OAuth client credentials, fetched from a secret.\n- `eave_google_oauth_client_id`: returns the Google OAuth client ID, extracted from the client credentials.\n- `eave_beta_prewhitelisted_emails`: returns a list of pre-whitelisted email addresses for a beta version of the application. The list is fetched from an environment variable or a secret, depending on the mode of the application.\n\nAt the end of the file, an instance of `AppConfig` is created and assigned to `app_config`.\n\nThis file does not start an application server like Express, Flask, Django, Gin, Rack, etc. It is a configuration file that is likely imported and used by the main application file."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/database.py", "basename": "database.py", "ext": ".py", "service_references": [], "summary": "The code in this file is not starting an application server. Instead, it is setting up a connection to a PostgreSQL database using SQLAlchemy, an SQL toolkit and Object-Relational Mapping (ORM) system for Python. \n\nThe code imports necessary modules from SQLAlchemy and the application's configuration file. It then creates a database URI using the configuration details (host, username, password, database name) and the PostgreSQL driver. \n\nAn asynchronous engine is created using this URI, with echo set to False (meaning SQL statements won't be logged) and pool_pre_ping set to True (which tests the connectivity to the database before each connection is used). \n\nFinally, an asynchronous session factory is created using the engine. This factory can be used to create sessions that automatically commit changes and close when their context manager exits. An example of how to use this session factory is provided in the comments."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/internal/__init__.py", "basename": "__init__.py", "ext": ".py", "service_references": [], "summary": "The code in this file is importing different modules from the same directory. It imports a module named 'database', 'config', 'orm', and 'oauth'. The 'config' module is imported with an alias 'app_config'. However, this file does not start an application server like Express, Flask, Django, Gin, Rack, etc. It's just importing modules for use elsewhere in the application."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/middlewares", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/middlewares/team_lookup.py", "basename": "team_lookup.py", "ext": ".py", "service_references": [], "summary": "The code is a Python script that defines a middleware for an ASGI (Asynchronous Server Gateway Interface) application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe middleware is named `TeamLookupASGIMiddleware` and it extends from `EaveASGIMiddleware`. The purpose of this middleware is to look up a team ID from the HTTP headers of a request and validate it. \n\nIn the `__call__` method, it checks if the scope type is \"http\". If it is, it calls the `_lookup_team` method to perform the team lookup operation. After that, it proceeds to call the next middleware or endpoint in the ASGI application.\n\nThe `_lookup_team` method retrieves the team ID from the HTTP headers using the `get_header_value` function. If a team ID is already set in the request context (possibly by another middleware), it checks if the team ID in the context matches the one in the headers. If they don't match, it raises a `BadRequestError`. If no team ID is found in the headers, it raises a `MissingRequiredHeaderError`.\n\nIf a team ID is found in the headers and it's not already set in the context, it tries to parse it as a UUID. If the parsing fails, it raises a `ValueError`. Then, it starts a database session and tries to find a team with that ID in the database. If no team is found, it raises an exception. If a team is found, it sets the team ID in the request context."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/middlewares/__init__.py", "basename": "__init__.py", "ext": ".py", "service_references": []}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/middlewares/development_bypass.py", "basename": "development_bypass.py", "ext": ".py", "service_references": [], "summary": "The code is written in Python and it does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThis code defines a middleware function `development_bypass_auth` for bypassing authentication in a development environment. It is used to bypass the authentication verification process during development for easier testing and debugging. \n\nThe function takes an HTTPScope object as an argument, which represents the scope of an HTTP request. It loads the request state and logs a warning message indicating that authentication verification is being bypassed. \n\nIt then retrieves the account ID from the authorization header of the HTTP request. If no account ID is found, it raises an exception.\n\nThe function then starts a database session and retrieves the account associated with the account ID from the database. If no account is found, it raises an exception.\n\nFinally, it sets the account ID in the context of the request state."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/middlewares/authentication.py", "basename": "authentication.py", "ext": ".py", "service_references": [], "summary": "This Python code is a middleware for an ASGI (Asynchronous Server Gateway Interface) application, which is a standard interface between web servers and web applications. It does not start an application server itself.\n\nThe code defines a class `AuthASGIMiddleware` that extends from `EaveASGIMiddleware`. This middleware is responsible for handling authentication in the application. When a request comes in, it checks if the request is of type \"http\". If it is, it checks if development bypass is allowed. If it is, it performs development bypass authentication. If not, it verifies the authentication.\n\nThe `_verify_auth` method is used to verify the authentication. It loads the request state and retrieves the account ID from the headers. If the account ID is not present, it raises an exception. It then retrieves the access token from the bearer token in the request. If the access token is not present or malformed, it raises a `BadRequestError`.\n\nThe code then starts a database session and retrieves the account with the given account ID and access token. It tries to verify the OAuth token of the account. If the access token has expired, it refreshes the OAuth token and verifies it again.\n\nFinally, it sets the account ID and team ID in the context of the request state."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/oauth", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/oauth/github_oauth.py", "basename": "github_oauth.py", "ext": ".py", "service_references": ["github"], "summary": "This Python code does not start an application server like Express, Flask, Django, Gin, Rack, etc. Instead, it defines two classes `GithubOAuthAuthorize` and `GithubOAuthCallback`, which are subclasses of `HTTPEndpoint`. These classes are likely used as part of a larger web application, possibly built with a framework like Starlette or FastAPI.\n\nThe `GithubOAuthAuthorize` class defines a `get` method that generates a GitHub authorization URL and sets various cookies related to user tracking and OAuth state. It then returns a redirect response to the generated authorization URL.\n\nThe `GithubOAuthCallback` class also defines a `get` method that handles the callback from GitHub after the user has authorized the application. It verifies the OAuth state, checks if the user is already logged in, and then either updates an existing GitHub installation or creates a new one associated with the user's account. It also logs various events for analytics purposes.\n\nThe code uses various libraries and modules for handling OAuth, cookies, analytics, logging, and interacting with a database. It also uses some custom modules from the `eave` package."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/oauth/slack_oauth.py", "basename": "slack_oauth.py", "ext": ".py", "service_references": ["slack"], "summary": "This Python code does not start an application server. It is a module that handles Slack's OAuth process for an application. It uses the Starlette framework for handling HTTP requests and responses, and OAuthLib for generating OAuth tokens.\n\nThe module defines two classes: `SlackOAuthAuthorize` and `SlackOAuthCallback`. \n\n`SlackOAuthAuthorize` has a single method `get` which generates an authorization URL for Slack's OAuth process, sets tracking cookies, saves the state of the OAuth process, and returns a redirect response to the authorization URL.\n\n`SlackOAuthCallback` inherits from a base OAuth callback class and overrides its `get` method. This method handles the callback from Slack's OAuth process. It checks if the callback is valid, retrieves access tokens and user information from Slack, creates or updates an account in the application's database, and redirects the user to a specific location in Slack.\n\nThe `_update_or_create_slack_installation` method in `SlackOAuthCallback` either updates an existing Slack installation in the database or creates a new one. It also logs an event if there's an attempt to create a duplicate integration.\n\nThe `_run_post_install_procedures` method logs an event when a new integration is added and sends a welcome message to the user in Slack."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/oauth/__init__.py", "basename": "__init__.py", "ext": ".py", "service_references": [], "summary": "This Python code does not start an application server. It imports the `enum` module and defines a constant string `EAVE_ERROR_CODE_QP` with the value \"ev_error_code\". It also defines an enumeration `EaveOnboardingErrorCode` with a single member `already_linked` that has a string value of \"already_linked\"."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/oauth/shared.py", "basename": "shared.py", "ext": ".py", "service_references": ["slack"], "summary": "This Python code is part of a larger application, possibly a web application, but it does not start an application server itself. The code is primarily concerned with handling OAuth authentication and user account management.\n\nThe code includes several functions for handling OAuth state verification, setting redirect responses, setting error codes, and checking if an email is whitelisted for beta access. \n\nThere are also asynchronous functions for getting a logged-in user's account details, checking for an existing account with a given provider and ID, creating a new account and team, and getting or creating an account based on the provided details. \n\nThese functions interact with the application's database to retrieve or update user account information. They also handle setting authentication cookies in the response headers to log the user into their account or update the cookies if they were already logged in.\n\nThe code also includes functionality to log events such as account creation and to send notifications to a Slack channel when a new account is registered. \n\nThe code uses several libraries including `http`, `re`, `typing`, `urllib.parse`, `starlette.requests`, `starlette.responses`, and several modules from the `eave` package."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/oauth/google_oauth.py", "basename": "google_oauth.py", "ext": ".py", "service_references": ["google_oauth"], "summary": "The code in the file google_oauth.py is part of an application that uses Starlette, a lightweight ASGI framework/toolkit for building asynchronous services in Python. It does not start an application server itself.\n\nThe file contains two classes: GoogleOAuthAuthorize and GoogleOAuthCallback. These classes are used to handle Google OAuth authorization and callback processes.\n\nThe GoogleOAuthAuthorize class has a get method that prepares an OAuth flow with Google, sets tracking cookies, saves state cookies, and returns a redirect response to the Google OAuth authorization URL.\n\nThe GoogleOAuthCallback class extends a base class for OAuth callbacks. Its get method handles the callback from Google after user authorization. It checks the validity of the callback, fetches the token, decodes the ID token, and then either gets an existing account or creates a new one with the provided information. If the credentials do not contain an ID token, it raises a MissingOAuthCredentialsError."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/oauth/atlassian_oauth.py", "basename": "atlassian_oauth.py", "ext": ".py", "service_references": ["atlassian"], "summary": "The code in the file `atlassian_oauth.py` does not start an application server. It is a module in a Python application that handles OAuth authorization and callback for Atlassian services. \n\nThe module imports various dependencies and declares two classes: `AtlassianOAuthAuthorize` and `AtlassianOAuthCallback`. \n\n`AtlassianOAuthAuthorize` has a single method `get` that initiates the OAuth flow by creating an OAuth session, getting the authorization URL, setting tracking cookies, saving the state cookie, and returning a redirect response to the authorization URL.\n\n`AtlassianOAuthCallback` extends from `base.BaseOAuthCallback` and overrides its `get` method. This method handles the OAuth callback. It validates the callback, fetches the OAuth token, gets user information, links the Connect installation, and updates or creates Atlassian installation. \n\nThe class also contains several helper methods such as `_link_connect_installation`, `_get_matching_connect_installations`, `_update_eave_team_document_platform`, `_maybe_set_default_confluence_space`, and `_update_or_create_atlassian_install`. These methods perform various tasks related to linking installations, updating team document platforms, setting default Confluence space, and updating or creating Atlassian installations."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/oauth/base.py", "basename": "base.py", "ext": ".py", "service_references": [], "summary": "This Python code is part of a larger application, possibly a web server, but it does not start an application server itself. It defines a class called `BaseOAuthCallback` which extends from `HTTPEndpoint`. This class is used to handle OAuth callbacks.\n\nThe `BaseOAuthCallback` class has several attributes including a request, response, state, code, error, error description, auth provider, and eave state. It has two methods: `get` and `_check_valid_callback`.\n\nThe `get` method is an asynchronous function that takes a request as an argument and returns a response. It retrieves the state, code, error, and error description from the request's query parameters. It verifies the OAuth state using a shared function and loads the eave state. If the state is valid, it assigns the retrieved values to the class attributes and returns the response.\n\nThe `_check_valid_callback` method checks if the callback is valid. If there is an error or if the code is missing, it logs a warning message, cancels the flow using a shared function, and returns False. If there are no issues, it returns True. \n\nThe code uses the Starlette framework for Python asynchronous web applications. Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services."}]}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/github_integration.py", "basename": "github_integration.py", "ext": ".py", "service_references": ["github"], "summary": "The code is from a Python file that does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe file is part of a larger application, possibly a web application, that integrates with GitHub. It defines a class `GithubIntegration` that inherits from `HTTPEndpoint`. This class has an asynchronous method `post` which handles HTTP POST requests. \n\nThe `post` method receives a request, extracts the JSON body, and parses it into a `GetGithubInstallation.RequestBody` object. It then starts a database session and attempts to fetch a GitHub installation and associated team from the database using the provided GitHub installation ID. If the installation is not found, it raises a `NotFoundError`. \n\nFinally, it returns a JSON response containing the GitHub installation and team details. The response is structured according to the `GetGithubInstallation.ResponseBody` model."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/documents.py", "basename": "documents.py", "ext": ".py", "service_references": [], "summary": "The code does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe code defines three classes: `UpsertDocument`, `SearchDocuments`, and `DeleteDocument`. Each class is a subclass of `eave.core.public.http_endpoint.HTTPEndpoint` and defines an asynchronous method `post` that handles HTTP POST requests.\n\n`UpsertDocument` class handles the creation or updating of a document. It first checks if the document exists. If it does not, it creates a new document and logs the event. If it does exist, it updates the document and logs the event. It then updates all subscriptions without a document reference.\n\n`SearchDocuments` class handles the searching of documents. It logs the event of searching for documents.\n\n`DeleteDocument` class handles the deletion of a document. It deletes the document and all its subscriptions, then logs the event.\n\nAll classes use the Starlette library's `Request` and `Response` objects to handle HTTP requests and responses. They also use the Eave library for various operations such as analytics, database operations, and exception handling."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/subscriptions.py", "basename": "subscriptions.py", "ext": ".py", "service_references": [], "summary": "The code does not start an application server such as Express, Flask, Django, Gin, Rack, etc. \n\nThis Python code defines three classes: `GetSubscription`, `CreateSubscription`, and `DeleteSubscription`. Each class inherits from `HTTPEndpoint` and implements a `post` method, which suggests that these classes are used to handle HTTP POST requests in a web application. \n\nThe `GetSubscription` class retrieves a subscription from a database. If the subscription does not exist, it returns a response with null values instead of throwing an error.\n\nThe `CreateSubscription` class creates a new subscription in the database if it does not already exist. If the subscription already exists, it simply returns the existing subscription. The HTTP status code in the response indicates whether a new subscription was created (201 Created) or an existing one was returned (200 OK).\n\nThe `DeleteSubscription` class deletes a subscription from the database if it exists and returns an HTTP 200 OK status code. \n\nAll three classes use the Starlette library for handling requests and responses, and they interact with a database using an ORM (Object-Relational Mapping) library. The specific database and ORM are not clear from the provided code."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/__init__.py", "basename": "__init__.py", "ext": ".py", "service_references": []}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/team.py", "basename": "team.py", "ext": ".py", "service_references": ["confluence"], "summary": "The code does not start an application server. It is a Python module that defines two HTTP endpoints for a web application, likely to be used in a larger framework such as Flask or Django. The module imports various dependencies, including database and ORM (Object-Relational Mapping) modules, HTTP request and response objects, and utility functions.\n\nThe first class, `GetTeamEndpoint`, defines a POST endpoint that retrieves information about a team and its integrations from a database. It uses the `EaveRequestState` to load the request, queries the database for the team and its integrations, and returns a JSON response with this information.\n\nThe second class, `UpsertConfluenceDestinationAuthedEndpoint`, also defines a POST endpoint. This endpoint updates or inserts (upserts) a Confluence destination for a team in the database. It loads the request, parses the request body, queries the database for the team and its Confluence installation, upserts the Confluence destination, and returns a JSON response with the team and Confluence destination information."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/noop.py", "basename": "noop.py", "ext": ".py", "service_references": [], "summary": "This Python code defines a class `NoopRequest` that extends from `HTTPEndpoint`. The `NoopRequest` class has an asynchronous method `get` which takes a `Request` object as an argument and returns a `Response` object. The `get` method doesn't perform any operation, hence the name \"Noop\" (short for \"no operation\").\n\nThe code does not start an application server. It's likely a part of a larger application, possibly using the Starlette framework (a lightweight ASGI framework for building high performance asyncio services)."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/atlassian_integration.py", "basename": "atlassian_integration.py", "ext": ".py", "service_references": [], "summary": "This Python code does not start an application server. It is a module in a larger application, likely a web application given the use of HTTP endpoints and requests/responses. \n\nThe code defines a class `AtlassianIntegration` that extends `HTTPEndpoint`. This class has a single asynchronous method `post` which handles HTTP POST requests. \n\nThe `post` method takes in a request, extracts the JSON body, and parses it into an object of type `GetAtlassianInstallation.RequestBody`. \n\nIt then starts a database session and attempts to retrieve an Atlassian installation and associated team from the database using the parsed data from the request. If it cannot find the installation, it raises a `NotFoundError`. \n\nFinally, it returns a JSON response containing the Atlassian installation and team data. \n\nThe code uses the Starlette library for handling HTTP requests and responses, and Eave's internal libraries for database operations and API utilities."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/connect_integration.py", "basename": "connect_integration.py", "ext": ".py", "service_references": [], "summary": "The code does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThis Python code defines two HTTP endpoints for handling requests related to \"Connect Integrations\". The endpoints are defined as classes that inherit from the HTTPEndpoint class. \n\nThe first class, QueryConnectIntegrationEndpoint, defines a POST endpoint that queries the database for a specific Connect Integration based on the product, client key, and team ID provided in the request body. If the integration is found, it returns the team and integration details. If not, it returns a 404 Not Found status.\n\nThe second class, RegisterConnectIntegrationEndpoint, also defines a POST endpoint. This endpoint either creates a new Connect Integration or updates an existing one based on the client key provided in the request body. The endpoint also logs an event to analytics indicating whether a new integration was added or an existing one was updated. The response includes the team and integration details. \n\nThe code uses the Starlette library for handling HTTP requests and responses, and the Eave library for database operations and analytics logging."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/authed_account.py", "basename": "authed_account.py", "ext": ".py", "service_references": [], "summary": "The code in this file does not start an application server. It is a Python module that defines two classes: `GetAuthedAccount` and `GetAuthedAccountTeamIntegrations`. Both classes are subclasses of `HTTPEndpoint` from the `eave.core.public.http_endpoint` module, which suggests they are used to handle HTTP requests in a web application.\n\nThe `GetAuthedAccount` class defines a `post` method that handles POST requests. It retrieves the authenticated account and team information from the database using the `EaveRequestState` loaded from the request, and returns a JSON response containing this information.\n\nThe `GetAuthedAccountTeamIntegrations` class also defines a `post` method that handles POST requests. It retrieves the authenticated account, team, integrations, and destination information from the database using the `EaveRequestState` loaded from the request, and returns a JSON response containing this information."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/slack_integration.py", "basename": "slack_integration.py", "ext": ".py", "service_references": ["slack"], "summary": "This Python code does not start an application server. It is a module in a larger application, likely a web application given the use of HTTP requests and responses. \n\nThe module defines a class `SlackIntegration` which is a subclass of `HTTPEndpoint`. This class has a single asynchronous method `post` which handles POST requests. \n\nThe `post` method receives a request, extracts the JSON body, and uses it to create a `GetSlackInstallation.RequestBody` object. It then begins a database session and attempts to find a `SlackInstallationOrm` object with the given `slack_team_id`. If it cannot find such an object, it raises a `NotFoundError`. \n\nIf it does find a `SlackInstallationOrm`, it ensures that the access tokens for this installation are up to date. It then retrieves the corresponding `TeamOrm` object from the database.\n\nFinally, it creates a `GetSlackInstallation.ResponseBody` object with the `SlackInstallationOrm` and `TeamOrm` objects, converts this to JSON, and returns it as the response to the POST request. \n\nThis code is part of an integration with Slack, specifically dealing with retrieving and updating Slack installation information."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/requests/status.py", "basename": "status.py", "ext": ".py", "service_references": [], "summary": "The code does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThis Python code defines several HTTP endpoints for a web application using the Starlette library. The endpoints are defined within classes that inherit from the HTTPEndpoint class. \n\nThe `StatusRequest` class defines endpoints for HTTP methods (POST, DELETE, HEAD, OPTIONS, GET). All these methods return the result of the `get` method. The `get` method checks the status of a database by executing a simple SQL query (\"SELECT 1\"). If the query returns no rows, it sets the HTTP status code to \"SERVICE_UNAVAILABLE\" and the status to \"UNHEALTHY\". The response is a JSON object with the status information.\n\nThe `WarmupRequest`, `StartRequest`, and `StopRequest` classes each define a single GET endpoint. The `get` method of `WarmupRequest` preloads some configuration data and returns an \"OK\" response. The `get` methods of `StartRequest` and `StopRequest` simply return an \"OK\" response."}]}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/exception_handlers.py", "basename": "exception_handlers.py", "ext": ".py", "service_references": [], "summary": "The code in the file `exception_handlers.py` defines a set of exception handlers for different types of HTTP errors in a web application. The file does not start an application server itself.\n\nThe exception handlers are functions that take a request and an exception as input, log the exception, create an error response model with the appropriate HTTP status code and message, and return a JSON response with the error model and status code. The error response model includes the status code, error message, and some context from the request.\n\nThe `unauthorized` handler also deletes authentication cookies from the response. The `validation_error` handler adds validation errors to the context if the exception is a `pydantic.ValidationError`.\n\nAt the end of the file, a mapping is defined that associates exceptions with their corresponding handlers. The mapping is commented out except for `pydantic.ValidationError` and a generic `Exception`, which is used by Starlette's `ServerErrorMiddleware`."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/__init__.py", "basename": "__init__.py", "ext": ".py", "service_references": [], "summary": "The code is importing modules from the same directory. Specifically, it imports 'exception_handlers' and 'http_endpoint'. However, there's no evidence in the provided code that an application server like Express, Flask, Django, Gin, Rack, etc. is being started."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/public/http_endpoint.py", "basename": "http_endpoint.py", "ext": ".py", "service_references": [], "summary": "The code defines a class `HTTPEndpoint` in Python, which is a custom implementation of the Starlette's HTTPEndpoint with improved typing. Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. \n\nThe `HTTPEndpoint` class is initialized with a scope, receive and send parameters. The scope must be of type \"http\". The class also defines the allowed HTTP methods (GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS) and checks if these methods are implemented in the class.\n\nThe `dispatch` method is used to handle incoming requests. It creates a `Request` object and determines the appropriate handler based on the request method. If the handler is asynchronous, it awaits the handler; otherwise, it runs the handler in a thread pool.\n\nThe `method_not_allowed` method is used to handle requests with methods that are not allowed. It raises an HTTPException if the application is running inside a Starlette application; otherwise, it returns a plain text response with a 405 status code.\n\nThis file does not start an application server like Express, Flask, Django, Gin, Rack etc. It's more of a utility or helper class for handling HTTP requests in an ASGI application."}]}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/__init__.py", "basename": "__init__.py", "ext": ".py", "service_references": [], "summary": "The code is a part of an application written in Python. It doesn't start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe code is importing two modules from the 'eave.stdlib' package: 'eave_origins' and 'eave_signing'. These modules are likely used for handling authentication tokens and signing them.\n\nThe 'EAVE_API_SIGNING_KEY' variable is set to the result of the 'get_key' function from the 'eave_signing' module, using a value from the 'EaveOrigin' enumeration in the 'eave_origins' module.\n\nThe 'EAVE_API_JWT_ISSUER' variable is set to a value from the 'EaveOrigin' enumeration in the 'eave_origins' module. This value likely represents the issuer of JWT (JSON Web Tokens) used for authentication in the API."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/core/eave/core/app.py", "basename": "app.py", "ext": ".py", "service_references": ["atlassian", "github", "slack"], "summary": "The code is written in Python and uses the Starlette framework, an asynchronous web server gateway interface (ASGI) framework, to create a web application. It imports various modules and functions for handling different types of requests and operations, such as authentication, team lookup, document operations, and integrations with Atlassian, Github, and Slack.\n\nThe `make_route` function is used to define the routes for the application. It takes an `EndpointConfiguration` object and an `ASGI3Application` object as arguments and returns a `Route` object. This function also sets up various middlewares based on the configuration of the endpoint.\n\nThe `routes` list contains all the routes for the application. Each route is defined using the `Route` class or the `make_route` function.\n\nThe `graceful_shutdown` function is an asynchronous function that is called when the application is shutting down. It disposes of the database engine and closes the cache client if it has been initialized.\n\nFinally, an instance of the `Starlette` class is created with the defined routes, middleware, exception handlers, and shutdown function. This instance represents the web application."}], "service_name": "eave_core_server"}], "files": []}], "files": []}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/src", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/src/api", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/src/api/routes.ts", "basename": "routes.ts", "ext": ".ts", "service_references": [], "summary": "This code is written in TypeScript and uses the Express.js framework. It defines a function called `InternalApiRouter` that takes an object with a property `addon` of type `AddOn` from 'atlassian-connect-express' as an argument. This function creates a new instance of an Express Router, which is not currently used, and then returns it. The file does not start an application server itself; it only exports a function that creates and returns a router."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/src/events", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/src/events/routes.ts", "basename": "routes.ts", "ext": ".ts", "service_references": ["atlassian"], "summary": "The code is written in TypeScript and is part of a larger application that uses the Express.js framework. It does not start an application server itself, but it exports two functions that are likely used elsewhere in the application to set up routing and middleware for handling webhooks.\n\nThe first function, `applyWebhookMiddlewares`, takes an Express application instance, an Atlassian AddOn instance, and a path as arguments. It applies two middlewares to the provided path: `express.json()` for parsing incoming request bodies as JSON, and `addon.middleware()` which is likely specific middleware provided by the Atlassian AddOn.\n\nThe second function, `WebhookRouter`, creates and returns an Express router. This router uses a `LifecycleRouter` (imported from a library) and a POST route at its root path. The POST route is protected by `addon.authenticate()`, which presumably ensures that incoming requests are authenticated. \n\nWhen a POST request is received, it logs the event, creates an authenticated Jira client, and then handles the request based on the `webhookEvent` property of the request body. If the `webhookEvent` is 'comment_created', it calls a `commentCreatedEventHandler`. If the `webhookEvent` is not recognized, it logs a warning and sends a 200 status response. If any errors occur during this process, they are passed to the next middleware in the chain."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/src/events/comment-created.ts", "basename": "comment-created.ts", "ext": ".ts", "service_references": ["jira", "openai"], "summary": "The code in this file does not start an application server. Instead, it defines and exports an asynchronous function `commentCreatedEventHandler` which is likely used as a callback for a specific event in an application, specifically when a comment is created in Jira.\n\nThe function takes an object with three properties: `req` (an Express request object), `res` (an Express response object), and `jiraClient` (an instance of a Jira client). It processes the incoming request, checks if it contains the necessary data, and responds accordingly.\n\nThe function first checks if the payload contains an issue and if the author of the comment is not an app. If these conditions are met, it checks if Eave (presumably a user or a bot) is mentioned in the comment. If Eave is mentioned, it logs the event and cleans the comment body. \n\nThen, it uses OpenAI to determine the intent of the comment and to extract a search query from it. If the intent is 'search', it performs a search operation using the extracted query and builds a response based on the search results. This response is then posted as a comment in Jira.\n\nThe file also contains several helper functions to clean the comment body, get the search query, determine the intent of the message, build the response, and check if a user is Eave."}]}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/src/app.ts", "basename": "app.ts", "ext": ".ts", "service_references": ["atlassian_connect_express", "jira", "google_app_engine"], "summary": "This code is for a Node.js application using the Express.js framework. It sets up an Atlassian Connect Express (ACE) add-on for Jira, which is a project management tool. The add-on uses various middlewares for security, request handling, and response handling. \n\nThe code also sets up routes for the application. It uses Google App Engine's lifecycle router, a status router, a webhook router for event handling, and an internal API router. \n\nThe add-on's configuration is adjusted based on the environment. In a production environment, the base URL is set to a specific value. \n\nThe code does not start an application server itself, but it exports the Express app and the ACE add-on, which can be used to start a server in another module."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/src/types.ts", "basename": "types.ts", "ext": ".ts", "service_references": ["jira"], "summary": "The code does not start an application server like Express, Flask, Django, Gin, Rack, etc. Instead, it defines TypeScript interfaces for various Jira-related entities. These interfaces are used to type-check the structure of objects that represent resources in the Jira API.\n\nThe interfaces include `JiraProject`, `JiraIssueType`, `JiraStatusCategory`, `JiraStatus`, `JiraUser`, `JiraIssue`, `JiraAssociatedUsers`, `JiraIssueLinkType`, `JiraChange`, `JiraChangelog`, `JiraComment`, `JiraIdKey`, `JiraStatusId`, `JiraTransition`, and `JiraContext`.\n\nThere are also interfaces for incoming event payloads such as `JiraWebhookEvent` and `JiraCommentCreatedEventPayload`. These are used to type-check the structure of data received from Jira webhooks.\n\nThe file also contains a commented-out interface called `JiraEventPayload` which seems to be specific to the Forge platform.\n\nEach interface extends the `ApiResource` interface, which has a single property `self` of type string. The other interfaces add additional properties that are specific to the type of resource they represent. For example, the `JiraProject` interface adds properties like `id`, `key`, `name`, `projectTypeKey`, etc."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/src/jira-client.ts", "basename": "jira-client.ts", "ext": ".ts", "service_references": ["jira"], "summary": "The code defines a class `JiraClient` that extends the `ConnectClient` class. This class is used to interact with Jira's REST API. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe `JiraClient` class has three methods:\n\n1. `getAuthedJiraClient`: This static method creates an authenticated instance of `JiraClient`. It takes an object as an argument that includes a request object, an `AddOn` instance, and optionally a `teamId` and `clientKey`. It uses these to create an authenticated `ConnectClient` instance and then wraps it in a `JiraClient` instance.\n\n2. `getUser`: This method retrieves a user from Jira based on their account ID. It sends a GET request to the `/rest/api/3/user` endpoint of the Jira API. If the request is successful, it parses the response body as a `JiraUser` object and returns it. If the request fails (i.e., the status code is 400 or higher), it returns `undefined`.\n\n3. `postComment`: This method posts a comment to a Jira issue. It takes an object as an argument that includes the issue ID and the comment body. It sends a POST request to the `/rest/api/3/issue/{issueId}/comment` endpoint of the Jira API. If the request is successful, it returns the response body as a `JiraComment` object. If the request fails, it returns `undefined`."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/src/config.ts", "basename": "config.ts", "ext": ".ts", "service_references": [], "summary": "The code is a configuration file for a Jira application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe file imports two modules, `EaveConfig` and `EaveOrigin`, from the `@eave-fyi/eave-stdlib-ts` package. It then defines a new class `AppConfig` that extends `EaveConfig`. \n\nIn this class, it sets two properties: `eaveOrigin` and `eaveJiraAppAccountId`. The `eaveOrigin` is set to the `eave_jira_app` value from the `EaveOrigin` module. The `eaveJiraAppAccountId` is a hardcoded string value that is the same across all installations for the \"eave-jira\" app key.\n\nFinally, it creates a new instance of `AppConfig` and exports it as the default export of the module. This instance can then be imported and used in other parts of the application."}]}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/config.json", "basename": "config.json", "ext": ".json", "service_references": [], "summary": "This code is a configuration file for a Jira application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe configuration file is divided into two main sections: development and production. Each section contains settings for different environments. \n\nIn both sections, there are settings for the local base URL, whether to set up an install route, the store (which includes the adapter, app key, product type, and eave origin), and the port. \n\nThe development section mentions that the host part of the URL is a placeholder and will be overridden at runtime with the ngrok host. \n\nThe production section also includes a whitelist of domains."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/pm2.config.cjs", "basename": "pm2.config.cjs", "ext": ".cjs", "service_references": [], "summary": "This code is a configuration file for PM2, a process manager for Node.js applications. It does not directly start an application server like Express, Flask, Django, Gin, Rack, etc., but it is used to manage the Node.js application specified in the configuration.\n\nThe configuration exports an object with an \"apps\" array. Inside this array, there is an object that represents a single application named 'jira'. The 'script' property points to the entry point of the application, which is a TypeScript file named 'server.ts'.\n\nThe 'out_file' and 'error_file' properties are set to '/dev/stdout' and '/dev/stderr' respectively, which means that standard output and error will be redirected to these locations.\n\nThe 'interpreter' property specifies the path to the TypeScript Node interpreter (ts-node) located in the project's node_modules directory. The 'interpreter_args' property is set to '--swc', which are the arguments passed to the interpreter.\n\nIn summary, this PM2 configuration file is used to manage a Node.js application written in TypeScript named 'jira'."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/package.json", "basename": "package.json", "ext": ".json", "service_references": [], "summary": "This is a package.json file for a Node.js application. It does not start an application server directly, but it does specify the dependencies and scripts needed to start the application.\n\nThe \"start\" script uses PM2, a process manager for Node.js applications, to start the application using a configuration file named pm2.config.cjs.\n\nThe application has several dependencies, including Express, a popular web application framework for Node.js, and Atlassian Connect Express, a framework for building Atlassian Connect based add-ons. Other dependencies include various libraries from the Eave project, SWC (a super-fast JavaScript/TypeScript compiler), Helmet (a security middleware for Express), and ts-node (a TypeScript execution environment for Node).\n\nThe devDependencies section includes various development tools, such as TypeScript, ESLint (a linter for JavaScript and TypeScript), and several ESLint plugins. It also includes type definitions for Node.js and Express, as well as nodemon (a tool that helps develop Node.js based applications by automatically restarting the node application when file changes in the directory are detected), sqlite3 (a library to interface with the SQLite3 database), and ngrok (a tool that exposes local servers behind NATs and firewalls to the public internet over secure tunnels).\n\nThe comment at the end notes that the \"longjohn\" module must be installed, or else the atlassian-connect-validator will crash the app in development."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/atlassian-connect.json", "basename": "atlassian-connect.json", "ext": ".json", "service_references": [], "summary": "This JSON file appears to be a configuration file for an Atlassian Connect app, specifically for Jira. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe app is named \"Eave\" and its key is \"eave-jira\". The vendor is \"Eave Technologies, Inc.\" and the vendor's website is \"https://www.eave.fyi\". The app uses JWT (JSON Web Tokens) for authentication.\n\nThe lifecycle events of the app (installed, enabled, disabled, uninstalled) are handled by endpoints under \"/events\".\n\nThe app has read and write scopes and has a webhook module set up to handle the \"comment_created\" event at the \"/events\" endpoint.\n\nThe \"links\" object provides the URL of the app's configuration file and the app's website. The \"baseUrl\" and \"self\" link are set dynamically with \"{{localBaseUrl}}\". \n\nLicensing is not enabled for this app."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/jira/server.ts", "basename": "server.ts", "ext": ".ts", "service_references": [], "summary": "The code in the file `apps/jira/server.ts` is used to start an application server. It imports several modules, including `applyShutdownHandlers` and `registerDevApp` from the `@eave-fyi/eave-stdlib-ts` package, as well as `app`, `addon`, and `appConfig` from local files.\n\nThe server is set to listen on a port specified by the `PORT` environment variable, or port 5500 if no such variable is set. The server is bound to the IP address '0.0.0.0', meaning it can accept connections from any IP address.\n\nWhen the server starts, it logs a message indicating the port it's listening on and the current Node.js environment. If the application is running in development mode, it also registers a development application using the `registerDevApp` function.\n\nFinally, the `applyShutdownHandlers` function is called with the server as an argument, presumably to handle any necessary cleanup when the server is shut down.\n\nThe specific application server framework being used isn't clear from this code alone, but it's likely to be Express or a similar Node.js-based framework, given the use of `app.listen()`."}], "service_name": "jira_server"}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/github", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/graphql", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/graphql/getRefs.graphql", "basename": "getRefs.graphql", "ext": ".graphql", "service_references": ["github"], "summary": "This code does not start an application server. Instead, it is a GraphQL query that fetches data from a GitHub repository. The query takes four parameters: the owner of the repository, the name of the repository, a query string to filter the references, and a prefix to filter the references. It retrieves the first 10 references (refs) from the specified repository, ordered by the date of the commit associated with each tag in descending order. For each reference, it fetches the name."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/graphql/getFileContentsByPath.graphql", "basename": "getFileContentsByPath.graphql", "ext": ".graphql", "service_references": ["github"], "summary": "This code does not start an application server. It is a GraphQL query that is used to fetch file contents from a GitHub repository. The query takes three parameters: the owner of the repository, the name of the repository, and an expression which likely refers to the file path. \n\nThe query fetches the repository and then accesses an object within the repository using the provided expression. It retrieves the type of the object, its commit resource path, its ID, and its OID (Object ID). \n\nIf the object is a Blob (a file), it retrieves the text of the file. If the object is a Tree (a directory), it retrieves the names of all entries in the directory and for each entry that is a Blob, it retrieves its OID and text."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/graphql/getResource.graphql", "basename": "getResource.graphql", "ext": ".graphql", "service_references": ["github"], "summary": "This code does not start an application server. It is a GraphQL query that is used to fetch data from a GitHub API. The query is named 'resource' and it takes a parameter 'resourceUrl' of type URI. The query fetches the owner's login and the repository name from the resource specified by the URL."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/graphql/getFileContents.graphql", "basename": "getFileContents.graphql", "ext": ".graphql", "service_references": ["github"], "summary": "This is a GraphQL query that retrieves the contents of a file from a specific commit in a GitHub repository. It does not start an application server. \n\nThe query takes four parameters: the owner of the repository, the name of the repository, the ID of the commit (commitOid), and the path of the file. It retrieves the repository's ID, owner's name (if the owner is an organization), and name. \n\nFor the specified commit, it retrieves the commit's ID and OID (Object ID). It also retrieves information about the specified file in that commit, including its OID, name, path, and programming language. If the file object is a Blob (Binary Large OBject), it retrieves the text content of the file."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/lib", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/lib/graphql-util.ts", "basename": "graphql-util.ts", "ext": ".ts", "service_references": ["github"], "summary": "The code in the file `graphql-util.ts` does not start an application server. Instead, it provides utility functions for interacting with GitHub's GraphQL API. \n\nThe `loadQuery` function reads a GraphQL query from a file, validates it, and caches it for future use. If the query is already in the cache, it retrieves it from there instead of reading from the file again. \n\nThe `getProjectV2ItemFieldValue` function uses the `loadQuery` function to load a query and then executes it using the provided context and variables. It retrieves a field value from a ProjectV2Item node in GitHub's GraphQL API.\n\nThe commented out functions `getLabel` and `getProjectV2Field` also load and execute queries, but they are currently not in use.\n\nThe `getIssueByNodeId` function loads and executes a query to retrieve an Issue node from GitHub's GraphQL API using a provided node ID. \n\nAll these functions return promises, making them asynchronous and suitable for use in an environment where non-blocking operations are required."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/lib/cache.ts", "basename": "cache.ts", "ext": ".ts", "service_references": [], "summary": "The code in this file is not starting an application server. Instead, it is importing a module named 'EphemeralCache' from a package '@eave-fyi/eave-stdlib-ts/src/cache.js' and then creating a new instance of this module. This instance is then exported as the default export of this module. The 'EphemeralCache' is likely used to temporarily store data in memory for quick access."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/lib/octokit-util.ts", "basename": "octokit-util.ts", "ext": ".ts", "service_references": ["github"], "summary": "This code does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe code is part of a utility library for interacting with GitHub's API using the Octokit library. It exports three asynchronous functions: \n\n1. `createOctokitClient(installationId: number)`: This function creates and returns an Octokit client for a given GitHub App installation ID. \n\n2. `createAppClient()`: This function creates and returns a new instance of the GitHub App client using the application ID, private key, and webhook secret from the application's configuration.\n\n3. `getInstallationId(eaveTeamId: string, ctx: LogContext)`: This function retrieves the installation ID of the GitHub integration for a given team ID. If the GitHub integration is missing for the team, it logs an error message and returns null. \n\nThe code also imports several modules, including the Octokit and App classes from the Octokit library, a logging module, a function for getting team information, and the application's configuration."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/api", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/api/routes.ts", "basename": "routes.ts", "ext": ".ts", "service_references": [], "summary": "This code does not start an application server, but it does define a module that can be used in an Express.js application server. The module exports a function `InternalApiRouter` that returns an Express router. This router has two routes defined: a POST route at '/content' and another POST route at '/subscribe'. \n\nThe '/content' route uses the `getSummary` function from the 'content.js' module. This function is called with the request and response objects from the Express route handler. If the function completes successfully, the response is ended. If there is an error, it is passed to the next middleware function.\n\nThe '/subscribe' route works similarly, but it uses the `subscribe` function from the 'subscribe.js' module. Like the '/content' route, it ends the response if the function completes successfully and passes any errors to the next middleware function."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/api/content.ts", "basename": "content.ts", "ext": ".ts", "service_references": ["github"], "summary": "The code in the file `content.ts` is part of a Node.js application that uses the Express.js framework. However, this file does not start an application server. \n\nThe code defines a function `getSummary` that is an Express.js route handler. This function takes a request and a response object, extracts the URL of a GitHub file from the request body, and sends a response with the content of the file. \n\nThe file uses the Octokit library to interact with the GitHub API. It defines several helper functions to fetch the content of a GitHub file given its URL. These functions handle various tasks such as fetching the repository by URL, getting file info from the URL, and fetching the raw content of the file.\n\nThe code also includes error handling and logging using the `eaveLogger` object. It logs errors and warnings if there are issues with the input URL, if it can't find the GitHub installation ID, if it can't find the repository or file info, or if it encounters an invalid git object."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/api/repos.ts", "basename": "repos.ts", "ext": ".ts", "service_references": ["github"], "summary": "The code in the file `repos.ts` does not start an application server. It is a TypeScript module that provides functionality for interacting with GitHub repositories using the GitHub API. \n\nThe module exports a single asynchronous function `getSummary(req: Request, res: Response)`. This function takes in a request and response object, presumably from an Express.js server, and returns a Promise that resolves to void. The function uses the Octokit library to interact with the GitHub API. It extracts a URL from the request body and attempts to fetch the content of the file located at that URL. If successful, it sends the content back in the response. If not, it sends an error status.\n\nThe module also contains several helper functions that are used to interact with the GitHub API. These include `getFileContent()`, `getRepositoryByUrl()`, `getFileInfoFromUrl()`, and `getRawContent()`. These functions are used to fetch file content, get repository information by URL, get file information from a URL, and fetch raw file content from a URL, respectively. \n\nThe code also includes extensive logging via the `eaveLogger` object, which is used to log errors and warnings during the execution of these functions."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/api/subscribe.ts", "basename": "subscribe.ts", "ext": ".ts", "service_references": ["github"], "summary": "The code in the file `apps/github/src/api/subscribe.ts` is a module that exports a single asynchronous function named `subscribe`. This function is designed to handle HTTP requests and responses in an Express.js application. It does not start an application server.\n\nThe `subscribe` function takes in a request and a response as arguments. It extracts the team ID from the request headers, and the URL from the request body. It then uses these to create a subscription to a GitHub repository, and sends the response back to the client.\n\nThe function uses several helper functions and modules, such as `getInstallationId` and `createOctokitClient` to interact with the GitHub API, and `createSubscription` to create a new subscription. It also uses the `eaveLogger` for logging errors and other information.\n\nThere are also two helper functions defined within the module: `getRepo` and `getRepoLocation`. The `getRepo` function takes in an Octokit client and a URL, and returns information about the GitHub repository pointed to by the URL. The `getRepoLocation` function parses the GitHub organization name and repository name from a given URL.\n\nThe code also includes several import statements at the beginning, which import various modules and types that are used within the `subscribe` function."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/events", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/events/routes.ts", "basename": "routes.ts", "ext": ".ts", "service_references": [], "summary": "The code is written in TypeScript and uses the Express.js framework to handle HTTP requests. It does not start an application server itself, but it exports functions that can be used in an Express.js application.\n\nThe `applyWebhookMiddlewares` function is used to apply a middleware to the Express.js application. This middleware uses the raw body parser from Express.js to parse incoming requests as raw data instead of JSON. This is done because the GitHub signature verification process requires the exact raw data, and even a slight change caused by JSON parsing could cause the verification to fail. The middleware is applied to a specific path on the application, and it only accepts 'application/json' data with a limit of '5mb'.\n\nThe `WebhookRouter` function creates a new Express.js router and defines a POST route at the root path ('/'). When a POST request is made to this route, it calls the `dispatch` function with the request and response objects. If the `dispatch` function resolves successfully, it ends the response. If it fails, it passes the error to the next middleware in the chain. The function then returns the router."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/events/push.ts", "basename": "push.ts", "ext": ".ts", "service_references": ["github", "openai"], "summary": "The code in the file `push.ts` is a handler function for GitHub push events. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe handler function processes push events from GitHub, specifically those related to branch updates (ignoring tag pushes). It uses the Octokit library to interact with GitHub's API and the Eave library for logging and other operations.\n\nWhen a push event is received, the handler function fetches the team ID associated with the event's installation ID. It then fetches the contents of the files that were modified in the push event.\n\nFor each modified file, the handler checks if there is a subscription for that file. If a subscription exists, it fetches the file's contents and builds a description of the file including its language, path, and repository name.\n\nThe handler then uses OpenAI to generate an explanation of what the code in the file does. This explanation is used to create a document that is associated with the subscription for the file. The document is then upserted (inserted or updated) in a database.\n\nThe handler function handles errors and logs them using the Eave logger. It also contains several TODO comments indicating areas where additional functionality needs to be implemented or existing functionality needs to be improved."}]}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/app.ts", "basename": "app.ts", "ext": ".ts", "service_references": [], "summary": "This code is written in TypeScript and sets up an Express.js application server. It imports several middleware functions and routers from different modules, including common request and response middlewares, internal API middlewares, a helmet middleware for security, and routers for Google App Engine lifecycle events, status, webhooks, and internal APIs.\n\nThe Express application is created and the helmet middleware is applied for basic security. Then, common request middlewares and internal API middlewares are applied to the application. The path for the internal API is set to '/github/api' and the path for webhooks is set to '/github/events'.\n\nA Google App Engine lifecycle router is also used in the application. A root router is created for the '/github' path and it uses the status router, webhook router, and internal API router.\n\nFinally, common response middlewares are applied to the application."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/types.ts", "basename": "types.ts", "ext": ".ts", "service_references": [], "summary": "The code in this file does not start an application server. It is a TypeScript file that is used for type declaration. It imports `LogContext` from a logging module in the `@eave-fyi/eave-stdlib-ts` package and `Octokit` from the `octokit` package. \n\nIt then declares a type `GitHubOperationsContext` which is an object that includes two properties: `octokit` of type `Octokit` and `ctx` of type `LogContext`. This type can be used elsewhere in the application to ensure consistent usage of objects that have this structure."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/dispatch.ts", "basename": "dispatch.ts", "ext": ".ts", "service_references": ["github"], "summary": "The code in the file `dispatch.ts` is a part of an Express application that handles GitHub webhooks. It does not start an application server itself, but exports a function `dispatch` that is likely used as a middleware in an Express application.\n\nThe `dispatch` function is an asynchronous function that takes an Express request and response object, and processes incoming GitHub webhook events. It first extracts necessary information from the request headers and body, such as the event name, delivery id, signature, installation id, and the payload.\n\nIt then verifies the signature of the webhook event to ensure it is from GitHub. If the signature verification fails and the application is not in development or dev mode, it sends a 400 status response.\n\nIf the signature is verified or the application is in development or dev mode, it retrieves a handler for the event from a registry. If no handler is found for the event, it logs a warning and sends a 200 status response.\n\nIf a handler is found, it creates an Octokit client for the installation that sent the webhook event, and passes the payload and Octokit client to the handler. After the handler finishes processing the event, it sends a 200 status response.\n\nThe file also registers a handler for 'push' events at the top of the file using a function from a registry module."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/registry.ts", "basename": "registry.ts", "ext": ".ts", "service_references": ["github"], "summary": "The code does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThis TypeScript file is part of a GitHub application and it manages a registry of event handlers for GitHub webhooks. It imports types from the '@octokit/webhooks' and '@eave-fyi/eave-stdlib-ts/src/logging.js' packages, as well as a custom type from a local file './types.js'. \n\nThe `HandlerFunction` type is declared, which is a function that takes an event and a context as arguments and returns a Promise that resolves to void.\n\nAn empty `registry` object is created to store the event handlers.\n\nTwo functions are exported: \n\n1. `registerHandler` - This function takes a name and a handler function as arguments. It binds the handler function to null and stores it in the registry under the provided name. It also logs that the handler has been registered.\n\n2. `getHandler` - This function takes a name as an argument and returns the corresponding handler function from the registry, or undefined if no such handler exists."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/src/config.ts", "basename": "config.ts", "ext": ".ts", "service_references": [], "summary": "The code in the file `apps/github/src/config.ts` does not start an application server. Instead, it defines a configuration class for a GitHub application. \n\nThe `AppConfig` class extends the `EaveConfig` class from the `@eave-fyi/eave-stdlib-ts` package. It sets the `eaveOrigin` to `EaveOrigin.eave_github_app` and the `eaveGithubAppId` to `'300560'`. \n\nThe class also includes getter methods for retrieving various secrets related to the GitHub application, such as the webhook secret, private key, client ID, and client secret. These secrets are presumably stored in an external secure location and are retrieved using the `getSecret` method of the parent `EaveConfig` class.\n\nFinally, an instance of the `AppConfig` class is created and exported as `appConfig`. This instance can be imported in other parts of the application to access the configuration settings."}], "service_name": "github_express_server"}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/pm2.config.cjs", "basename": "pm2.config.cjs", "ext": ".cjs", "service_references": [], "summary": "This code is a configuration file for PM2, a process manager for Node.js applications. It does not directly start an application server like Express, Flask, Django, Gin, Rack, etc., but it configures how a Node.js application should be managed by PM2.\n\nThe configuration specifies that there is one application named 'github'. The entry point of the application is './server.ts', which is a TypeScript file. The standard output and error of the application are redirected to '/dev/stdout' and '/dev/stderr' respectively.\n\nThe interpreter for the application is specified as 'ts-node', a TypeScript execution environment for Node.js, located in the 'node_modules/.bin' directory relative to the directory of this configuration file. The interpreter is passed '--swc' as an argument, which might be used to enable the SWC (Speedy Web Compiler) for faster TypeScript compilation."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/package.json", "basename": "package.json", "ext": ".json", "service_references": ["github"], "summary": "This is a package.json file for a Node.js application. It does not directly start an application server, but it does specify scripts and dependencies for the application. The \"start\" script uses PM2, a process manager for Node.js applications, to start the application based on the configuration in pm2.config.cjs.\n\nThe application has several dependencies, including Express, which is a web application framework for Node.js. This suggests that the application may be a web server, but the package.json file itself does not start the server.\n\nThe dependencies also include several libraries related to GitHub (such as @octokit/graphql-schema and @octokit/webhooks), suggesting that this application interacts with GitHub in some way. Other dependencies are related to TypeScript and ESLint, indicating that this is a TypeScript application and uses ESLint for linting.\n\nThe \"devDependencies\" section lists packages that are only needed for development and not when running the application in production. These include TypeScript, ESLint and its plugins, and type definitions for various libraries."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/github/server.ts", "basename": "server.ts", "ext": ".ts", "service_references": [], "summary": "The code in the file `apps/github/server.ts` is used to start an application server. It imports a function `applyShutdownHandlers` from a module `@eave-fyi/eave-stdlib-ts/src/api-util.js` and an Express application instance from `./src/app.js`. \n\nThe server is set to listen on a port number that is either provided by the environment variable `PORT` or defaults to 5300 if the environment variable is not set. The server listens on all network interfaces (`0.0.0.0`). \n\nWhen the server starts, it logs a message indicating the port number it's listening on and the current Node.js environment. \n\nThe `applyShutdownHandlers` function is called with the server instance, presumably to handle graceful shutdown of the server when necessary."}], "service_name": "github_server"}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/appengine-default", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/appengine-default/main.py", "basename": "main.py", "ext": ".py", "service_references": [], "summary": "The code in the file apps/appengine-default/main.py is extremely simple. It only contains one line that prints the string \"OK\" to the console. This file does not start an application server like Express, Flask, Django, Gin, Rack, etc."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/api", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/api/routes.ts", "basename": "routes.ts", "ext": ".ts", "service_references": ["confluence"], "summary": "The code is written in TypeScript and uses the Express.js framework to define an API router for a Confluence integration. It imports several modules and functions, including the Express Router and various content management functions like `getAvailableSpaces`, `searchContent`, `createContent`, `updateContent`, and `deleteContent`.\n\nThe `InternalApiRouter` function exports a router with several POST endpoints: \n\n- `/spaces/query`: This endpoint queries available spaces using the `getAvailableSpaces` function.\n- `/content/search`: This endpoint searches for content using the `searchContent` function.\n- `/content/create`: This endpoint creates new content using the `createContent` function.\n- `/content/update`: This endpoint updates existing content using the `updateContent` function.\n- `/content/delete`: This endpoint deletes existing content using the `deleteContent` function.\n\nEach of these endpoints uses a common pattern: they create a Confluence client using the `getConfluenceClient` function, perform their respective operations, and then end the response for safety. If any errors occur during these operations, they are passed to the next middleware function.\n\nThe `getConfluenceClient` function is used to create an authenticated Confluence client. It retrieves a team ID from the request headers, which is then used to create and return an authenticated Confluence client.\n\nThere's also a commented-out section for a potential proxy endpoint for the Confluence API.\n\nThis file does not start an application server itself; it merely exports a router that can be used by an Express.js application."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/api/update-content.ts", "basename": "update-content.ts", "ext": ".ts", "service_references": ["confluence", "openai"], "summary": "The code in the file `update-content.ts` does not start an application server. Instead, it exports a single asynchronous function named `updateContent`. This function is designed to be used as a middleware in an Express.js application. \n\nThe function takes an object as an argument, which includes a request (`req`), a response (`res`), and a `confluenceClient`. The function uses the `confluenceClient` to fetch a page by its ID, which is provided in the request body. If the page is not found, it logs an error and sends a 500 status response.\n\nIf the page is found, it checks if there is an existing body of content. If there is, it constructs a prompt to merge the existing content with the new content provided in the request body. It then determines which OpenAI model to use based on the token count of the prompt. If a suitable model is found, it uses an authenticated OpenAI client to create a chat completion with the prompt. If the OpenAI response indicates that it was unable to merge the documents, it logs a warning and uses the new content. If the prompt is too big for OpenAI, it logs a warning and overwrites the document.\n\nFinally, it uses the `confluenceClient` to update the page with the new or merged content and sends a JSON response with the updated content."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/api/delete-content.ts", "basename": "delete-content.ts", "ext": ".ts", "service_references": ["confluence"], "summary": "The code in the file `apps/confluence/src/api/delete-content.ts` is a module that exports an asynchronous function named `deleteContent`. This function takes an object as an argument which includes a request object (`req`) and a `confluenceClient` object. The function extracts the `content` from the request body and then calls the `archivePage` method of the `confluenceClient` object, passing the `content_id` of the `content` as an argument.\n\nThe file does not start an application server like Express, Flask, Django, Gin, Rack, etc. It is a utility module that is likely used by an application server to handle specific requests related to deleting content in a Confluence system."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/api/create-content.ts", "basename": "create-content.ts", "ext": ".ts", "service_references": ["confluence"], "summary": "The code in the file `apps/confluence/src/api/create-content.ts` does not start an application server. It exports a default asynchronous function `createContent` that takes an object with properties `req`, `res`, and `confluenceClient` as arguments. \n\nThe function `createContent` is designed to create content in a Confluence space. It first checks if the space exists and if it has a homepage. If either of these conditions is not met, it logs a warning and sends a 400 status response. \n\nIf the document to be created does not have any parents, it is placed in the root of the space. If the document has at least one parent, a hierarchy is built and the document is placed accordingly. \n\nThe function also handles title conflicts by checking if a page with the same title exists anywhere else in the space. If it does, it generates a unique title. \n\nThe function `resolveTitleConflict` is used to generate a unique title in case of a conflict. It appends a number to the title and increments it until a unique title is found or the limit is reached. If the limit is reached, it appends a UUID to the title.\n\nFinally, the function creates the new document and sends it as a JSON response."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/api/util.ts", "basename": "util.ts", "ext": ".ts", "service_references": ["confluence"], "summary": "This code is part of a utility file in a Confluence application. It does not start an application server. It imports a module for handling HTML entities and a Confluence client module. \n\nThe file exports two things: a function and a type. \n\nThe function `cleanDocument` takes a string as an argument, which represents an HTML document. It decodes the HTML entities in the document, replaces all instances of '&' with '&amp;' (since Confluence cannot handle decoded ampersands), and replaces all instances of '<br>' with '<br/>' (since Confluence cannot handle unclosed br tags). The function then returns the cleaned content.\n\nThe type `ConfluenceClientArg` is an object type that has one property, `confluenceClient`, which is of type `ConfluenceClient`."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/api/search-content.ts", "basename": "search-content.ts", "ext": ".ts", "service_references": ["confluence"], "summary": "The code in the file `apps/confluence/src/api/search-content.ts` does not start an application server. Instead, it exports an asynchronous function `searchContent` that is used to search content in Confluence, a team collaboration software. \n\nThe function takes an object as an argument which includes a request (`req`), a response (`res`), and a Confluence client (`confluenceClient`). It first loads the logging context from the response and extracts the search parameters from the request body. \n\nIf the `space_key` is provided, it is added to the `cqlcontext`. If the `text` is not empty, it is added to the `cqlConditions`. The `cqlConditions` are then joined with 'AND' to form a `cql` string. \n\nIf the `cql` string is empty, it logs an error message, sends a 500 status code as the response, and returns. Otherwise, it uses the Confluence client to perform a search with the `cql` and `cqlcontext`. \n\nIt then filters out any results that do not have a body and sends the filtered results as a JSON response."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/api/get-available-spaces.ts", "basename": "get-available-spaces.ts", "ext": ".ts", "service_references": ["confluence"], "summary": "The code in this file does not start an application server. It exports an asynchronous function named `getAvailableSpaces` that fetches available spaces from a Confluence client. The function takes an object as an argument, which includes a response object (`res`) and a Confluence client (`confluenceClient`). \n\nThe function calls the `getSpaces` method of the Confluence client, which returns a promise that resolves to the available spaces. These spaces are then included in a response body object, which is sent back to the client as a JSON response. \n\nThe types of the arguments and the response body are imported from other modules."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/events", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/events/routes.ts", "basename": "routes.ts", "ext": ".ts", "service_references": ["atlassian", "confluence"], "summary": "This code is written in TypeScript and is part of a larger application that uses the Express.js framework for Node.js. It does not start an application server itself, but it defines two functions that are used to configure routes and middleware for the application.\n\nThe `applyWebhookMiddlewares` function takes an Express application instance, an Atlassian add-on instance, and a path as arguments. It applies two middleware functions to the specified path: `express.json()` for parsing JSON request bodies, and the middleware function provided by the Atlassian add-on.\n\nThe `WebhookRouter` function takes an Atlassian add-on instance as an argument and returns a new Express router. This router is configured to use a lifecycle router (which handles events related to the lifecycle of the Atlassian add-on) and to handle POST requests to its root path. When a POST request is received, it logs the event using the `eaveLogger` utility.\n\nThe Atlassian add-on and the eaveLogger utility are imported from external libraries. The Atlassian add-on is used to interact with Atlassian products (in this case, Confluence), while the eaveLogger utility is used for logging. The configuration for the application is imported from a local `config.js` file."}]}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/app.ts", "basename": "app.ts", "ext": ".ts", "service_references": [], "summary": "The code is a Node.js application using the Express.js framework. It sets up an Express server and configures it with various middleware and routes. \n\nThe application uses the Atlassian Connect Express (ACE) library to integrate with Atlassian applications, and it registers a custom store with ACE using the EaveApiAdapter. \n\nThe app is configured to use a variety of middleware for security and request/response handling, including a helmet middleware for security, Atlassian security policy middlewares, common request and response middlewares, and internal API middlewares. \n\nThe app also sets up several routes, including a GAELifecycleRouter, a StatusRouter, a WebhookRouter for handling event-related requests, and an InternalApiRouter for handling API requests. \n\nThe app's configuration is transformed based on the environment it's running in. If it's running in production, the base URL of the app descriptor is set to a specific value.\n\nIn summary, this is an Express.js server application designed to integrate with Atlassian applications, with various middleware and routes configured for handling requests and responses."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/config.ts", "basename": "config.ts", "ext": ".ts", "service_references": [], "summary": "The code is a configuration file for an application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nIt imports two modules, `EaveConfig` and `EaveOrigin`, from the `@eave-fyi/eave-stdlib-ts` package. The `AppConfig` class extends the `EaveConfig` class and sets two properties: `eaveOrigin` and `eaveConfluenceAppAccountId`. The `eaveOrigin` is set to `EaveOrigin.eave_confluence_app`, and `eaveConfluenceAppAccountId` is set to a specific string value. \n\nFinally, an instance of the `AppConfig` class is created and exported as the default export of the module. This instance can be imported in other parts of the application to access the configuration settings."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/src/confluence-client.ts", "basename": "confluence-client.ts", "ext": ".ts", "service_references": ["confluence"], "summary": "The code in this file does not start an application server. Instead, it defines a class `ConfluenceClient` that extends `ConnectClient`. This class is used to interact with the Confluence API, a service for managing content in Atlassian's Confluence software.\n\nThe `ConfluenceClient` class includes methods for:\n\n- Getting an authenticated Confluence client\n- Fetching a space by its key\n- Fetching a page by its title or ID\n- Fetching the children of a page\n- Fetching the root page of a space\n- Creating a new page\n- Archiving a page\n- Fetching all spaces\n- Searching for content\n- Updating a page\n- Fetching system information\n\nEach method makes a request to the Confluence API and returns the response. The methods use the `request` method from the `ConnectClient` class to make these requests. The `request` method is not defined in this file, but it is presumably defined in the `ConnectClient` class that `ConfluenceClient` extends."}], "service_name": "confluence_server"}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/config.json", "basename": "config.json", "ext": ".json", "service_references": [], "summary": "This code is a configuration file in JSON format for a product named \"confluence\". It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe configuration file contains two main sections: \"development\" and \"production\". Each section contains settings for different environments. \n\nIn both environments, the base URL for the local server is specified (\"localBaseUrl\"), a setup install route is set to false (\"setupInstallRoute\"), and a store object is defined with properties like \"adapter\", \"appKey\", \"productType\", and \"eaveOrigin\". The \"port\" property is set to use an environment variable \"$PORT\".\n\nIn the production environment, there is an additional property \"whitelist\" which contains a list of URLs. This could be used to restrict or allow certain domains to access the application."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/pm2.config.cjs", "basename": "pm2.config.cjs", "ext": ".cjs", "service_references": [], "summary": "This code is a configuration file for PM2, a process manager for Node.js applications. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. directly, but it is used to manage the Node.js process that could be running such a server.\n\nThe configuration exports an object with an \"apps\" array. Inside this array, there is an object that defines the properties of the application named 'confluence'. The 'script' property points to the main file of the application ('./server.ts'), which will be run by PM2.\n\nThe 'out_file' and 'error_file' properties are set to '/dev/stdout' and '/dev/stderr', respectively, meaning that standard output and error will be redirected to these system paths.\n\nThe 'interpreter' property is set to use the 'ts-node' package from the project's 'node_modules' directory. This package is used to execute TypeScript files directly, without needing to compile them to JavaScript first.\n\nThe 'interpreter_args' property is set to '--swc', which is an argument passed to the interpreter. In this case, it instructs 'ts-node' to use the SWC compiler, a super-fast JavaScript/TypeScript compiler."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/package.json", "basename": "package.json", "ext": ".json", "service_references": [], "summary": "This is a package.json file for a Node.js application. It does not start an application server directly, but it does specify scripts for starting the application and its development environment. \n\nThe \"start\" script uses PM2, a process manager for Node.js applications, to start the application based on the configuration specified in pm2.config.cjs. The \"start-dev\" script uses nodemon to automatically restart the application whenever file changes in the directory are detected, and it also attempts to kill any running instances of ngrok.\n\nThe \"test\" script runs tests using Ava, a test runner for Node.js, with a specific configuration file.\n\nThe \"dependencies\" section lists the libraries that the application needs to run. These include Express, a web application framework for Node.js, and several libraries related to Atlassian Connect Express, which is used for building Atlassian add-ons.\n\nThe \"devDependencies\" section lists the libraries needed for development but not for running the application. These include various types for TypeScript, ESLint for enforcing coding standards, Ava for testing, and nodemon for automatic restarts during development.\n\nThe comment at the end notes that the \"longjohn\" library must be installed or else the Atlassian Connect Validator will crash the app in development."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/atlassian-connect.json", "basename": "atlassian-connect.json", "ext": ".json", "service_references": [], "summary": "This JSON file appears to be a configuration file for an Atlassian Connect app named \"Eave\". It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe file contains various settings for the app, such as its key, name, description, and vendor information. It also specifies that the app uses JWT (JSON Web Tokens) for authentication.\n\nThe \"lifecycle\" section defines the endpoints that will be hit when the app is installed, enabled, disabled, or uninstalled. The \"scopes\" section indicates that the app has read and write permissions.\n\nThe \"baseUrl\" and \"links\" sections contain placeholders for the base URL of the app. The \"modules\" section is currently empty, indicating that no modules are defined in this configuration. \n\nThe \"enableLicensing\" field is set to false, indicating that this app does not require a license to operate."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/confluence/server.ts", "basename": "server.ts", "ext": ".ts", "service_references": [], "summary": "The code in the file `apps/confluence/server.ts` is used to start an application server. It imports several modules, including `applyShutdownHandlers` and `registerDevApp` from the `@eave-fyi/eave-stdlib-ts` package, as well as `app`, `addon`, and `appConfig` from local files.\n\nThe server is set to listen on a port number specified by the environment variable `PORT`, or defaults to 5400 if not specified. The server is also set to listen on all network interfaces ('0.0.0.0').\n\nWhen the server starts, it logs a message indicating the port number it's listening on and the current Node.js environment. If the application is running in development mode, it also registers a development application using the `registerDevApp` function.\n\nFinally, it applies shutdown handlers to the server using the `applyShutdownHandlers` function. This is likely used to gracefully shut down the server when necessary, such as when the process receives a termination signal.\n\nThe specific application server framework used (such as Express, Flask, Django, etc.) is not explicitly mentioned in this code. However, given the use of `app.listen()`, it's likely that this code is using Express or a similar Node.js-based server framework."}], "service_name": "confluence_server"}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/context", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/context/Provider.js", "basename": "Provider.js", "ext": ".js", "service_references": [], "summary": "This JavaScript file is part of a React application and it does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe code defines a context provider for the application. Context provides a way to pass data through the component tree without having to pass props down manually at every level. \n\nIn this case, the context provider is managing three pieces of state: `modalState`, `userState`, and `errorState`. \n\n- `modalState` is an object that tracks whether a modal is open and what mode it's in (sign up or log in).\n- `userState` is an object that tracks whether a user is authenticated and their team information.\n- `errorState` is an object that tracks any errors.\n\nThe state for each of these is initialized using the `useState` hook from React, and the state and its corresponding setter function are stored in the `store` object. \n\nThe `AppContextProvider` component then returns the `AppContext.Provider` component with the `store` as its value, allowing all child components to access and modify the state as needed."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/EaveLogo", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/EaveLogo/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "The code is a React component for a logo. It does not start an application server. \n\nThe file exports a single React functional component named `EaveLogo`. This component uses the `makeStyles` hook from Material-UI to define some CSS classes. The styles are responsive and change based on the screen size (using the 'md' breakpoint). \n\nThe `EaveLogo` component takes a `className` prop, which is combined with the `logoWrapper` class using the `classNames` function. The component returns a `Link` element from `react-router-dom`, which is styled with the combined classes and links to the root (\"/\") path. The link contains the text \"eave\" and a span with the text \"Beta\", which is styled with the `beta` class."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/AuthUser", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/AuthUser/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This file does not start an application server. \n\nThe code is a React component named `AuthUser` that checks if a user is authenticated. It uses a custom React hook `useUser` to get the user's authentication state and a function to check the user's authentication state. \n\nIf the user's authentication state is null (meaning it's not yet determined), it calls the `checkUserAuthState` function. While checking, it displays a circular progress indicator in the center of the screen. \n\nOnce the user's authentication state is determined (either authenticated or not), it renders its children components. \n\nThe `makeClasses` function uses Material-UI's `makeStyles` to create CSS classes for styling the circular progress indicator."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Footer", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Footer/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This code defines a Footer component for a React application. The Footer component is styled using Material-UI's makeStyles function. The styles include responsive design elements that adjust padding and display properties based on the screen size. The Footer component includes copyright information and links to the Terms and Privacy Policy pages. The current year is dynamically generated and included in the copyright text. The Footer component is exported for use in other parts of the application. This file does not start an application server."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/PrivateRoutes", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/PrivateRoutes/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This code defines a React component called PrivateRoutes. It uses the useUser custom hook to get the user state and check if the user is authenticated. If the user is authenticated, it renders the Outlet component, which is a placeholder where child routes can be rendered. If the user is not authenticated, it redirects the user to the root (\"/\") route using the Navigate component from react-router-dom. This file does not start an application server."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/PageSection", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/PageSection/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This code defines a React component called `PageSection`. It does not start an application server. \n\nThe `PageSection` component is a reusable section of a webpage that can be customized with different styles and content. It uses the `makeStyles` hook from Material-UI to define a set of CSS classes that can be applied to the section. The styles include different padding sizes for different screen sizes, an alternate background color, and a top section style that includes additional padding.\n\nThe component takes several props: `children` (the content to be displayed in the section), `alternateBackground` (a boolean indicating whether to use the alternate background color), `topSection` (a boolean indicating whether this is a top section), `sectionClassName` (additional CSS classes to apply to the section), `wrapperClassName` (additional CSS classes to apply to the wrapper div), and `id` (the id attribute for the section).\n\nThe `classNames` function is used to combine these classes into a single string that can be applied to the `className` attribute of the section and wrapper div. The `children` prop is rendered inside the wrapper div.\n\nFinally, the `PageSection` component is exported for use in other parts of the application."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/hoc", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/hoc/withTitle.js", "basename": "withTitle.js", "ext": ".js", "service_references": [], "summary": "The code does not start an application server. It is a Higher Order Component (HOC) in React, a JavaScript library for building user interfaces. \n\nThe HOC, named `withTitle`, is a function that takes another component (`WrappedComponent`) as an argument and returns a new component (`ComponentWithTitle`). This new component sets the document's title to the value of `pageTitle` prop if it exists, otherwise it defaults to 'Eave, for your information.'. Then it renders the `WrappedComponent` with all the props it received. \n\nThis HOC can be used to wrap any component that needs to set the document's title based on its props."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/BlockStack", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/BlockStack/index.js", "basename": "index.js", "ext": ".js", "service_references": [], "summary": "This JavaScript file is part of a React application and does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe file defines a React component named `BlockStack` that renders a section of HTML. This section includes a title and a list of blocks. The title and blocks are passed as properties to the component. The title is displayed using another React component named `Copy`, and each block is displayed using a React component named `Block`.\n\nThe `BlockStack` component is styled using Material-UI's `withStyles` higher-order component. The styles are defined in the `styles` object, which includes responsive styles for different screen sizes.\n\nFinally, the styled `BlockStack` component is exported for use in other parts of the application."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/ScrollToTop", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/ScrollToTop/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This code defines a React component named ScrollToTop. It uses the useEffect hook from React and the useLocation hook from react-router-dom. The useLocation hook is used to get the current location's pathname. The useEffect hook is used to execute a side effect after every render, which in this case is scrolling to the top of the page. This side effect is triggered every time the pathname changes. The component does not render anything, it returns null. This file does not start an application server."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Banners", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Banners/IntegrationsBanner", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Banners/IntegrationsBanner/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "The code is a React component named IntegrationsBanner. It does not start an application server. \n\nThe component uses Material-UI's makeStyles hook to define CSS styles for different elements of the component. The styles are responsive, with different rules for different screen sizes (small, medium, large).\n\nThe IntegrationsBanner component receives two props: title and subtitle. It returns a PageSection component with two main parts: a div containing the title and subtitle, and a div containing logos for Slack, Github, and Jira. The logos are imported from a constants file.\n\nEach logo is displayed as an image with its source and alternative text fetched from the INTEGRATION_LOGOS constant. The size of each logo changes depending on the screen size. \n\nThe IntegrationsBanner component is exported as a default export at the end of the file."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Banners/DocumentationBanner", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Banners/DocumentationBanner/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "The given code is a React component named `DocumentationBanner`. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe `DocumentationBanner` component uses Material UI for styling and takes two props: `title` and `subtitle`. It uses the `makeStyles` hook from Material UI to create CSS classes for styling the component. \n\nThe component returns a `PageSection` component with a specific id and class names. Inside this `PageSection`, there is a `div` that contains two `Copy` components which display the `title` and `subtitle` props. \n\nThere is also a `picture` element that contains two `source` elements and an `img` element. The `source` elements are used to provide different images for different viewport sizes (responsive design). The `imageUrl` function is used to get the URLs of the images. \n\nThe `DocumentationBanner` component is exported as the default export of the module."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Banners/PrivacyBanner", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Banners/PrivacyBanner/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "The code in the file is a React component named PrivacyBanner. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe PrivacyBanner component takes two props: title and subtitle. It uses the Material-UI library to create custom styles for the component. The styles are responsive and change based on the screen size (mobile or desktop).\n\nThe component returns a PageSection component with an image and two Copy components. The image source is obtained from a helper function called imageUrl. The Copy components display the title and subtitle passed as props to the PrivacyBanner component.\n\nThe PrivacyBanner component is exported as a default export from the file."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Banners/SlackBanner", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Banners/SlackBanner/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This code defines a React component called `SlackBanner`. The component is styled using Material-UI's `makeStyles` function and the `classNames` library. The styles are responsive, with different layouts and padding for different screen sizes.\n\nThe `SlackBanner` component takes two props: `titles` and `subtitles`, which are both arrays. It uses these to display two sections of copy text, each with a title and a subtitle. The text is displayed using a component called `Copy`.\n\nThe component also displays an image, with different source files used depending on the screen width. The image file paths are generated using a helper function called `imageUrl`.\n\nThe entire component is wrapped in another component called `PageSection`.\n\nThis file does not start an application server. It simply exports a React component that can be used elsewhere in the application."}]}], "files": []}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Button", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Button/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This code defines a Button component in React, using Material UI for styling. The Button component can be customized with various properties such as size (large or not), color, variant, target, and whether it acts as a link (with the 'to' property). \n\nThe component uses the makeStyles hook from Material UI to define custom styles for the button. These styles include root (basic button styles), large (styles for a large button), and link (styles for a button acting as a link). \n\nThe Button component itself is a functional component that takes in several props. It uses these props to determine the button's classes, color, variant, and target. If the 'to' prop is provided, the button is wrapped in a Link component from react-router-dom, making it act as a link.\n\nThis file does not start an application server like Express, Flask, Django, Gin, Rack, etc. It's just a component in a React application."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/CloseIcon.js", "basename": "CloseIcon.js", "ext": ".js", "service_references": [], "summary": "This JavaScript file defines a React component called CloseIcon. The component renders an SVG image of a close icon (typically an 'X' shape). The color of the icon can be customized via the 'stroke' prop, and if no color is provided, it defaults to black. The 'className' prop is used to apply CSS styles to the SVG element. The file does not start an application server."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/AtlassianIcon.jsx", "basename": "AtlassianIcon.jsx", "ext": ".jsx", "service_references": [], "summary": "The code does not start an application server. It is a JavaScript file that defines a React component named `AtlassianIcon`. This component returns an SVG image of the Atlassian logo. The logo's appearance is defined by a series of path and gradient elements within the SVG. The `className` prop is used to apply CSS styles to the SVG element. The component is exported for use in other parts of the application."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/ConnectIcon.js", "basename": "ConnectIcon.js", "ext": ".js", "service_references": [], "summary": "The code is a React component for a Connect Icon. The component renders an SVG icon when called. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. The SVG icon is made up of multiple path elements, each representing a different part of the icon. The color of the icon is set to the current color of the parent element. The className prop allows for additional CSS styling to be applied from a parent component."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/SlackIcon.jsx", "basename": "SlackIcon.jsx", "ext": ".jsx", "service_references": [], "summary": "The code defines a React component called SlackIcon that returns an SVG representation of the Slack logo. The SVG paths and shapes are styled with different colors and strokes to create the logo. The component accepts a prop called className, which can be used to apply additional CSS styles to the SVG element. This file does not start an application server."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/PurpleCheckIcon.jsx", "basename": "PurpleCheckIcon.jsx", "ext": ".jsx", "service_references": [], "summary": "The code defines a React functional component named PurpleCheckIcon. This component returns an SVG (Scalable Vector Graphics) that represents a purple check icon. The SVG's stroke color is set to \"#512DA8\" (a shade of purple), and the stroke width is set to \"3\". The SVG's path is defined with the \"d\" attribute. The component accepts a prop named className, which is used to set the CSS class of the SVG element. This component does not start an application server."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/SnapIcon.js", "basename": "SnapIcon.js", "ext": ".js", "service_references": [], "summary": "The code defines a React component called SnapIcon. This component renders an SVG image when it is used. The SVG image is defined within the render method of the SnapIcon class. The image's fill color and class name can be customized via the component's props. The file does not start an application server."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/GoogleIcon.jsx", "basename": "GoogleIcon.jsx", "ext": ".jsx", "service_references": [], "summary": "The code in this file defines a React component called GoogleIcon. This component returns an SVG image of the Google logo. The logo is composed of four paths, each filled with a different color to represent the four colors of the Google logo. The size and viewbox of the SVG are defined, and the paths are clipped to fit within the defined viewbox. The component accepts a prop called className which is applied to the SVG element, allowing for external styling. This file does not start an application server."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/ConfluenceIcon.jsx", "basename": "ConfluenceIcon.jsx", "ext": ".jsx", "service_references": [], "summary": "This code defines a React component named `ConfluenceIcon` that renders an SVG icon. The SVG icon is defined within the component and uses two linear gradients for coloring. The `className` prop is used to apply CSS classes to the SVG element for styling purposes. The component does not start an application server; it is a stateless functional component that returns an SVG icon when rendered. The icon appears to be related to Confluence, a team collaboration software product, based on the name of the component."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/SyncIcon.js", "basename": "SyncIcon.js", "ext": ".js", "service_references": [], "summary": "The code defines a React component named SyncIcon that renders an SVG image. The SVG image is defined within the render method of the component. The component accepts a className prop which is used to set the class of the SVG element. The fill color of the SVG is set to 'currentColor'. This component does not start an application server."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/DownIcon.js", "basename": "DownIcon.js", "ext": ".js", "service_references": [], "summary": "This code defines a React component called DownIcon. This component renders an SVG image of a down arrow. The color of the arrow (stroke) and the CSS class name applied to the SVG element (className) can be customized via props. If no stroke color is provided, it defaults to black. This file does not start an application server."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/HamburgerIcon.js", "basename": "HamburgerIcon.js", "ext": ".js", "service_references": [], "summary": "This JavaScript file defines a React component called HamburgerIcon. The component renders an SVG image that represents a hamburger icon, which is commonly used in web design for a button that opens a navigation menu. The color of the lines in the icon can be customized via the 'stroke' prop, and if no color is provided, it defaults to black. The 'className' prop is used to apply CSS styles to the SVG element. This file does not start an application server."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/DocumentIcon.js", "basename": "DocumentIcon.js", "ext": ".js", "service_references": [], "summary": "The code is a React component that renders an SVG icon of a document. It does not"}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/ChatboxIcon.jsx", "basename": "ChatboxIcon.jsx", "ext": ".jsx", "service_references": [], "summary": "This code defines a React component named ChatboxIcon. This component returns an SVG (Scalable Vector Graphics) that represents a chatbox icon. The SVG has two paths, one for the chatbox shape and the other for the lines inside the chatbox. The viewBox, fill, stroke, and other attributes are used to style the SVG. The component accepts a prop named className, which is applied to the SVG element to allow further styling from outside the component. This file does not start an application server."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Icons/LockIcon.js", "basename": "LockIcon.js", "ext": ".js", "service_references": [], "summary": "The code defines a React component called LockIcon. This component renders an SVG image of a lock icon. The icon's appearance can be customized through properties passed to the component: `className` to apply CSS styles, `stroke` to set the color of the lock's outline, `lockFill` to set the color of the lock body, and `circleFill` to set the color of the circle inside the lock. If these properties are not provided, default colors are used. The file does not start an application server."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Affiliates", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Affiliates/index.js", "basename": "index.js", "ext": ".js", "service_references": [], "summary": "The code is a JavaScript file that uses React, a popular JavaScript library for building user interfaces. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe file defines a React component named `Affiliates`. This component renders a section of a webpage that includes a message (\"Trusted by employees from\") and logos of affiliate companies (Amazon, PayPal, Disney, and Honey). \n\nThe logos and their alternative text are imported from a constants file. The `withStyles` function from the Material-UI library is used to apply styles to the component. The styles are responsive, meaning they adjust based on the screen size (e.g., the logos have different widths on small ('sm') screens).\n\nThe `Affiliates` component is exported at the end of the file, so it can be imported and used in other parts of the application."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Copy", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Copy/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "The code in this file is a React component named `Copy`. This component is used to render text with different styles based on the `variant` prop it receives. The `variant` prop can be 'h1', 'h2', 'h3', 'footnote', 'pSmall', or any other value (which defaults to a paragraph style). The text to be rendered is passed as children to the `Copy` component.\n\nThe component uses the `makeStyles` function from Material-UI to define CSS classes for each variant. These classes define properties like font size, line height, font weight, margin, and color. The classes also include responsive styles that apply at different screen sizes (using Material-UI's `theme.breakpoints.up('sm')` for small screens).\n\nThe `classNames` function is used to conditionally apply the 'bold' class along with the class for the specified variant and any additional classes passed in the `className` prop.\n\nThe file does not start an application server like Express, Flask, Django, Gin, Rack, etc. It simply exports a React component that can be imported and used in other parts of a React application."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Hero", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Hero/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This code defines a React component called \"Hero\". It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe Hero component takes in three props: title, subtitle, and cta (call to action). It uses the makeStyles hook from Material-UI to define some CSS styles for the title and subtitle. \n\nThe component uses a custom hook called useAuthModal to get a function called openModal. When the button in this component is clicked, it calls openModal with the SIGNUP state from the AUTH_MODAL_STATE constant.\n\nThe component returns a PageSection component with the topSection prop. Inside this PageSection, it renders a Copy component for the title and subtitle (with their respective styles), and a Button component for the call to action. When this button is clicked, it opens a modal for signing up."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/Page", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/Page/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This code is a React component named 'Page' that is used to structure the layout of a page in a web application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe 'Page' component includes a Header, Footer, and AuthModal component, and it also accepts children components. The 'simpleHeader' prop is passed to the Header component. \n\nThe makeStyles function from '@material-ui/styles' is used to create CSS classes for the component. The 'container' class sets the position to 'relative', the minimum height to '100vh', and sets the color and background color based on the theme's typography color and palette background respectively. \n\nThe 'Page' component is exported as a default export from this module."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/HomePage", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/HomePage/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This code is a React component for the home page of a web application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe HomePage component uses several hooks and components:\n\n- `useUser` hook to get the user state and check if the user is authenticated.\n- `useNavigate` hook from `react-router-dom` to navigate to different pages in the application.\n- `Hero`, `IntegrationsBanner`, `SlackBanner`, `DocumentationBanner`, and `PrivacyBanner` components to display different sections of the home page.\n- `Page` component to wrap the entire page.\n\nThe `useEffect` hook is used to redirect authenticated users to the dashboard page. \n\nThe `copy` object contains text that is displayed on the home page. Each property of the `copy` object corresponds to a section of the home page and contains properties for the title, subtitle, and other text in that section.\n\nThe HomePage component returns a JSX element that includes all these components and displays the text from the `copy` object."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/TermsPage", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/TermsPage/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This code is a React component for a Terms of Service page. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe component uses Material-UI's makeStyles function to define CSS styles for the page. The styles are responsive and adjust based on the screen size (mobile, sm, md).\n\nThe TermsPage component renders a Page component with a simpleHeader prop. Inside this Page component, it renders the main content of the Terms of Service page. The content includes several sections such as \"Terms of Service\", \"Use of Services\", \"User Accounts\", \"Fees\", \"Intellectual Property\", \"Disclaimer of Warranties\", \"Limitation of Liability\", \"Indemnification\", \"Termination\", \"Governing Law\", \"Changes to Terms\", and \"Contact Us\". Each section is rendered using the Copy component with specific styles applied.\n\nThe text within each section provides information about the terms and conditions for using the services provided by the company. The \"Contact Us\" section includes an email link for users to send their questions about the terms.\n\nFinally, the TermsPage component is exported for use in other parts of the application."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/Dashboard", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/Dashboard/Footnote.jsx", "basename": "Footnote.jsx", "ext": ".jsx", "service_references": [], "summary": "This JavaScript file defines a React component named \"Footnote\". It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe Footnote component is styled using Material-UI's makeStyles function. It has two main parts: a chat icon and a message from the Eave team. The chat icon is hidden on smaller screens (below the 'md' breakpoint) and displayed on larger screens. The message from the Eave team includes a link to a feedback form and an email address for direct contact.\n\nThe FEEDBACK_URL is imported from a constants file. The Copy component and ChatboxIcon component are also imported from other files. The Footnote component is exported for use in other parts of the application."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/Dashboard/Thanks.jsx", "basename": "Thanks.jsx", "ext": ".jsx", "service_references": [], "summary": "The code is a React component named 'Thanks'. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThis component is a simple thank you message that is displayed to users after they sign up. It uses Material-UI's makeStyles hook to create CSS classes for styling the component. The 'Copy' component is used to display the text messages. \n\nThe 'Thanks' component returns a section with two 'Copy' components: one for the heading \"Thanks for Signing Up!\" and another for the message about being added to the waitlist. The second 'Copy' component also includes a mailto link for inquiries. The 'Thanks' component is then exported for use in other parts of the application."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/Dashboard/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This JavaScript file is a React component named Dashboard. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe Dashboard component uses several imported modules and components such as React's useEffect hook, Material-UI's makeStyles and CircularProgress, a custom hook called useUser, and several other components (PageSection, Page, Thanks, Steps, Copy).\n\nThe makeStyles function is used to define CSS styles for the component. The useUser hook is used to manage user-related state and functions.\n\nIn the Dashboard component, the useEffect hook is used to fetch user information if it hasn't been fetched already and if it's not currently being fetched.\n\nThe render method of the Dashboard component returns a Page component that contains a PageSection component. Inside the PageSection, it conditionally renders different components or elements based on the state of the user information. If the user information is not available or is being fetched, it either shows an error message or a loading spinner. If the user information is available, it checks if the user's team is in beta whitelist. If not, it shows a Thanks component; otherwise, it shows a Steps component."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/Dashboard/Steps.jsx", "basename": "Steps.jsx", "ext": ".jsx", "service_references": ["confluence", "github", "slack", "jira"], "summary": "The code is a React component named 'Steps' that is part of a larger application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThis component is a part of a setup or onboarding process for a user. It guides the user through a series of steps to integrate their account with various services such as Atlassian's Confluence, Github, Slack, and Jira. \n\nThe Steps component uses Material UI for styling and layout. It also uses several custom components such as 'Copy', 'Button', and various icons. The component also uses a custom hook 'useUser' to manage user state.\n\nThe state of the component is managed using React's useState and useEffect hooks. The state variables keep track of the current step in the process, whether the user is editing their Confluence space, and whether the user has clicked on the buttons to integrate with Forge, Jira, or Slack.\n\nThe component returns a section containing a series of steps. Each step has a title, description, and action button. The action buttons either link to an external URL for integration or trigger an update to the user's Confluence space. The steps are displayed using Material UI's Stepper, Step, StepLabel, and StepContent components. \n\nThe component also handles errors and loading states, displaying appropriate feedback to the user."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/Dashboard/StepIcon.jsx", "basename": "StepIcon.jsx", "ext": ".jsx", "service_references": [], "summary": "This code defines a React component named `StepIcon`. It uses the `makeStyles` function from the Material-UI library to define some CSS styles for the component. The styles are responsive, with different sizes specified for viewports above the 'md' breakpoint.\n\nThe `StepIcon` component itself renders a div with the class `step`. If the `completed` prop is true, it also renders a `PurpleCheckIcon` component inside the div. The `PurpleCheckIcon` component is imported from another file in the same project.\n\nThis file does not start an application server. It simply exports a React component that can be used elsewhere in a React application."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/PrivacyPage", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Pages/PrivacyPage/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This code is a React component for a Privacy Policy page. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe code first imports necessary modules and components such as React, makeStyles from Material-UI for styling, a HEADER constant, a Page component and a Copy component. \n\nIt then defines a set of CSS classes using the makeStyles function from Material-UI. \n\nThe main component exported from this file is PrivacyPage. This is a functional component that uses the defined CSS classes to style its content. The content of the page is mostly static text that outlines the privacy policy of the company, Eave Technologies Inc. The text includes information about what data is collected, how it's used, how it's shared, data security measures, user rights and choices, changes to the policy, and contact information. \n\nThe PrivacyPage component is then exported for use in other parts of the application."}]}], "files": []}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/AuthModal", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/AuthModal/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "This code defines a React component named `AuthModal` which is used to create a modal dialog for user authentication. The modal dialog can be in either login mode or signup mode, and the text and options displayed are adjusted accordingly. \n\nThe `AuthModal` component uses Material-UI's Dialog, IconButton, and makeStyles for styling and layout. It also uses a custom hook `useAuthModal` to manage the state of the modal (whether it's open, and whether it's in login or signup mode). \n\nThe modal contains a close button, a header that changes based on the mode, a subheader with additional information, and a button to continue with Google for authentication. There's also commented out code for a button to continue with Slack for authentication. \n\nIf the modal is in signup mode, it also displays a disclaimer with links to the terms of service and privacy policy. \n\nThis file does not start an application server like Express, Flask, Django, Gin, Rack, etc. It's a component file in a React application."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Header", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Header/index.jsx", "basename": "index.jsx", "ext": ".jsx", "service_references": [], "summary": "The code is a React component for a header of a web application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe header component uses Material-UI for styling and layout. It also uses React hooks for managing state and other side effects. The header includes a logo (EaveLogo), a hamburger icon for opening a drawer (a sliding menu), and different buttons depending on the user's authentication status.\n\nIf the user is authenticated, the header displays \"Send Feedback\" and \"Log Out\" buttons. If the user is not authenticated, it displays \"Log In\" and \"Get Early Access\" buttons. The \"Log In\" and \"Get Early Access\" buttons open modals for login and signup respectively when clicked.\n\nThe header also has a mobile version where the buttons are displayed in a drawer that slides in from the right when the hamburger icon is clicked. The drawer can be closed by clicking a close icon.\n\nThe `simpleHeader` prop determines whether to display the buttons and the hamburger icon. If `simpleHeader` is true, only the logo is displayed."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Block", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/components/Block/index.js", "basename": "index.js", "ext": ".js", "service_references": [], "summary": "This JavaScript file is part of a React application and does not start an application server. It defines a React component named `Block` that renders a block of content with an image and some text (copy). \n\nThe `Block` component receives `classes`, `copy`, and `img` as props. `classes` is used for CSS styling, `copy` is the text content to be displayed, and `img` is an object containing the source URL (`src`) and alternative text (`alt`) for the image. \n\nThe `Block` component uses the `withStyles` higher-order component from Material-UI to apply styles to the component. The styles are defined in the `styles` object, which includes responsive styles for different screen sizes using Material-UI's breakpoints. \n\nThe `Copy` component is imported from '../Copy/index.jsx' and is used to display the text content within the block. \n\nIn summary, this file exports a styled `Block` component that displays an image and some text."}]}], "files": []}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/theme", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/theme/index.js", "basename": "index.js", "ext": ".js", "service_references": [], "summary": "This JavaScript file is part of a marketing application and it's used to define the theme for the application's user interface. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe file uses the createTheme function from the '@material-ui/core' library to define a theme object. This theme object includes a color palette and typography settings. The color palette defines primary and background colors, while the typography settings define text colors and the font family to be used throughout the application. \n\nThe theme object is then exported for use in other parts of the application."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/hooks", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/hooks/useError.js", "basename": "useError.js", "ext": ".js", "service_references": [], "summary": "This JavaScript file does not start an application server. It is a React Hook that provides a way to access and manipulate the error state from the AppContext. \n\nThe useError hook uses the useContext React Hook to access the error state from the AppContext. It then destructures the error state into errorState and setErrorState. The errorState is the current state of the error and setErrorState is a function to update this state. \n\nThe hook returns an object containing both errorState and setErrorState, allowing components that use this hook to both read the current error state and update it."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/hooks/useUser.js", "basename": "useUser.js", "ext": ".js", "service_references": ["confluence"], "summary": "The code is a React hook called `useUser` that provides various functionalities related to user management. It does not start an application server.\n\nThe hook uses the React's `useContext` and `useState` hooks to manage user state and other related states. The user state is obtained from the `AppContext` and is used to store user-related information.\n\nThe hook returns an object with several properties and methods:\n\n- `userState` and `setUserState`: The current user state and a function to update it.\n- `availableSpaces`, `loadingGetUserInfo`, `loadingAvailableSpaces`, `loadingUpdateConfluenceSpace`, `getUserError`, and `updateConfluenceError`: States and their setters for various aspects of the user's interaction with the application.\n- `checkUserAuthState`: A function that checks if the user is authenticated.\n- `getUserInfo`: A function that fetches the user's team information.\n- `loadAvailableSpaces`: A function that fetches available spaces for the user's team.\n- `updateConfluenceSpace`: A function that updates the currently selected Confluence space.\n- `logOut`: A function that logs the user out.\n\nThe hook makes use of the Fetch API to make HTTP requests to various endpoints, and updates the states accordingly based on the responses. It also handles errors and logs them to the console."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/hooks/useAuthModal.js", "basename": "useAuthModal.js", "ext": ".js", "service_references": [], "summary": "This code does not start an application server. It is a JavaScript file that exports a custom React Hook called `useAuthModal`. This hook is used to manage the state of an authentication modal in a React application. \n\nThe hook uses the `useContext` hook from React to access the `authModal` state from the `AppContext`. It then returns an object with several properties and methods related to the authentication modal:\n\n- `modalState`: The current state of the authentication modal.\n- `setModalState`: A function to update the state of the authentication modal.\n- `isOpen`: A boolean indicating whether the modal is currently open.\n- `openModal`: A function to open the modal, optionally with a specific mode (login or signup).\n- `closeModal`: A function to close the modal.\n- `isLoginMode`: A boolean indicating whether the modal is currently in login mode.\n- `isSignupMode`: A boolean indicating whether the modal is currently in signup mode.\n\nThe `openModal` and `closeModal` functions use the `setModalState` function to update the state of the modal. The `openModal` function can also change the mode of the modal if a different mode is passed as an argument."}]}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/constants.js", "basename": "constants.js", "ext": ".js", "service_references": [], "summary": "This JavaScript file is defining and exporting a series of constants that appear to be used for a marketing application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe constants include:\n\n- `FEEDBACK_URL`: A URL for a Google Forms feedback form.\n- `HEADER` and `FOOTER`: Objects defining the heights of the header and footer for both mobile and desktop versions of the application.\n- `AFFILIATE_LOGOS` and `INTEGRATION_LOGOS`: Objects containing information about logos for various affiliate and integration partners. Each logo has a source URL (generated by the `imageUrl` function imported from `asset-helpers.js`) and an alt text.\n- `AUTH_MODAL_STATE`: An object defining possible states for an authentication modal, including 'login' and 'signup'."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/index.js", "basename": "index.js", "ext": ".js", "service_references": [], "summary": "This JavaScript code is using React, a popular JavaScript library for building user interfaces. It is not starting an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe code imports the React library, the ReactDOM library (specifically the client-side version), and an App component from a local file named 'App.js'. \n\nIt then gets a DOM element with the id 'root' and creates a React root from it. This is a part of the new concurrent mode in React. \n\nFinally, it renders the imported App component into this root. This is typically the top-level component in a React app, and would contain all other components used in the application."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/asset-helpers.js", "basename": "asset-helpers.js", "ext": ".js", "service_references": [], "summary": "This JavaScript file does not start an application server like Express, Flask, Django, Gin, Rack, etc. Instead, it exports two helper functions: imageUrl and jsUrl. These functions are used to generate URLs for image and JavaScript files respectively. They do this by appending the filename to a base URL stored in window.eave.assetBase. The imageUrl function appends the filename to '/images/', and the jsUrl function appends the filename to '/dist/'."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/js/App.js", "basename": "App.js", "ext": ".js", "service_references": [], "summary": "This JavaScript file is part of a React application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe file imports several dependencies including React, react-router-dom for routing, react-cookie for managing cookies, @material-ui/core for UI components and theming, react-helmet for managing changes to the document head, and several custom components and contexts.\n\nThe App component is a class-based component that renders the main structure of the application. It uses a CookiesProvider to provide cookies to the rest of the app, an AppStoreProvider to provide application state, and a ThemeProvider to provide theme data. \n\nThe Helmet component is used to set the title of the document. \n\nThe AuthUser component presumably provides some sort of authentication-related functionality.\n\nThe Router component is used to set up routing for the application. It defines routes for a terms page, a privacy page, a dashboard (which is nested inside a PrivateRoutes component, presumably meaning it requires authentication), a home page, and a catch-all route that redirects to the home page.\n\nFinally, the App component is exported as the default export from the module, wrapped in the withCookies higher-order component to give it access to cookies."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/static", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/static/images", "dirs": [], "files": []}], "files": []}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/templates", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/templates/index.html.jinja", "basename": "index.html.jinja", "ext": ".jinja", "service_references": ["google_tag_manager", "google_fonts"], "summary": "This code is a Jinja template for an HTML file. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe template is used to generate the main index page for a web application. It includes several dynamic elements that are filled in when the template is rendered:\n\n- The `cookie_domain`, `api_base`, and `asset_base` are inserted into a JavaScript object on the window.\n- If analytics are enabled, it includes a script for Google Tag Manager.\n- The `asset_base` is used to generate URLs for the favicon and a JavaScript file.\n- The page title is either a provided value or a default string.\n\nThe page also includes Google Fonts, a meta description, and a viewport setting for responsive design. If analytics are enabled, it also includes a no-script fallback for Google Tag Manager. \n\nThe body of the page contains a message for users who have JavaScript disabled and a div with the id \"root\", which is typically where a JavaScript application would be mounted."}]}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/config.py", "basename": "config.py", "ext": ".py", "service_references": [], "summary": "The code is a Python script that defines a configuration class for an application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe AppConfig class inherits from the EaveConfig class in the eave.stdlib.config module. It sets the eave_origin attribute to EaveOrigin.eave_www.\n\nThe AppConfig class has two properties: asset_base and eave_web_session_encryption_key. The asset_base property returns the value of the EAVE_ASSET_BASE environment variable if it exists; otherwise, it returns \"/static\". \n\nThe eave_web_session_encryption_key property is a cached property that returns the value of the EAVE_WEB_SESSION_ENCRYPTION_KEY environment variable. If the application is in development mode, it defaults to \"dev-encryption-key\" if the environment variable is not set. In other modes, it retrieves the key as a secret.\n\nAt the end of the script, an instance of AppConfig is created and assigned to the variable app_config."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/__init__.py", "basename": "__init__.py", "ext": ".py", "service_references": []}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/eave/marketing/app.py", "basename": "app.py", "ext": ".py", "service_references": ["confluence"], "summary": "The code is a Flask application server for a marketing application. It imports various modules and sets up several routes for handling HTTP requests. \n\nThe routes include:\n- \"/status\" for getting the status of the application.\n- \"/_ah/warmup\", \"/_ah/start\", and \"/_ah/stop\" for starting, warming up, and stopping the application.\n- \"/authcheck\" for checking the authentication state of a user.\n- \"/dashboard/me/team\" for getting information about a user's team.\n- \"/dashboard/me/team/destinations/confluence/spaces/query\" for getting available spaces.\n- \"/dashboard/me/team/destinations/confluence/upsert\" for updating or inserting a Confluence destination.\n- \"/dashboard/logout\" for logging out a user.\n- A catch-all route for handling all other requests.\n\nThe application uses cookies for authentication and tracking. It also interacts with an external API to perform various operations related to a user's team and Confluence destinations."}], "service_name": "marketing_server"}], "files": []}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/package.json", "basename": "package.json", "ext": ".json", "service_references": [], "summary": "This is a package.json file for a Node.js application. It does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThe \"engines\" field specifies that this application requires Node.js version 18 and npm version 9.\n\nThe \"type\" field is set to \"module\", which means that this application uses ECMAScript modules.\n\nThe \"scripts\" field is currently empty, which means there are no custom scripts defined for tasks such as starting the server or running tests.\n\nThe \"dependencies\" field lists the libraries that the application needs to run. These include various React libraries, Material-UI for the user interface, classnames for CSS class manipulation, email-validator for email validation, react-cookie for cookie handling, react-router-dom for routing, and uuid for creating unique identifiers.\n\nThe \"devDependencies\" field lists the libraries needed for development but not for running the application. These include Babel for transpiling JavaScript code, eslint for linting, webpack for bundling the code, and various loaders for handling different types of files. The \"@eave-fyi/es-config\" dependency is loaded from a local file rather than from npm."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/marketing/webpack.config.cjs", "basename": "webpack.config.cjs", "ext": ".cjs", "service_references": [], "summary": "This code is a configuration file for Webpack, a popular static module bundler for JavaScript applications. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe configuration is set to development mode and specifies an entry point for the application at 'eave/marketing/js/index.js'. The output of the bundled files will be placed in 'eave/marketing/static/dist'.\n\nIt uses 'eval-source-map' as its devtool, which provides a good tradeoff between build speed and quality source maps for development.\n\nThe module rules specify how different types of files should be processed. JavaScript and JSX files are processed with Babel to transform modern JavaScript and React code into code that can run in older environments. CSS files are processed with style-loader and css-loader to inject styles into the DOM. Image files (png, jpg, jpeg, gif) are processed with file-loader to resolve import/require() on a file into a url and emits the file into the output directory.\n\nThere's also a configuration for a development server, but it's noted that it's not currently used in development. The server would serve static files from 'eave/marketing/static' under the '/static' public path. It's also configured to not show a full-screen overlay in the browser when there are compiler errors or warnings."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack", "dirs": [{"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/requests", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/requests/event_processor.py", "basename": "event_processor.py", "ext": ".py", "service_references": ["slack"], "summary": "The code in the file `event_processor.py` does not start an application server. It is a part of a larger application, possibly a web application, that uses the Starlette framework for Python.\n\nThe file defines a class `SlackEventProcessorTask` which inherits from `HTTPEndpoint`, a class provided by the Starlette framework. This class is designed to handle HTTP POST requests to a specific endpoint, `/_tasks/slack-events`.\n\nThe `post` method of the class is an asynchronous function that processes incoming requests. It first checks if the request has a valid signature. If the signature is not valid, it returns a success response to prevent Cloud Tasks from retrying the request.\n\nIf the signature is valid, it extracts the task execution count from the request headers and sets it in the logging context. It then creates an instance of `AsyncSlackRequestHandler` with the Slack app and handles the request with additional context properties.\n\nThe `_is_valid_signature` method is an asynchronous function that checks if the request has a valid signature. It extracts necessary information from the request headers and body, builds a message to sign, and verifies the signature. If any required information is missing or if the signature verification fails, it logs a warning and returns False. Otherwise, it returns True."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/requests/event_callback.py", "basename": "event_callback.py", "ext": ".py", "service_references": ["slack"], "summary": "The code in this file does not start an application server. It is a part of a larger application, likely a web server built with Starlette, a lightweight ASGI framework/toolkit for building asynchronous services in Python.\n\nThis file defines a class `SlackEventCallbackHandler` that extends `HTTPEndpoint` from the Starlette framework. This class is designed to handle HTTP POST requests to the `/slack/events` endpoint, which are expected to be event callbacks from Slack.\n\nThe `post` method is an asynchronous function that processes the incoming request. It first logs the request, then checks if the request is an SSL check, URL verification, or if the request has a valid Slack signature. If any of these checks fail, it returns a successful HTTP response to prevent Slack from retrying the request and to hide the failure reason from potential bad actors.\n\nIf the event is not of interest (determined by `_is_watched_event`), it is ignored and a successful response is returned. If the event is of interest, it is converted into an asynchronous Bolt request and a task is created from the request.\n\nThe class also includes several helper methods to perform various checks on the request, such as `_is_ssl_check`, `_is_url_verification`, `_is_signature_valid`, and `_is_watched_event`. The `_create_task` method creates a task from the request and adds it to a queue for further processing.\n\nThe commented-out `_try_react` method suggests that there may have been functionality to react to certain events with a thumbs-up emoji, but this has been disabled or removed.\n\nThe code uses several libraries including `slack_bolt`, `slack_sdk`, `starlette`, and `eave.stdlib`."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/requests/__init__.py", "basename": "__init__.py", "ext": ".py", "service_references": []}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/requests/warmup.py", "basename": "warmup.py", "ext": ".py", "service_references": [], "summary": "This Python script is not starting an application server like Express, Flask, Django, Gin, Rack, etc. Instead, it defines three HTTP endpoints using the Starlette library for ASGI applications: WarmupRequest, StartRequest, and StopRequest. \n\nThe WarmupRequest endpoint preloads shared and app configurations, preloads public keys, and tries to establish a Redis connection. If the Redis connection fails, it logs the exception but does not prevent the app from warming up. \n\nThe StartRequest and StopRequest endpoints simply log that they have received a start or stop request and return an HTTP 200 OK response. They don't perform any other actions. \n\nThe script uses the Eave library for logging, configuration management, caching, and signing."}]}, {"py/object": "eave.archer.fs_hierarchy.FSHierarchy", "root": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/brain", "dirs": [], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/brain/context_building.py", "basename": "context_building.py", "ext": ".py", "service_references": ["slack", "openai"], "summary": "This Python code does not start an application server. It is a module in a larger application, possibly a chatbot or AI assistant, that interacts with the Slack API and the OpenAI API. \n\nThe module is primarily concerned with building and managing context for messages. It defines a class `ContextBuildingMixin` which inherits from a `Base` class. This class has several asynchronous methods for building context from messages, including `build_message_context`, `build_context`, `build_concatenated_context`, `build_rolling_context`, and `build_link_context_and_subscribe`. \n\nThese methods gather messages from a conversation, format them, and build a context string. If the context is too long, it is condensed using the OpenAI API. The class also has methods to summarize content from URLs (`_summarize_content` and `_rolling_summarize_content`) and to subscribe to changes in files linked in the messages (`build_link_context_and_subscribe`). \n\nThe code uses the OpenAI GPT-4 model for context building and summarization tasks. It also uses memoization to optimize the `build_context` method, ensuring that the result is cached after the first call and reused in subsequent calls with the same arguments. \n\nErrors in retrieving data from Slack or OpenAI are handled by raising custom exceptions (`SlackDataError` and `OpenAIDataError`)."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/brain/document_metadata.py", "basename": "document_metadata.py", "ext": ".py", "service_references": ["openai"], "summary": "The code in the file `document_metadata.py` does not start an application server. It is a Python module that uses OpenAI's GPT-4 model to generate metadata for a given conversation. The module contains several asynchronous functions that use the OpenAI API to generate a title, a hierarchy, a documentation type, and the documentation itself for a conversation. \n\nThe `get_topic` function generates a title for the conversation. The `get_hierarchy` function generates a list of parent folders for the conversation. The `get_documentation_type` function determines the type of documentation that is most appropriate for the conversation. The `DocumentationType` class is an enumeration of possible documentation types. The `get_documentation` function generates the actual documentation for the conversation based on its type. \n\nEach function formats a prompt with the conversation and other parameters, sends it to the OpenAI API, and processes the response. If the OpenAI API does not return a response, an `OpenAIDataError` is raised."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/brain/message_prompts.py", "basename": "message_prompts.py", "ext": ".py", "service_references": ["openai"], "summary": "The code in the file `message_prompts.py` does not start an application server. It is a Python script that uses the OpenAI API to analyze messages and determine what action should be taken based on the content of the message. \n\nThe script imports necessary modules and defines a string constant `CONVO_STRUCTURE` which describes the order of conversation. \n\nIt defines an enumeration `MessageAction` which lists possible actions that can be taken based on a message. \n\nThe function `message_action` takes a context string and an optional logging context as arguments. It formats a prompt asking what action should be taken based on the message, sends this prompt to the OpenAI API, and returns the appropriate `MessageAction` based on the response. \n\nThe function `_get_openai_response` takes a list of messages and a temperature parameter, sends these to the OpenAI API, and returns the response. If no response is received, it raises an `OpenAIDataError`. \n\nThere is also commented out code for a `MessageType` enumeration and a `message_type` function, which would presumably determine the type of a message."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/brain/core.py", "basename": "core.py", "ext": ".py", "service_references": ["slack"], "summary": "The code is part of a Python module named `core.py` in a Slack application. It doesn't start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe module defines a class `Brain` that inherits from `IntentProcessingMixin`. This class seems to be responsible for processing incoming messages and events from Slack. It has methods to process messages (`process_message`), process shortcut events (`process_shortcut_event`), and load data (`load_data`).\n\nIn the `process_message` method, it checks if the incoming message has mentioned a user (presumably a bot named Eave). If Eave is mentioned, it acknowledges the receipt of the message, logs the event, and handles the action specified in the message. If Eave is not mentioned, it checks if there are any subscriptions. If there are no subscriptions, it logs that Eave is not subscribed to the thread and stops processing. If there are subscriptions, it sets the message action to `REFINE_DOCUMENTATION`, logs the event, and handles the action.\n\nThe `process_shortcut_event` method is currently only acknowledging the receipt of the event. The rest of its implementation is commented out.\n\nThe `load_data` method retrieves the user profile and expanded text from the message, builds the message context, and logs a warning if the expanded text is unexpectedly None."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/brain/document_management.py", "basename": "document_management.py", "ext": ".py", "service_references": ["openai", "slack"], "summary": "The code in the file `apps/slack/eave/slack/brain/document_management.py` is a Python module that defines a class `DocumentManagementMixin`. This class is responsible for managing documents in a Slack application. It does not start an application server.\n\nThe class has several asynchronous methods for managing documents, including creating, updating, archiving, and searching for documents. It also includes methods for building documentation from a conversation and building resources from messages. \n\nThe `create_documentation_and_subscribe` method checks if there's an existing subscription to a thread and creates initial documentation if there isn't. If there is, it notifies the user that the conversation is already being watched.\n\nThe `create_documentation` method generates documentation from the conversation, parses the generated documentation to add contextual information, saves the document to the organization's documentation destination, and sends a follow-up response to the original Slack thread with a link to the documentation.\n\nThe `search_documentation` method searches for relevant documentation and sends the results to the user.\n\nThe `update_documentation` method is currently a placeholder and does not perform any action.\n\nThe `refine_documentation` method rebuilds and updates the documentation.\n\nThe `archive_documentation` method deletes the documentation if it exists and sends a response to the user accordingly.\n\nThe `upsert_document` method updates an existing document or inserts a new document if it does not exist.\n\nThe `search_documents` method uses OpenAI to extract key terms from a conversation and uses these terms to search for relevant documentation."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/brain/intent_processing.py", "basename": "intent_processing.py", "ext": ".py", "service_references": ["slack"], "summary": "This Python code does not start an application server. It is part of a larger application, likely a chatbot for Slack, named Eave. The code is responsible for processing different types of user intents or actions in a conversation. \n\nThe `IntentProcessingMixin` class inherits from `DocumentManagementMixin` and `SubscriptionManagementMixin`, suggesting it has capabilities related to managing documents and subscriptions. \n\nThe `handle_action` method is an asynchronous function that processes different types of message actions, such as creating documentation, watching or unwatching a conversation, searching, updating, refining, deleting documentation, or handling an unknown request. \n\nThe `handle_unknown_request` method handles situations where the bot doesn't recognize the user's request. It logs a warning, sends a response to the user explaining that it doesn't know how to handle the request, and suggests rephrasing the message. It also checks if there's an active subscription and responds accordingly.\n\nThe `unwatch_conversation` method stops the bot from watching a conversation by deleting the subscription and logs this event."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/brain/communication.py", "basename": "communication.py", "ext": ".py", "service_references": ["slack"], "summary": "This Python code is part of a larger application, likely a chatbot or similar tool that interacts with Slack. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe file defines a class `CommunicationMixin` that inherits from a `Base` class. This `CommunicationMixin` class contains methods for sending responses, notifying of failures, acknowledging receipt of messages, and adding reactions in a Slack workspace.\n\nThe `send_response` method sends a message to the Slack workspace and logs the event. If any additional parameters are provided, they are also included in the log.\n\nThe `notify_failure` method sends a response indicating a technical issue and logs the event. If the exception is an `HTTPException`, the request id is included in the log.\n\nThe `acknowledge_receipt` method tries to add a reaction to a message to acknowledge its receipt. If the reaction fails because of an invalid name, it tries to add a different reaction. If it fails again, it logs a warning and gives up. If the reaction is added successfully, it logs the event.\n\nThe `_add_reaction` method tries to add a reaction to a message and its parent message. If the reaction fails because it has already been added or because of an invalid name, it logs a warning or an exception and raises the exception."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/brain/subscription_management.py", "basename": "subscription_management.py", "ext": ".py", "service_references": [], "summary": "The code in the file `subscription_management.py` does not start an application server. Instead, it defines a class `SubscriptionManagementMixin` that inherits from `CommunicationMixin`. This class has three asynchronous methods: `get_subscription`, `create_subscription`, and `notify_existing_subscription`.\n\nThe `get_subscription` method sends a request to get a subscription from an external service using the `GetSubscriptionRequest.perform` method from the `eave_subscriptions` module. It uses the context, origin, team ID, and subscription source as parameters for the request.\n\nThe `create_subscription` method either gets and returns an existing subscription or creates and returns a new one. It uses the `CreateSubscriptionRequest.perform` method from the `eave_subscriptions` module to do this. After creating a subscription, it logs an event named \"eave_subscribed\" with a description and some parameters.\n\nThe `notify_existing_subscription` method sends a response to notify of an existing subscription. If the subscription has a document reference, it sends a message saying that it's already watching the conversation and provides a link to the document. If there's no document reference, it doesn't send any response."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/brain/base.py", "basename": "base.py", "ext": ".py", "service_references": ["slack"], "summary": "The code does not start an application server like Express, Flask, Django, Gin, Rack, etc. \n\nThis Python code defines a base class for a Slack bot application. The class is named `Base` and it contains attributes related to Slack messages, user profiles, teams, and subscriptions. It also contains methods for logging events and getting the execution count of tasks.\n\nThe `Base` class is initialized with a Slack message, a team object, a Slack context object, and a logging context object. It also has a method `log_event` which logs events with various details like event name, description, source, team details, and other parameters.\n\nThe `execution_count` property method retrieves the count of task executions from the Slack context. If no count is found, it defaults to 0. The count is then returned as an integer. \n\nThe code also imports several modules and classes from different packages including typing for type hinting, slack_bolt for asynchronous Slack app development, eave for various functionalities like message prompts, configurations, Slack models, analytics, logging, and core API models."}]}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/config.py", "basename": "config.py", "ext": ".py", "service_references": ["slack"], "summary": "The code in the file does not start an application server. It is a configuration file for a Slack application that is part of a larger project, likely a microservice architecture, using the Eave framework.\n\nThe file defines several constants related to Slack events and tasks, such as the queue name and target path for Slack events, and context keys for task execution count and Eave context.\n\nIt also defines an AppConfig class that inherits from EaveConfig in the Eave standard library. This class specifies the origin of the Eave application and includes methods to retrieve the Slack app's signing secret and socket mode token from environment secrets. It also includes a method to check if the application is running in socket mode.\n\nAt the end of the file, an instance of AppConfig is created. This instance can be imported by other parts of the application to access the configuration settings."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/event_handlers.py", "basename": "event_handlers.py", "ext": ".py", "service_references": ["slack"], "summary": "The code is a Python script that handles events from a Slack application using the Slack Bolt framework. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe script imports necessary modules and defines several asynchronous functions to handle different types of events from Slack, such as messages, member joining a channel, and shortcuts. \n\nThe `register_event_handlers` function registers these handlers to the appropriate events in the Slack application. \n\nThe `error_handler` function logs any exceptions that occur during event handling. \n\nThe `shortcut_eave_watch_request_handler` function handles a shortcut event but currently returns immediately as it's not supported. \n\nThe `event_message_handler` function handles message events, processes the message, and handles any exceptions that occur during processing. \n\nThe `event_member_joined_channel_handler` function handles events when a member joins a channel. It sends an introductory message to the new member and logs the event. \n\nThe `noop_handler` function is a no-operation handler that simply acknowledges the event.\n\nThe script also includes error handling and logging functionalities."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/__init__.py", "basename": "__init__.py", "ext": ".py", "service_references": []}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/app.py", "basename": "app.py", "ext": ".py", "service_references": ["slack"], "summary": "The code is a Python script for a Starlette application server. Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. \n\nThe script starts by importing necessary modules and setting the time to UTC. It then defines several routes for the application, including routes for warmup, start, stop, and Slack event processing. \n\nThe \"/slack\" mount point includes a status route and an event route. The comment suggests that there will be future additions for API with signature and origin verification.\n\nA graceful shutdown function is defined to close the cache client if it's initialized.\n\nFinally, an instance of the Starlette application is created with the defined middleware, routes, and shutdown function. The application is not started in this script."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/slack_app.py", "basename": "slack_app.py", "ext": ".py", "service_references": ["slack"], "summary": "This Python script is part of a Slack application that uses the Slack SDK and the Eave library. It does not start an application server like Express, Flask, Django, Gin, Rack, etc.\n\nThe script imports necessary modules and defines two custom exceptions: `MissingSlackTeamIdError` and `MissingSlackClientError`. \n\nThe main function in this script is `authorize()`, which is an asynchronous function that handles the authorization of a Slack team. It uses the team ID and an instance of `AsyncWebClient` to authorize the team. If the team ID or client is not provided, it raises the custom exceptions defined earlier. The function also handles caching of the authorization data to improve performance and reduce unnecessary API requests.\n\nThe script then creates an instance of `AsyncApp`, a class from the Slack SDK that represents a Slack application. The instance is configured with several options, including disabling request verification, SSL check, and URL verification. This is because these checks are already handled elsewhere in the application. The `authorize()` function defined earlier is used as the authorization function for the app.\n\nFinally, the script registers event handlers for the app using a function from the Eave library. These event handlers will handle various events that occur in the Slack app, such as messages being sent or reactions being added."}, {"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/eave/slack/slack_models.py", "basename": "slack_models.py", "ext": ".py", "service_references": ["slack"], "summary": "The code in the file `slack_models.py` is part of a larger application, likely a Slack bot or integration, and it defines several classes that represent different entities in the Slack API, such as messages, reactions, profiles, and conversations. It does not start an application server.\n\nThe classes include methods to fetch data from the Slack API, parse and format messages, and perform actions like sending responses or adding reactions. The code uses the `slack_sdk` and `slack_bolt` libraries to interact with the Slack API.\n\nThe `SlackMessage` class is the most complex one. It represents a message in Slack and includes methods to parse and format the message text, resolve mentions of users, channels, and subteams, check if the message is a bot message or if it mentions a specific app, send responses, add reactions, and more.\n\nThe `SlackProfile` class represents a user profile in Slack and includes methods to fetch the profile data from the Slack API.\n\nThe `SlackConversation` class represents a conversation (channel) in Slack and includes methods to fetch the conversation data from the Slack API.\n\nThe `SlackReaction` class represents a reaction to a message in Slack.\n\nThe `SlackPermalink` class represents a permalink to a message in Slack.\n\nThe `SlackShortcut` class is not fully implemented yet."}], "service_name": "starlette_server"}], "files": []}], "files": [{"py/object": "eave.archer.fs_hierarchy.FileReference", "path": "/Users/teotimogarcia/Development/eave-monorepo/apps/slack/socketmode.py", "basename": "socketmode.py", "ext": ".py", "service_references": ["slack"], "summary": "The code is written in Python and it does not start an application server like Express, Flask, Django, Gin, Rack, etc. Instead, it uses asyncio and aiohttp to handle asynchronous operations and HTTP requests respectively.\n\nThe file `apps/slack/socketmode.py` is a part of a Slack application that uses Socket Mode to communicate with the Slack API. Socket Mode allows the app to receive events and interactive payloads from Slack over a WebSocket connection.\n\nThe code defines a class `AsyncSocketModeWithImmediateAckHandler` that extends `AsyncSocketModeHandler` from the `slack_bolt` library. This class overrides the `handle` method to immediately acknowledge (`ack`) the message from Slack, allowing the application to process the message without being rushed by Slack's timeout.\n\nThe function `start_socket_mode` is defined to start the Socket Mode client with the Slack app token from the app's configuration.\n\nIf this script is run directly (not imported as a module), it will start the Socket Mode client by running the `start_socket_mode` function in an asyncio event loop."}], "service_name": "slack_socket_mode"}], "files": []}