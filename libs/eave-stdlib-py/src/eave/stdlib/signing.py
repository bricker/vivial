import base64
import enum
import hashlib
from dataclasses import dataclass
from typing import Literal

import cryptography.exceptions
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec, padding, rsa, utils
from eave.stdlib.config import shared_config
from eave.stdlib.eave_origins import EaveOrigin
from google.cloud import kms
from google.protobuf.wrappers_pb2 import Int64Value

from . import checksum
from . import exceptions as eave_exceptions
from . import util as eave_util

KMS_KEYRING_LOCATION = "global"
KMS_KEYRING_NAME = "primary"


class SigningAlgorithm(enum.Enum):
    RS256 = "RS256"
    ES256 = "ES256"


@dataclass
class SigningKeyDetails:
    id: str
    version: str
    algorithm: SigningAlgorithm


_SIGNING_KEYS = {
    EaveOrigin.eave_api.value: SigningKeyDetails(
        id="eave-api-signing-key",
        version="1",
        algorithm=SigningAlgorithm.ES256,
    ),
    EaveOrigin.eave_www.value: SigningKeyDetails(
        id="eave-www-signing-key",
        version="1",
        algorithm=SigningAlgorithm.ES256,
    ),

    # This key was generated by Google, and is used to sign requests between the GitHub App and the Eave Core API.
    EaveOrigin.eave_github_app.value: SigningKeyDetails(
        id="eave-github-app-signing-key-02",
        version="1",
        algorithm=SigningAlgorithm.ES256,
    ),
    EaveOrigin.eave_slack_app.value: SigningKeyDetails(
        id="eave-slack-app-signing-key",
        version="1",
        algorithm=SigningAlgorithm.ES256,
    ),
    EaveOrigin.eave_atlassian_app.value: SigningKeyDetails(
        id="eave-atlassian-app-signing-key",
        version="1",
        algorithm=SigningAlgorithm.ES256,
    ),

    # This key was downloaded from GitHub, and then imported into KMS. It is used to sign requests between Eave and GitHub.
    "github_api_client": SigningKeyDetails(
        id="eave-github-app-signing-key-01",
        version="2",
        algorithm=SigningAlgorithm.RS256,
    ),
}


def get_key(signer: str) -> SigningKeyDetails:
    return _SIGNING_KEYS[signer]


def sign_b64(signing_key: SigningKeyDetails, data: str | bytes) -> str:
    """
    Signs the data with GCP KMS, and returns the base64-encoded signature
    """
    kms_client = kms.KeyManagementServiceClient()

    key_version_name = kms_client.crypto_key_version_path(
        project=shared_config.google_cloud_project,
        location=KMS_KEYRING_LOCATION,
        key_ring=KMS_KEYRING_NAME,
        crypto_key=signing_key.id,
        crypto_key_version=signing_key.version,
    )

    message_bytes = eave_util.ensure_bytes(data)
    digest = hashlib.sha256(message_bytes).digest()
    digest_crc32c = checksum.generate_checksum(data=digest)

    sign_response = kms_client.asymmetric_sign(
        request={"name": key_version_name, "digest": {"sha256": digest}, "digest_crc32c": digest_crc32c}
    )

    if sign_response.verified_digest_crc32c is False:
        raise eave_exceptions.InvalidChecksumError()
    if sign_response.name != key_version_name:
        raise eave_exceptions.InvalidChecksumError()

    checksum.validate_checksum_or_exception(data=sign_response.signature, checksum=sign_response.signature_crc32c)

    return eave_util.b64encode(sign_response.signature)


def verify_signature_or_exception(signing_key: SigningKeyDetails, message: str | bytes, signature: str | bytes) -> Literal[True]:
    """
    Verifies the signature matches the message.
    Either raises or returns True.
    The return value is to help you, the developer, understand that if this function doesn't throw,
    then the signature is verified.
    """
    message_bytes = eave_util.ensure_bytes(message)
    signature_bytes = base64.b64decode(signature)
    kms_client = kms.KeyManagementServiceClient()

    key_version_name = kms_client.crypto_key_version_path(
        project=shared_config.google_cloud_project,
        location=KMS_KEYRING_LOCATION,
        key_ring=KMS_KEYRING_NAME,
        crypto_key=signing_key.id,
        crypto_key_version=signing_key.version,
    )

    digest = hashlib.sha256(message_bytes).digest()

    public_key_from_kms = kms_client.get_public_key(request={"name": key_version_name})
    public_key_from_pem = serialization.load_pem_public_key(
        data=public_key_from_kms.pem.encode(), backend=default_backend()
    )
    sha256 = hashes.SHA256()

    try:
        match signing_key.algorithm:
            case SigningAlgorithm.RS256:
                assert isinstance(public_key_from_pem, rsa.RSAPublicKey)
                pad = padding.PKCS1v15()
                public_key_from_pem.verify(
                    signature=signature_bytes,
                    data=digest,
                    padding=pad,
                    algorithm=utils.Prehashed(sha256),
                )
                return True
            case SigningAlgorithm.ES256:
                assert isinstance(public_key_from_pem, ec.EllipticCurvePublicKey)
                public_key_from_pem.verify(
                    signature=signature_bytes,
                    data=digest,
                    signature_algorithm=ec.ECDSA(utils.Prehashed(sha256)),
                )
                return True
            case _:
                raise eave_exceptions.InvalidSignatureError(f"Unsupported algorithm: {signing_key.algorithm}")
    except cryptography.exceptions.InvalidSignature as e:
        raise eave_exceptions.InvalidSignatureError() from e
