(()=>{"use strict";var __webpack_modules__={"./src/content.mjs":
/*!*************************!*\
  !*** ./src/content.mjs ***!
  \*************************/(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _globals_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.mjs */ "./src/globals.mjs");\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.mjs */ "./src/helpers.mjs");\n/* harmony import */ var _query_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./query.mjs */ "./src/query.mjs");\n/* harmony import */ var _visibility_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./visibility.mjs */ "./src/visibility.mjs");\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  CONTENT_ATTR: "data-track-content",\n  CONTENT_CLASS: "eaveTrackContent",\n  CONTENT_NAME_ATTR: "data-content-name",\n  CONTENT_PIECE_ATTR: "data-content-piece",\n  CONTENT_PIECE_CLASS: "eaveContentPiece",\n  CONTENT_TARGET_ATTR: "data-content-target",\n  CONTENT_TARGET_CLASS: "eaveContentTarget",\n  CONTENT_IGNOREINTERACTION_ATTR: "data-content-ignoreinteraction",\n  CONTENT_IGNOREINTERACTION_CLASS: "eaveContentIgnoreInteraction",\n  location: undefined,\n\n  findContentNodes: function () {\n    var cssSelector = "." + this.CONTENT_CLASS;\n    var cssSelector2 = "." + this.LEGACY_CONTENT_CLASS;\n    var attrSelector = "[" + this.CONTENT_ATTR + "]";\n    var contentNodes = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findMultiple([\n      cssSelector,\n      cssSelector2,\n      attrSelector,\n    ]);\n\n    return contentNodes;\n  },\n  findContentNodesWithinNode: function (node) {\n    if (!node) {\n      return [];\n    }\n\n    // NOTE: we do not use query.findMultiple here as querySelectorAll would most likely not deliver the result we want\n\n    var nodes1 = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findNodesHavingCssClass(node, this.CONTENT_CLASS);\n    nodes1 = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findNodesHavingCssClass(\n      node,\n      this.LEGACY_CONTENT_CLASS,\n      nodes1,\n    );\n    var nodes2 = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findNodesHavingAttribute(node, this.CONTENT_ATTR);\n\n    if (nodes2 && nodes2.length) {\n      var index;\n      for (index = 0; index < nodes2.length; index++) {\n        nodes1.push(nodes2[index]);\n      }\n    }\n\n    if (_query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeAttribute(node, this.CONTENT_ATTR)) {\n      nodes1.push(node);\n    } else if (_query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeCssClass(node, this.CONTENT_CLASS)) {\n      nodes1.push(node);\n    } else if (_query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeCssClass(node, this.LEGACY_CONTENT_CLASS)) {\n      nodes1.push(node);\n    }\n\n    nodes1 = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].makeNodesUnique(nodes1);\n\n    return nodes1;\n  },\n  findParentContentNode: function (anyNode) {\n    if (!anyNode) {\n      return;\n    }\n\n    var node = anyNode;\n    var counter = 0;\n\n    while (node && node !== globalThis.eave.documentAlias && node.parentNode) {\n      if (_query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeAttribute(node, this.CONTENT_ATTR)) {\n        return node;\n      }\n      if (_query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeCssClass(node, this.CONTENT_CLASS)) {\n        return node;\n      }\n      if (_query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeCssClass(node, this.LEGACY_CONTENT_CLASS)) {\n        return node;\n      }\n\n      node = node.parentNode;\n\n      if (counter > 1000) {\n        break; // prevent loop, should not happen anyway but better we do this\n      }\n      counter++;\n    }\n  },\n  findPieceNode: function (node) {\n    var contentPiece;\n\n    contentPiece = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findFirstNodeHavingAttribute(\n      node,\n      this.CONTENT_PIECE_ATTR,\n    );\n\n    if (!contentPiece) {\n      contentPiece = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findFirstNodeHavingClass(\n        node,\n        this.CONTENT_PIECE_CLASS,\n      );\n    }\n    if (!contentPiece) {\n      contentPiece = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findFirstNodeHavingClass(\n        node,\n        this.LEGACY_CONTENT_PIECE_CLASS,\n      );\n    }\n\n    if (contentPiece) {\n      return contentPiece;\n    }\n\n    return node;\n  },\n  findTargetNodeNoDefault: function (node) {\n    if (!node) {\n      return;\n    }\n\n    var target = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findFirstNodeHavingAttributeWithValue(\n      node,\n      this.CONTENT_TARGET_ATTR,\n    );\n    if (target) {\n      return target;\n    }\n\n    target = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findFirstNodeHavingAttribute(node, this.CONTENT_TARGET_ATTR);\n    if (target) {\n      return target;\n    }\n\n    target = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findFirstNodeHavingClass(node, this.CONTENT_TARGET_CLASS);\n    if (target) {\n      return target;\n    }\n\n    target = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findFirstNodeHavingClass(\n      node,\n      this.LEGACY_CONTENT_TARGET_CLASS,\n    );\n    if (target) {\n      return target;\n    }\n  },\n  findTargetNode: function (node) {\n    var target = this.findTargetNodeNoDefault(node);\n    if (target) {\n      return target;\n    }\n\n    return node;\n  },\n  findContentName: function (node) {\n    if (!node) {\n      return;\n    }\n\n    var nameNode = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findFirstNodeHavingAttributeWithValue(\n      node,\n      this.CONTENT_NAME_ATTR,\n    );\n\n    if (nameNode) {\n      return _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getAttributeValueFromNode(nameNode, this.CONTENT_NAME_ATTR);\n    }\n\n    var contentPiece = this.findContentPiece(node);\n    if (contentPiece) {\n      return this.removeDomainIfIsInLink(contentPiece);\n    }\n\n    if (_query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeAttributeWithValue(node, "title")) {\n      return _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getAttributeValueFromNode(node, "title");\n    }\n\n    var clickUrlNode = this.findPieceNode(node);\n\n    if (_query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeAttributeWithValue(clickUrlNode, "title")) {\n      return _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getAttributeValueFromNode(clickUrlNode, "title");\n    }\n\n    var targetNode = this.findTargetNode(node);\n\n    if (_query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeAttributeWithValue(targetNode, "title")) {\n      return _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getAttributeValueFromNode(targetNode, "title");\n    }\n  },\n  findContentPiece: function (node) {\n    if (!node) {\n      return;\n    }\n\n    var nameNode = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findFirstNodeHavingAttributeWithValue(\n      node,\n      this.CONTENT_PIECE_ATTR,\n    );\n\n    if (nameNode) {\n      return _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getAttributeValueFromNode(nameNode, this.CONTENT_PIECE_ATTR);\n    }\n\n    var contentNode = this.findPieceNode(node);\n\n    var media = this.findMediaUrlInNode(contentNode);\n    if (media) {\n      return this.toAbsoluteUrl(media);\n    }\n  },\n  findContentTarget: function (node) {\n    if (!node) {\n      return;\n    }\n\n    var targetNode = this.findTargetNode(node);\n\n    if (_query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeAttributeWithValue(targetNode, this.CONTENT_TARGET_ATTR)) {\n      return _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getAttributeValueFromNode(\n        targetNode,\n        this.CONTENT_TARGET_ATTR,\n      );\n    }\n\n    var href;\n    if (_query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeAttributeWithValue(targetNode, "href")) {\n      href = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getAttributeValueFromNode(targetNode, "href");\n      return this.toAbsoluteUrl(href);\n    }\n\n    var contentNode = this.findPieceNode(node);\n\n    if (_query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeAttributeWithValue(contentNode, "href")) {\n      href = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getAttributeValueFromNode(contentNode, "href");\n      return this.toAbsoluteUrl(href);\n    }\n  },\n  isSameDomain: function (url) {\n    if (!url || !url.indexOf) {\n      return false;\n    }\n\n    if (0 === url.indexOf(this.getLocation().origin)) {\n      return true;\n    }\n\n    var posHost = url.indexOf(this.getLocation().host);\n    if (8 >= posHost && 0 <= posHost) {\n      return true;\n    }\n\n    return false;\n  },\n  removeDomainIfIsInLink: function (text) {\n    // we will only remove if domain === location.origin meaning is not an outlink\n    var regexContainsProtocol = "^https?://[^/]+";\n    var regexReplaceDomain = "^.*//[^/]+";\n\n    if (\n      text &&\n      text.search &&\n      -1 !== text.search(new RegExp(regexContainsProtocol)) &&\n      this.isSameDomain(text)\n    ) {\n      text = text.replace(new RegExp(regexReplaceDomain), "");\n      if (!text) {\n        text = "/";\n      }\n    }\n\n    return text;\n  },\n  findMediaUrlInNode: function (node) {\n    if (!node) {\n      return;\n    }\n\n    var mediaElements = ["img", "embed", "video", "audio"];\n    var elementName = node.nodeName.toLowerCase();\n\n    if (\n      -1 !== _helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.indexOfArray(mediaElements, elementName) &&\n      _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findFirstNodeHavingAttributeWithValue(node, "src")\n    ) {\n      var sourceNode = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findFirstNodeHavingAttributeWithValue(node, "src");\n\n      return _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getAttributeValueFromNode(sourceNode, "src");\n    }\n\n    if (\n      elementName === "object" &&\n      _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeAttributeWithValue(node, "data")\n    ) {\n      return _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getAttributeValueFromNode(node, "data");\n    }\n\n    if (elementName === "object") {\n      var params = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findNodesByTagName(node, "param");\n      if (params && params.length) {\n        var index;\n        for (index = 0; index < params.length; index++) {\n          if (\n            "movie" ===\n              _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getAttributeValueFromNode(params[index], "name") &&\n            _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeAttributeWithValue(params[index], "value")\n          ) {\n            return _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getAttributeValueFromNode(params[index], "value");\n          }\n        }\n      }\n\n      var embed = _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].findNodesByTagName(node, "embed");\n      if (embed && embed.length) {\n        return this.findMediaUrlInNode(embed[0]);\n      }\n    }\n  },\n  trim: function (text) {\n    return _helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trim(text);\n  },\n  isOrWasNodeInViewport: function (node) {\n    if (!node || !node.getBoundingClientRect || node.nodeType !== 1) {\n      return true;\n    }\n\n    var rect = node.getBoundingClientRect();\n    var html = globalThis.eave.documentAlias.documentElement || {};\n\n    var wasVisible = rect.top < 0;\n    if (wasVisible && node.offsetTop) {\n      wasVisible = node.offsetTop + rect.height > 0;\n    }\n\n    var docWidth = html.clientWidth; // The clientWidth attribute returns the viewport width excluding the size of a rendered scroll bar\n\n    if (\n      globalThis.eave.windowAlias.innerWidth &&\n      docWidth > globalThis.eave.windowAlias.innerWidth\n    ) {\n      docWidth = globalThis.eave.windowAlias.innerWidth; // The innerWidth attribute must return the viewport width including the size of a rendered scroll bar\n    }\n\n    var docHeight = html.clientHeight; // The clientWidth attribute returns the viewport width excluding the size of a rendered scroll bar\n\n    if (\n      globalThis.eave.windowAlias.innerHeight &&\n      docHeight > globalThis.eave.windowAlias.innerHeight\n    ) {\n      docHeight = globalThis.eave.windowAlias.innerHeight; // The innerWidth attribute must return the viewport width including the size of a rendered scroll bar\n    }\n\n    return (\n      (rect.bottom > 0 || wasVisible) &&\n      rect.right > 0 &&\n      rect.left < docWidth &&\n      (rect.top < docHeight || wasVisible) // rect.top < 0 we assume user has seen all the ones that are above the current viewport\n    );\n  },\n  isNodeVisible: function (node) {\n    var isItVisible = (0,_visibility_mjs__WEBPACK_IMPORTED_MODULE_3__.isVisible)(node);\n    var isInViewport = this.isOrWasNodeInViewport(node);\n    return isItVisible && isInViewport;\n  },\n  buildInteractionRequestParams: function (interaction, name, piece, target) {\n    var params = "";\n\n    if (interaction) {\n      params += "c_i=" + globalThis.eave.encodeWrapper(interaction);\n    }\n    if (name) {\n      if (params) {\n        params += "&";\n      }\n      params += "c_n=" + globalThis.eave.encodeWrapper(name);\n    }\n    if (piece) {\n      if (params) {\n        params += "&";\n      }\n      params += "c_p=" + globalThis.eave.encodeWrapper(piece);\n    }\n    if (target) {\n      if (params) {\n        params += "&";\n      }\n      params += "c_t=" + globalThis.eave.encodeWrapper(target);\n    }\n\n    if (params) {\n      params += "&ca=1";\n    }\n\n    return params;\n  },\n  buildImpressionRequestParams: function (name, piece, target) {\n    var params =\n      "c_n=" +\n      globalThis.eave.encodeWrapper(name) +\n      "&c_p=" +\n      globalThis.eave.encodeWrapper(piece);\n\n    if (target) {\n      params += "&c_t=" + globalThis.eave.encodeWrapper(target);\n    }\n\n    if (params) {\n      params += "&ca=1";\n    }\n\n    return params;\n  },\n  buildContentBlock: function (node) {\n    if (!node) {\n      return;\n    }\n\n    var name = this.findContentName(node);\n    var piece = this.findContentPiece(node);\n    var target = this.findContentTarget(node);\n\n    name = this.trim(name);\n    piece = this.trim(piece);\n    target = this.trim(target);\n\n    return {\n      name: name || "Unknown",\n      piece: piece || "Unknown",\n      target: target || "",\n    };\n  },\n  collectContent: function (contentNodes) {\n    if (!contentNodes || !contentNodes.length) {\n      return [];\n    }\n\n    var contents = [];\n\n    var index, contentBlock;\n    for (index = 0; index < contentNodes.length; index++) {\n      contentBlock = this.buildContentBlock(contentNodes[index]);\n      if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isDefined(contentBlock)) {\n        contents.push(contentBlock);\n      }\n    }\n\n    return contents;\n  },\n  setLocation: function (location) {\n    this.location = location;\n  },\n  getLocation: function () {\n    var locationAlias = this.location || globalThis.eave.windowAlias.location;\n\n    if (!locationAlias.origin) {\n      locationAlias.origin =\n        locationAlias.protocol +\n        "//" +\n        locationAlias.hostname +\n        (locationAlias.port ? ":" + locationAlias.port : "");\n    }\n\n    return locationAlias;\n  },\n  toAbsoluteUrl: function (url) {\n    if ((!url || String(url) !== url) && url !== "") {\n      // we only handle strings\n      return url;\n    }\n\n    if ("" === url) {\n      return this.getLocation().href;\n    }\n\n    // Eg //example.com/test.jpg\n    if (url.search(/^\\/\\//) !== -1) {\n      return this.getLocation().protocol + url;\n    }\n\n    // Eg http://example.com/test.jpg\n    if (url.search(/:\\/\\//) !== -1) {\n      return url;\n    }\n\n    // Eg #test.jpg\n    if (0 === url.indexOf("#")) {\n      return this.getLocation().origin + this.getLocation().pathname + url;\n    }\n\n    // Eg ?x=5\n    if (0 === url.indexOf("?")) {\n      return this.getLocation().origin + this.getLocation().pathname + url;\n    }\n\n    // Eg mailto:x@y.z tel:012345, ... market:... sms:..., javascript:... ecmascript: ... and many more\n    if (0 === url.search("^[a-zA-Z]{2,11}:")) {\n      return url;\n    }\n\n    // Eg /test.jpg\n    if (url.search(/^\\//) !== -1) {\n      return this.getLocation().origin + url;\n    }\n\n    // Eg test.jpg\n    var regexMatchDir = "(.*/)";\n    var base =\n      this.getLocation().origin +\n      this.getLocation().pathname.match(new RegExp(regexMatchDir))[0];\n    return base + url;\n  },\n  isUrlToCurrentDomain: function (url) {\n    var absoluteUrl = this.toAbsoluteUrl(url);\n\n    if (!absoluteUrl) {\n      return false;\n    }\n\n    var origin = this.getLocation().origin;\n    if (origin === absoluteUrl) {\n      return true;\n    }\n\n    if (0 === String(absoluteUrl).indexOf(origin)) {\n      if (":" === String(absoluteUrl).substr(origin.length, 1)) {\n        return false; // url has port whereas origin has not => different URL\n      }\n\n      return true;\n    }\n\n    return false;\n  },\n  setHrefAttribute: function (node, url) {\n    if (!node || !url) {\n      return;\n    }\n\n    _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].setAnyAttribute(node, "href", url);\n  },\n  shouldIgnoreInteraction: function (targetNode) {\n    if (\n      _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeAttribute(targetNode, this.CONTENT_IGNOREINTERACTION_ATTR)\n    ) {\n      return true;\n    }\n    if (\n      _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeCssClass(targetNode, this.CONTENT_IGNOREINTERACTION_CLASS)\n    ) {\n      return true;\n    }\n    if (\n      _query_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].hasNodeCssClass(\n        targetNode,\n        this.LEGACY_CONTENT_IGNOREINTERACTION_CLASS,\n      )\n    ) {\n      return true;\n    }\n    return false;\n  },\n});\n\n\n//# sourceURL=webpack://eave-tracing-client/./src/content.mjs?')},"./src/cookies.mjs":
/*!*************************!*\
  !*** ./src/cookies.mjs ***!
  \*************************/(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CookieManager: () => (/* binding */ CookieManager)\n/* harmony export */ });\n/* harmony import */ var _globals_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.mjs */ "./src/globals.mjs");\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.mjs */ "./src/helpers.mjs");\n\n\n\n/**\n * CookieManager class\n */\nclass CookieManager {\n  constructor() {\n    /* MEMBER FIELDS */\n    this.SESSION_COOKIE_NAME = "eave.session";\n    this.CONSENT_COOKIE_NAME = "eave_consent";\n    this.COOKIE_CONSENT_COOKIE_NAME = "eave_cookie_consent";\n    this.CONSENT_REMOVED_COOKIE_NAME = "eave_consent_removed";\n    // First-party cookie name prefix\n    this.configCookieNamePrefix = "_ev_";\n    // Life of the visitor cookie (in milliseconds)\n    this.configVisitorCookieTimeout = 33955200000; // 13 months (365 days + 28days)\n    // Life of the session cookie (in milliseconds)\n    this.configSessionCookieTimeout = 1800000; // 30 minutes\n    // Life of the referral cookie (in milliseconds)\n    this.configReferralCookieTimeout = 15768000000; // 6 months\n    // Eave cookies we manage\n    this.configCookiesToDelete = ["id", "ses", "cvar", "ref"];\n    // First-party cookie domain\n    // User agent defaults to origin hostname\n    this.configCookieDomain = undefined;\n    // First-party cookie path\n    // Default is user agent defined.\n    this.configCookiePath = undefined;\n    // Whether to use "Secure" cookies that only work over SSL\n    this.configCookieIsSecure = false;\n    // Set SameSite attribute for cookies\n    this.configCookieSameSite = "Lax";\n    // First-party cookies are disabled\n    this.configCookiesDisabled = false;\n  }\n\n  /**\n   * Get cookie value\n   *\n   * @returns {string|number} cookie value for `cookieName` or 0 if not found\n   */\n  getCookie(cookieName) {\n    if (\n      this.configCookiesDisabled &&\n      cookieName !== this.CONSENT_REMOVED_COOKIE_NAME\n    ) {\n      return 0;\n    }\n\n    var cookiePattern = new RegExp("(^|;)[ ]*" + cookieName + "=([^;]*)"),\n      cookieMatch = cookiePattern.exec(globalThis.eave.documentAlias.cookie);\n\n    return cookieMatch ? globalThis.eave.decodeWrapper(cookieMatch[2]) : 0;\n  };\n\n  /**\n   * Set cookie value\n   *\n   * @param {string} cookieName\n   * @param {string} value\n   * @param {number} msToExpire (optional)\n   * @param {string} path site path to limit cookie sharing to (default "/")\n   * @param {string} domain domain to limit cookie sharing to (optional)\n   * @param {boolean} isSecure wither cookie is only attached to https requests (default falsey)\n   * @param {string} sameSite cookie sharing restrictions (default "Lax")\n   *    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value\n   */\n  setCookie(\n    cookieName,\n    value,\n    msToExpire,\n    path,\n    domain,\n    isSecure,\n    sameSite,\n  ) {\n    if (\n      this.configCookiesDisabled &&\n      cookieName !== this.CONSENT_REMOVED_COOKIE_NAME\n    ) {\n      return;\n    }\n\n    var expiryDate;\n\n    // relative time to expire in milliseconds\n    if (msToExpire) {\n      expiryDate = new Date();\n      expiryDate.setTime(expiryDate.getTime() + msToExpire);\n    }\n\n    if (!sameSite) {\n      sameSite = "Lax";\n    }\n\n    globalThis.eave.documentAlias.cookie =\n      cookieName +\n      "=" +\n      globalThis.eave.encodeWrapper(value) +\n      (msToExpire ? ";expires=" + expiryDate.toGMTString() : "") +\n      ";path=" +\n      (path || "/") +\n      (domain ? ";domain=" + domain : "") +\n      (isSecure ? ";secure" : "") +\n      ";SameSite=" +\n      sameSite;\n\n    // check the cookie was actually set\n    if (\n      (!msToExpire || msToExpire >= 0) &&\n      this.getCookie(cookieName) !== String(value)\n    ) {\n      var msg =\n        "There was an error setting cookie `" +\n        cookieName +\n        "`. Please check domain and path.";\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.logConsoleError(msg);\n    }\n  };\n\n  /*\n   * Inits the custom variables object\n   */\n  getCustomVariablesFromCookie() {\n    var cookieName = this.getCookieName("cvar"),\n      cookie = this.getCookie(cookieName);\n\n    if (cookie && cookie.length) {\n      cookie = globalThis.eave.windowAlias.JSON.parse(cookie);\n\n      if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject(cookie)) {\n        return cookie;\n      }\n    }\n\n    return {};\n  };\n\n  /*\n   * Loads the referrer attribution information\n   *\n   * @returns {Array}\n   *  0: campaign name\n   *  1: campaign keyword\n   *  2: timestamp\n   *  3: raw URL\n   */\n  loadReferrerAttributionCookie() {\n    // NOTE: if the format of the cookie changes,\n    // we must also update JS tests, PHP tracker, System tests,\n    // and notify other tracking clients (eg. Java) of the changes\n    var cookie = this.getCookie(this.getCookieName("ref"));\n\n    if (cookie.length) {\n      try {\n        cookie = globalThis.eave.windowAlias.JSON.parse(cookie);\n        if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject(cookie)) {\n          return cookie;\n        }\n      } catch (ignore) {\n        // Pre 1.3, this cookie was not JSON encoded\n      }\n    }\n\n    return ["", "", 0, ""];\n  };\n\n  isPossibleToSetCookieOnDomain(domainToTest) {\n    var testCookieName = this.configCookieNamePrefix + "testcookie_domain";\n    var valueToSet = "testvalue";\n    this.setCookie(\n      testCookieName,\n      valueToSet,\n      10000,\n      null,\n      domainToTest,\n      this.configCookieIsSecure,\n      this.configCookieSameSite,\n    );\n\n    if (this.getCookie(testCookieName) === valueToSet) {\n      this.deleteCookie(testCookieName, null, domainToTest);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Deletes the set of cookies `configCookiesToDelete` that we manage\n   */\n  deleteCookies() {\n    var savedConfigCookiesDisabled = this.configCookiesDisabled;\n\n    // Temporarily allow cookies just to delete the existing ones\n    this.configCookiesDisabled = false;\n\n    var index, cookieName;\n\n    for (index = 0; index < this.configCookiesToDelete.length; index++) {\n      cookieName = this.getCookieName(this.configCookiesToDelete[index]);\n      if (\n        cookieName !== this.CONSENT_REMOVED_COOKIE_NAME &&\n        cookieName !== this.CONSENT_COOKIE_NAME &&\n        0 !== this.getCookie(cookieName)\n      ) {\n        this.deleteCookie(\n          cookieName,\n          this.configCookiePath,\n          this.configCookieDomain,\n        );\n      }\n    }\n\n    this.configCookiesDisabled = savedConfigCookiesDisabled;\n  };\n\n  /*\n   * Get cookie name with prefix and domain hash\n   */\n  getCookieName(baseName) {\n    return this.configCookieNamePrefix + baseName;\n  };\n\n  deleteCookie(cookieName, path, domain) {\n    this.setCookie(cookieName, "", -129600000, path, domain);\n  };\n\n  /*\n   * Does browser have cookies enabled (for this site)?\n   */\n  hasCookies() {\n    if (this.configCookiesDisabled) {\n      return "0";\n    }\n\n    if (\n      !_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isDefined(globalThis.eave.windowAlias.showModalDialog) &&\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isDefined(globalThis.eave.navigatorAlias.cookieEnabled)\n    ) {\n      return globalThis.eave.navigatorAlias.cookieEnabled ? "1" : "0";\n    }\n\n    // for IE we want to actually set the cookie to avoid trigger a warning eg in IE see #11507\n    var testCookieName = this.configCookieNamePrefix + "testcookie";\n    this.setCookie(\n      testCookieName,\n      "1",\n      undefined,\n      this.configCookiePath,\n      this.configCookieDomain,\n      this.configCookieIsSecure,\n      this.configCookieSameSite,\n    );\n\n    var hasCookie = this.getCookie(testCookieName) === "1" ? "1" : "0";\n    this.deleteCookie(testCookieName);\n    return hasCookie;\n  };\n\n  resetOrExtendSession() {\n    const sessionId = this.getCookie(this.SESSION_COOKIE_NAME) || _helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.uuidv4();\n    this.setCookie(\n      this.SESSION_COOKIE_NAME,\n      sessionId,\n      this.configSessionCookieTimeout,\n      undefined,\n      undefined,\n      true, // required true for "None" sameSite\n      "None", // ensure this cookie is attached to our atom event requests\n    );\n  };\n}\n\n\n//# sourceURL=webpack://eave-tracing-client/./src/cookies.mjs?')},"./src/eave-client.mjs":
/*!*****************************!*\
  !*** ./src/eave-client.mjs ***!
  \*****************************/(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _content_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./content.mjs */ "./src/content.mjs");\n/* harmony import */ var _globals_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.mjs */ "./src/globals.mjs");\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers.mjs */ "./src/helpers.mjs");\n/* harmony import */ var _tracker_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tracker.mjs */ "./src/tracker.mjs");\n/* harmony import */ var _visibility_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./visibility.mjs */ "./src/visibility.mjs");\n/*!\n * Eave - Intelligent Analytics\n *\n * JavaScript tracking client\n *\n * @link https://eave.fyi\n * @source https://github.com/eave-fyi/eave-tracing-client-js/\n * @license https://www.gnu.org/licenses/gpl-3.0.en.html#license-text GPLv3 (also in LICENSE.txt)\n */\n\n/*\nmodified from \n * https://github.com/matomo-org/tag-manager/ (GPLv3)\n * https://github.com/matomo-org/matomo/js/piwik.js (BSD-3)\n*/\n\n/*\n * Browser [In]Compatibility\n * - minimum required ECMAScript: ECMA-262, edition 3\n *\n * Incompatible with these (and earlier) versions of:\n * - IE4 - try..catch and for..in introduced in IE5\n * - IE5 - named anonymous functions, array.push, encodeURIComponent, decodeURIComponent, and getElementsByTagName introduced in IE5.5\n * - IE6 and 7 - window.JSON introduced in IE8\n * - Firefox 1.0 and Netscape 8.x - FF1.5 adds array.indexOf, among other things\n * - Mozilla 1.7 and Netscape 6.x-7.x\n * - Netscape 4.8\n * - Opera 6 - Error object (and Presto) introduced in Opera 7\n * - Opera 7\n */\n\n\n\n\n\n\n\n// eave singleton and namespace\nif (typeof window.eaveTracker !== "object") {\n  window.eaveTracker = (function () {\n    "use strict";\n\n    function TrackerProxy() {\n      return {\n        push: _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.apply,\n      };\n    }\n\n    /**\n     * Applies the given methods in the given order if they are present in paq.\n     *\n     * @param {Array} paq\n     * @param {Array} methodsToApply an array containing method names in the order that they should be applied\n     *                 eg [\'setSiteId\', \'setTrackerUrl\']\n     * @returns {Array} the modified paq array with the methods that were already applied set to undefined\n     */\n    function applyMethodsInOrder(paq, methodsToApply) {\n      var appliedMethods = {};\n      var index, iterator;\n\n      for (index = 0; index < methodsToApply.length; index++) {\n        var methodNameToApply = methodsToApply[index];\n        appliedMethods[methodNameToApply] = 1;\n\n        for (iterator = 0; iterator < paq.length; iterator++) {\n          if (paq[iterator] && paq[iterator][0]) {\n            var methodName = paq[iterator][0];\n\n            if (methodNameToApply === methodName) {\n              _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.apply(paq[iterator]);\n              delete paq[iterator];\n\n              if (\n                appliedMethods[methodName] > 1 &&\n                methodName !== "addTracker" &&\n                methodName !== "enableLinkTracking"\n              ) {\n                _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.logConsoleError(\n                  "The method " +\n                    methodName +\n                    \' is registered more than once in "globalThis.eave._paq" variable. Only the last call has an effect. Please have a look at the multiple eave trackers documentation: https://developer.matomo.org/guides/tracking-javascript-guide#multiple-piwik-trackers\',\n                );\n              }\n\n              appliedMethods[methodName]++;\n            }\n          }\n        }\n      }\n\n      return paq;\n    }\n\n    /************************************************************\n     * Constructor\n     ************************************************************/\n\n    // priority order for application of Tracker methods\n    var applyFirst = [\n      "addTracker",\n      "enableFileTracking",\n      "forgetCookieConsentGiven",\n      "requireCookieConsent",\n      "disableBrowserFeatureDetection",\n      "disableCampaignParameters",\n      "disableCookies",\n      "setTrackerUrl",\n      "setAPIUrl",\n      "enableCrossDomainLinking",\n      "setCrossDomainLinkingTimeout",\n      "setDomains",\n      "setUserId",\n      "setSiteId",\n      "alwaysUseSendBeacon",\n      "disableAlwaysUseSendBeacon",\n      "enableLinkTracking",\n      "setCookieConsentGiven",\n      "requireConsent",\n      "setConsentGiven",\n      "disablePerformanceTracking",\n      "setPagePerformanceTiming",\n      "setExcludedQueryParams",\n      "setExcludedReferrers",\n    ];\n\n    function createFirstTracker(eaveUrl, siteId) {\n      var tracker = new _tracker_mjs__WEBPACK_IMPORTED_MODULE_3__.Tracker(eaveUrl, siteId);\n      globalThis.eave.asyncTrackers.push(tracker);\n\n      globalThis.eave._paq = applyMethodsInOrder(\n        globalThis.eave._paq,\n        applyFirst,\n      );\n\n      // apply the queue of actions\n      for (\n        var iterator = 0;\n        iterator < globalThis.eave._paq.length;\n        iterator++\n      ) {\n        if (globalThis.eave._paq[iterator]) {\n          _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.apply(globalThis.eave._paq[iterator]);\n        }\n      }\n\n      // replace initialization array with proxy object\n      globalThis.eave._paq = new TrackerProxy();\n\n      globalThis.eave.eave.trigger("TrackerAdded", [tracker]);\n\n      return tracker;\n    }\n\n    /************************************************************\n     * Proxy object\n     * - this allows the caller to continue push()\'ing to globalThis.eave._paq\n     *   after the Tracker has been initialized and loaded\n     ************************************************************/\n\n    // initialize the eave singleton\n    _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.addEventListener(\n      globalThis.eave.windowAlias,\n      "beforeunload",\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.beforeUnloadHandler,\n      false,\n    );\n    _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.addEventListener(\n      globalThis.eave.windowAlias,\n      "visibilitychange",\n      function () {\n        // if unloaded, return\n        if (globalThis.eave.isPageUnloading) {\n          return;\n        }\n        // if not visible\n        if (globalThis.eave.documentAlias.visibilityState === "hidden") {\n          _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.executePluginMethod("unload");\n        }\n      },\n      false,\n    );\n    _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.addEventListener(\n      globalThis.eave.windowAlias,\n      "online",\n      function () {\n        if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.isDefined(globalThis.eave.navigatorAlias.serviceWorker)) {\n          globalThis.eave.navigatorAlias.serviceWorker.ready.then(\n            function (swRegistration) {\n              if (swRegistration && swRegistration.sync) {\n                return swRegistration.sync.register("eaveSync");\n              }\n            },\n            function () {\n              // handle (but ignore) failed promise, see https://github.com/matomo-org/matomo/issues/17454\n            },\n          );\n        }\n      },\n      false,\n    );\n\n    _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.addEventListener(\n      globalThis.eave.windowAlias,\n      "message",\n      function (e) {\n        if (!e || !e.origin) {\n          return;\n        }\n\n        var tracker, i, eaveHost;\n        var originHost = _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.getHostName(e.origin);\n\n        var trackers = globalThis.eave.eave.getAsyncTrackers();\n        for (i = 0; i < trackers.length; i++) {\n          eaveHost = _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.getHostName(trackers[i].getEaveUrl());\n\n          // find the matching tracker\n          if (eaveHost === originHost) {\n            tracker = trackers[i];\n            break;\n          }\n        }\n\n        if (!tracker) {\n          // no matching tracker\n          // Don\'t accept the message unless it came from the expected origin\n          return;\n        }\n\n        var data = null;\n        try {\n          data = JSON.parse(e.data);\n        } catch (ex) {\n          return;\n        }\n\n        if (!data) {\n          return;\n        }\n\n        function postMessageToCorrectFrame(postMessage) {\n          // Find the iframe with the right URL to send it back to\n          var iframes =\n            globalThis.eave.documentAlias.getElementsByTagName("iframe");\n          for (i = 0; i < iframes.length; i++) {\n            var iframe = iframes[i];\n            var iframeHost = _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.getHostName(iframe.src);\n\n            if (\n              iframe.contentWindow &&\n              _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.isDefined(iframe.contentWindow.postMessage) &&\n              iframeHost === originHost\n            ) {\n              var jsonMessage = JSON.stringify(postMessage);\n              iframe.contentWindow.postMessage(jsonMessage, e.origin);\n            }\n          }\n        }\n\n        // This listener can process two kinds of messages\n        // 1) maq_initial_value => sent by optout iframe when it finishes loading.  Passes the value of the third\n        // party opt-out cookie (if set) - we need to use this and any first-party cookies that are present to\n        // initialise the configHasConsent value and send back the result so that the display can be updated.\n        // 2) maq_opted_in => sent by optout iframe when the user changes their optout setting.  We need to update\n        // our first-party cookie.\n        if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.isDefined(data.maq_initial_value)) {\n          // Make a message to tell the optout iframe about the current state\n\n          postMessageToCorrectFrame({\n            maq_opted_in: data.maq_initial_value && tracker.hasConsent(),\n            maq_url: tracker.getEaveUrl(),\n            maq_optout_by_default: tracker.isConsentRequired(),\n          });\n        } else if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.isDefined(data.maq_opted_in)) {\n          // perform the opt in or opt out...\n          trackers = globalThis.eave.eave.getAsyncTrackers();\n          for (i = 0; i < trackers.length; i++) {\n            tracker = trackers[i];\n            if (data.maq_opted_in) {\n              tracker.rememberConsentGiven();\n            } else {\n              tracker.forgetConsentGiven();\n            }\n          }\n\n          // Make a message to tell the optout iframe about the current state\n          postMessageToCorrectFrame({\n            maq_confirm_opted_in: tracker.hasConsent(),\n            maq_url: tracker.getEaveUrl(),\n            maq_optout_by_default: tracker.isConsentRequired(),\n          });\n        }\n      },\n      false,\n    );\n\n    Date.prototype.getTimeAlias = Date.prototype.getTime;\n\n    /************************************************************\n     * Public data and methods\n     ************************************************************/\n\n    globalThis.eave.eave = {\n      initialized: false,\n\n      JSON: globalThis.eave.windowAlias.JSON,\n\n      /**\n       * DOM Document related methods\n       */\n      DOM: {\n        /**\n         * Adds an event listener to the given element.\n         * @param element\n         * @param eventType\n         * @param eventHandler\n         * @param useCapture  Optional\n         */\n        addEventListener: function (\n          element,\n          eventType,\n          eventHandler,\n          useCapture,\n        ) {\n          var captureType = typeof useCapture;\n          if (captureType === "undefined") {\n            useCapture = false;\n          }\n\n          _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.addEventListener(element, eventType, eventHandler, useCapture);\n        },\n        /**\n         * Specify a function to execute when the DOM is fully loaded.\n         *\n         * If the DOM is already loaded, the function will be executed immediately.\n         *\n         * @param {Function} callback\n         */\n        onLoad: _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.trackCallbackOnLoad,\n\n        /**\n         * Specify a function to execute when the DOM is ready.\n         *\n         * If the DOM is already ready, the function will be executed immediately.\n         *\n         * @param {Function} callback\n         */\n        onReady: _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.trackCallbackOnReady,\n\n        /**\n         * Detect whether a node is visible right now.\n         */\n        isNodeVisible: _visibility_mjs__WEBPACK_IMPORTED_MODULE_4__.isVisible,\n\n        /**\n         * Detect whether a node has been visible at some point\n         */\n        isOrWasNodeVisible: _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNodeVisible,\n      },\n\n      /**\n       * Listen to an event and invoke the handler when a the event is triggered.\n       *\n       * @param {string} event\n       * @param {Function} handler\n       */\n      on: function (event, handler) {\n        if (!globalThis.eave.eventHandlers[event]) {\n          globalThis.eave.eventHandlers[event] = [];\n        }\n\n        globalThis.eave.eventHandlers[event].push(handler);\n      },\n\n      /**\n       * Remove a handler to no longer listen to the event. Must pass the same handler that was used when\n       * attaching the event via ".on".\n       * @param {string} event\n       * @param {Function} handler\n       */\n      off: function (event, handler) {\n        if (!globalThis.eave.eventHandlers[event]) {\n          return;\n        }\n\n        var i = 0;\n        for (i; i < globalThis.eave.eventHandlers[event].length; i++) {\n          if (globalThis.eave.eventHandlers[event][i] === handler) {\n            globalThis.eave.eventHandlers[event].splice(i, 1);\n          }\n        }\n      },\n\n      /**\n       * Triggers the given event and passes the parameters to all handlers.\n       *\n       * @param {string} event\n       * @param {Array} extraParameters\n       * @param {Object} context  If given the handler will be executed in this context\n       */\n      trigger: function (event, extraParameters, context) {\n        if (!globalThis.eave.eventHandlers[event]) {\n          return;\n        }\n\n        var i = 0;\n        for (i; i < globalThis.eave.eventHandlers[event].length; i++) {\n          globalThis.eave.eventHandlers[event][i].apply(\n            context || globalThis.eave.windowAlias,\n            extraParameters,\n          );\n        }\n      },\n\n      /**\n       * Add plugin\n       *\n       * @param {string} pluginName\n       * @param {Object} pluginObj\n       */\n      addPlugin: function (pluginName, pluginObj) {\n        globalThis.eave.plugins[pluginName] = pluginObj;\n      },\n\n      /**\n       * Get Tracker (factory method)\n       *\n       * @param {string} eaveUrl\n       * @param {int|string} siteId\n       * @returns {Tracker}\n       */\n      getTracker: function (eaveUrl, siteId) {\n        if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.isDefined(siteId)) {\n          siteId = this.getAsyncTracker().getSiteId();\n        }\n        if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.isDefined(eaveUrl)) {\n          eaveUrl = this.getAsyncTracker().getTrackerUrl();\n        }\n\n        return new _tracker_mjs__WEBPACK_IMPORTED_MODULE_3__.Tracker(eaveUrl, siteId);\n      },\n\n      /**\n       * Get all created async trackers\n       *\n       * @returns {Tracker[]}\n       */\n      getAsyncTrackers: function () {\n        return globalThis.eave.asyncTrackers;\n      },\n\n      /**\n       * Adds a new tracker. All sent requests will be also sent to the given siteId and eaveUrl.\n       * If eaveUrl is not set, current url will be used.\n       *\n       * @param {null|string} eaveUrl  If null, will reuse the same tracker URL of the current tracker instance\n       * @param {int|string} siteId\n       * @returns {Tracker}\n       */\n      addTracker: function (eaveUrl, siteId) {\n        var tracker;\n        if (!globalThis.eave.asyncTrackers.length) {\n          tracker = createFirstTracker(eaveUrl, siteId);\n        } else {\n          tracker = globalThis.eave.asyncTrackers[0].addTracker(\n            eaveUrl,\n            siteId,\n          );\n        }\n        return tracker;\n      },\n\n      /**\n       * Get internal asynchronous tracker object.\n       *\n       * If no parameters are given, it returns the internal asynchronous tracker object. If a eaveUrl and idSite\n       * is given, it will try to find an optional\n       *\n       * @param {string} eaveUrl\n       * @param {int|string} siteId\n       * @returns {Tracker}\n       */\n      getAsyncTracker: function (eaveUrl, siteId) {\n        var firstTracker;\n        if (\n          globalThis.eave.asyncTrackers &&\n          globalThis.eave.asyncTrackers.length &&\n          globalThis.eave.asyncTrackers[0]\n        ) {\n          firstTracker = globalThis.eave.asyncTrackers[0];\n        } else {\n          return createFirstTracker(eaveUrl, siteId);\n        }\n\n        if (!siteId && !eaveUrl) {\n          // for BC and by default we just return the initially created tracker\n          return firstTracker;\n        }\n\n        // we look for another tracker created via `addTracker` method\n        if ((!_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.isDefined(siteId) || null === siteId) && firstTracker) {\n          siteId = firstTracker.getSiteId();\n        }\n\n        if ((!_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.isDefined(eaveUrl) || null === eaveUrl) && firstTracker) {\n          eaveUrl = firstTracker.getTrackerUrl();\n        }\n\n        var tracker,\n          i = 0;\n        for (i; i < globalThis.eave.asyncTrackers.length; i++) {\n          tracker = globalThis.eave.asyncTrackers[i];\n          if (\n            tracker &&\n            String(tracker.getSiteId()) === String(siteId) &&\n            tracker.getTrackerUrl() === eaveUrl\n          ) {\n            return tracker;\n          }\n        }\n      },\n\n      /**\n       * NOTE: not sure if this is relevant since matomo fork\n       * When calling plugin methods via "globalThis.eave._paq.push([\'...\'])" and the plugin is loaded separately because\n       * eave.js is not writable then there is a chance that first eave.js is loaded and later the plugin.\n       * In this case we would have already executed all "globalThis.eave._paq.push" methods and they would not have succeeded\n       * because the plugin will be loaded only later. In this case, once a plugin is loaded, it should call\n       * "eave.retryMissedPluginCalls()" so they will be executed after all.\n       */\n      retryMissedPluginCalls: function () {\n        var missedCalls = globalThis.eave.missedPluginTrackerCalls;\n        globalThis.eave.missedPluginTrackerCalls = [];\n        var i = 0;\n        for (i; i < missedCalls.length; i++) {\n          _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.apply(missedCalls[i]);\n        }\n      },\n    };\n    console.log("assigned to global.eave.eave", globalThis.eave.eave)\n\n    // Expose eave as an AMD module\n    if (typeof define === "function" && define.amd) {\n      define("eave", [], function () {\n        return globalThis.eave.eave;\n      });\n    }\n\n    return globalThis.eave.eave;\n  })();\n}\n\n/* pluginTrackerHook */\n\n(function () {\n  "use strict";\n\n  function hasPaqConfiguration() {\n    if ("object" !== typeof globalThis.eave._paq) {\n      return false;\n    }\n    // needed to write it this way for jslint\n    var lengthType = typeof globalThis.eave._paq.length;\n    if ("undefined" === lengthType) {\n      return false;\n    }\n\n    return !!globalThis.eave._paq.length;\n  }\n\n  if (\n    window &&\n    "object" === typeof window.eaveTrackerPluginAsyncInit &&\n    window.eaveTrackerPluginAsyncInit.length\n  ) {\n    var i = 0;\n    for (i; i < window.eaveTrackerPluginAsyncInit.length; i++) {\n      if (typeof window.eaveTrackerPluginAsyncInit[i] === "function") {\n        window.eaveTrackerPluginAsyncInit[i]();\n      }\n    }\n  }\n\n  if (window && window.eaveTrackerAsyncInit) {\n    window.eaveTrackerAsyncInit();\n  }\n\n  console.log("glbl.eave", globalThis.eave)\n  console.log("window.eaveTracker")\n  if (!globalThis.eave.eave.getAsyncTrackers().length) {\n    // we only create an initial tracker when no other async tracker has been created yet in eaveAsyncInit()\n    if (hasPaqConfiguration()) {\n      // we only create an initial tracker if there is a configuration for it via globalThis.eave._paq. Otherwise\n      // eave.getAsyncTrackers() would return unconfigured trackers\n      globalThis.eave.eave.addTracker();\n    } else {\n      globalThis.eave._paq = {\n        push: function (args) {\n          // needed to write it this way for jslint\n          var consoleType = typeof console;\n          if (consoleType !== "undefined" && console && console.error) {\n            console.error(\n              "globalThis.eave._paq.push() was used but eave tracker was not initialized before the eave.js file was loaded. Make sure to configure the tracker via globalThis.eave._paq.push before loading eave.js. Alternatively, you can create a tracker via eave.addTracker() manually and then use globalThis.eave._paq.push but it may not fully work as tracker methods may not be executed in the correct order.",\n              args,\n            );\n          }\n        },\n      };\n    }\n  }\n\n  window.eaveTracker.trigger("eaveInitialized", []);\n  window.eaveTracker.initialized = true;\n})();\n\n/*jslint sloppy: true */\n(function () {\n  var jsTrackerType = typeof window.AnalyticsTracker;\n  if (jsTrackerType === "undefined") {\n    window.AnalyticsTracker = window.eaveTracker;\n  }\n})();\n/*jslint sloppy: false */\n\n/*! @license-end */\n\n\n//# sourceURL=webpack://eave-tracing-client/./src/eave-client.mjs?')},"./src/globals.mjs":
/*!*************************!*\
  !*** ./src/globals.mjs ***!
  \*************************/(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\nvar documentAlias = document,\n  navigatorAlias = navigator,\n  screenAlias = screen,\n  windowAlias = window;\n\nvar _paq = [];\n_paq.push(["setTrackingCookies"])\n_paq.push(["trackPageView"]);\n_paq.push(["enableLinkTracking"]);\n_paq.push(["enableRouteHistoryTracking"]);\n_paq.push(["enableButtonClickTracking"]);\n// TODO: update to point to eave backend\n_paq.push(["setTrackerUrl", "http://localhost:3000/matomo"]);\n// _paq.push([\'setSiteId\', \'1\']); // TODO: this isnt necessary?\n\nglobalThis.eave = {\n  expireDateTime: undefined,\n  _paq,\n  /* plugins */\n  plugins: {},\n  eventHandlers: {},\n  /* alias frequently used globals for added minification */\n  documentAlias,\n  navigatorAlias,\n  windowAlias,\n  screenAlias,\n  /* performance timing */\n  performanceAlias:\n    windowAlias.performance ||\n    windowAlias.mozPerformance ||\n    windowAlias.msPerformance ||\n    windowAlias.webkitPerformance,\n  /* encode */\n  encodeWrapper: windowAlias.encodeURIComponent,\n  /* decode */\n  decodeWrapper: windowAlias.decodeURIComponent,\n  /* urldecode */\n  urldecode: unescape,\n  /* asynchronous tracker */\n  asyncTrackers: [],\n  /* local eave */\n  eave: undefined,\n  missedPluginTrackerCalls: [],\n  coreConsentCounter: 0,\n  coreHeartBeatCounter: 0,\n  trackerIdCounter: 0,\n  isPageUnloading: false,\n  trackerInstallCheckNonce: "",\n};\n\n\n//# sourceURL=webpack://eave-tracing-client/./src/globals.mjs?')},"./src/helpers.mjs":
/*!*************************!*\
  !*** ./src/helpers.mjs ***!
  \*************************/(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEventListener: () => (/* binding */ addEventListener),\n/* harmony export */   addUrlParameter: () => (/* binding */ addUrlParameter),\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   argsToQueryParameters: () => (/* binding */ argsToQueryParameters),\n/* harmony export */   arrayChunk: () => (/* binding */ arrayChunk),\n/* harmony export */   beforeUnloadHandler: () => (/* binding */ beforeUnloadHandler),\n/* harmony export */   containsNodeElement: () => (/* binding */ containsNodeElement),\n/* harmony export */   domainFixup: () => (/* binding */ domainFixup),\n/* harmony export */   executePluginMethod: () => (/* binding */ executePluginMethod),\n/* harmony export */   filterIn: () => (/* binding */ filterIn),\n/* harmony export */   generateUniqueId: () => (/* binding */ generateUniqueId),\n/* harmony export */   getChildrenFromNode: () => (/* binding */ getChildrenFromNode),\n/* harmony export */   getCurrentTimestampInSeconds: () => (/* binding */ getCurrentTimestampInSeconds),\n/* harmony export */   getHostName: () => (/* binding */ getHostName),\n/* harmony export */   getProtocolScheme: () => (/* binding */ getProtocolScheme),\n/* harmony export */   getReferrer: () => (/* binding */ getReferrer),\n/* harmony export */   getUrlParameter: () => (/* binding */ getUrlParameter),\n/* harmony export */   indexOfArray: () => (/* binding */ indexOfArray),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isNumberOrHasLength: () => (/* binding */ isNumberOrHasLength),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isObjectEmpty: () => (/* binding */ isObjectEmpty),\n/* harmony export */   isPositiveNumberString: () => (/* binding */ isPositiveNumberString),\n/* harmony export */   isSameHost: () => (/* binding */ isSameHost),\n/* harmony export */   isSitePath: () => (/* binding */ isSitePath),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   loadScript: () => (/* binding */ loadScript),\n/* harmony export */   logConsoleError: () => (/* binding */ logConsoleError),\n/* harmony export */   onlyPositiveIntegers: () => (/* binding */ onlyPositiveIntegers),\n/* harmony export */   queryStringify: () => (/* binding */ queryStringify),\n/* harmony export */   removeCharactersFromEndOfString: () => (/* binding */ removeCharactersFromEndOfString),\n/* harmony export */   removeUrlParameter: () => (/* binding */ removeUrlParameter),\n/* harmony export */   safeDecodeWrapper: () => (/* binding */ safeDecodeWrapper),\n/* harmony export */   setExpireDateTime: () => (/* binding */ setExpireDateTime),\n/* harmony export */   sha1: () => (/* binding */ sha1),\n/* harmony export */   sortObjectsByKeys: () => (/* binding */ sortObjectsByKeys),\n/* harmony export */   stringContains: () => (/* binding */ stringContains),\n/* harmony export */   stringEndsWith: () => (/* binding */ stringEndsWith),\n/* harmony export */   stringStartsWith: () => (/* binding */ stringStartsWith),\n/* harmony export */   titleFixup: () => (/* binding */ titleFixup),\n/* harmony export */   trackCallbackOnLoad: () => (/* binding */ trackCallbackOnLoad),\n/* harmony export */   trackCallbackOnReady: () => (/* binding */ trackCallbackOnReady),\n/* harmony export */   trim: () => (/* binding */ trim),\n/* harmony export */   urlFixup: () => (/* binding */ urlFixup),\n/* harmony export */   utf8_encode: () => (/* binding */ utf8_encode),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4)\n/* harmony export */ });\n/* harmony import */ var _globals_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.mjs */ "./src/globals.mjs");\n\n\n/**\n * See https://github.com/matomo-org/matomo/issues/8413\n * To prevent Javascript Error: Uncaught URIError: URI malformed when encoding is not UTF-8. Use this method\n * instead of decodeWrapper if a text could contain any non UTF-8 encoded characters eg\n * a URL like http://apache.matomo/test.html?%F6%E4%FC or a link like\n * <a href="test-with-%F6%E4%FC/story/0">(encoded iso-8859-1 URL)</a>\n */\nfunction safeDecodeWrapper(url) {\n  try {\n    return globalThis.eave.decodeWrapper(url);\n  } catch (e) {\n    return unescape(url);\n  }\n}\n\n/*\n * Is property defined?\n */\nfunction isDefined(property) {\n  // workaround https://github.com/douglascrockford/JSLint/commit/24f63ada2f9d7ad65afc90e6d949f631935c2480\n  var propertyType = typeof property;\n\n  return propertyType !== "undefined";\n}\n\n/*\n * Is property a function?\n */\nfunction isFunction(property) {\n  return typeof property === "function";\n}\n\n/*\n * Is property an object?\n *\n * @returns {boolean} Returns true if property is null, an Object, or subclass of Object (i.e., an instanceof String, Date, etc.)\n */\nfunction isObject(property) {\n  return typeof property === "object";\n}\n\n/*\n * Is property a string?\n */\nfunction isString(property) {\n  return typeof property === "string" || property instanceof String;\n}\n\n/*\n * Is property a string?\n */\nfunction isNumber(property) {\n  return typeof property === "number" || property instanceof Number;\n}\n\n/*\n * Is property a string?\n */\nfunction isNumberOrHasLength(property) {\n  return (\n    isDefined(property) &&\n    (isNumber(property) || (isString(property) && property.length))\n  );\n}\n\nfunction isObjectEmpty(property) {\n  if (!property) {\n    return true;\n  }\n\n  var i;\n  for (i in property) {\n    if (Object.prototype.hasOwnProperty.call(property, i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Logs an error in the console.\n *  Note: it does not generate a JavaScript error, so make sure to also generate an error if needed.\n * @param message\n */\nfunction logConsoleError(message) {\n  // needed to write it this way for jslint\n  var consoleType = typeof console;\n  if (consoleType !== "undefined" && console && console.error) {\n    console.error(message);\n  }\n}\n\n/*\n * apply wrapper\n *\n * @param {Array} parameterArray An array comprising either:\n *      [ \'methodName\', optional_parameters ]\n * or:\n *      [ functionObject, optional_parameters ]\n */\nfunction apply() {\n  var i, j, f, parameterArray, trackerCall;\n\n  for (i = 0; i < arguments.length; i += 1) {\n    trackerCall = null;\n    if (arguments[i] && arguments[i].slice) {\n      trackerCall = arguments[i].slice();\n    }\n    parameterArray = arguments[i];\n    f = parameterArray.shift();\n\n    var fParts, context;\n\n    var isStaticPluginCall = isString(f) && f.indexOf("::") > 0;\n    if (isStaticPluginCall) {\n      // a static method will not be called on a tracker and is not dependent on the existence of a\n      // tracker etc\n      fParts = f.split("::");\n      context = fParts[0];\n      f = fParts[1];\n\n      if (\n        "object" === typeof globalThis.eave.eave[context] &&\n        "function" === typeof globalThis.eave.eave[context][f]\n      ) {\n        globalThis.eave.eave[context][f].apply(\n          globalThis.eave.eave[context],\n          parameterArray,\n        );\n      } else if (trackerCall) {\n        // we try to call that method again later as the plugin might not be loaded yet\n        // a plugin can call "globalThis.eave.eave.retryMissedPluginCalls();" once it has been loaded and then the\n        // method call to "globalThis.eave.eave[context][f]" may be executed\n        globalThis.eave.missedPluginTrackerCalls.push(trackerCall);\n      }\n    } else {\n      for (j = 0; j < globalThis.eave.asyncTrackers.length; j++) {\n        if (isString(f)) {\n          context = globalThis.eave.asyncTrackers[j];\n\n          var isPluginTrackerCall = f.indexOf(".") > 0;\n\n          if (isPluginTrackerCall) {\n            fParts = f.split(".");\n            if (context && "object" === typeof context[fParts[0]]) {\n              context = context[fParts[0]];\n              f = fParts[1];\n            } else if (trackerCall) {\n              // we try to call that method again later as the plugin might not be loaded yet\n              globalThis.eave.missedPluginTrackerCalls.push(trackerCall);\n              break;\n            }\n          }\n\n          if (context[f]) {\n            context[f].apply(context, parameterArray);\n          } else {\n            var message =\n              "The method \'" +\n              f +\n              \'\\\' was not found in "_paq" variable.  Please have a look at the eave tracker documentation: https://developer.matomo.org/api-reference/tracking-javascript\';\n            logConsoleError(message);\n\n            if (!isPluginTrackerCall) {\n              // do not trigger an error if it is a call to a plugin as the plugin may just not be\n              // loaded yet etc\n              throw new TypeError(message);\n            }\n          }\n\n          if (f === "addTracker") {\n            // addTracker adds an entry to globalThis.eave.asyncTrackers and would otherwise result in an endless loop\n            break;\n          }\n\n          if (f === "setTrackerUrl" || f === "setSiteId") {\n            // these two methods should be only executed on the first tracker\n            break;\n          }\n        } else {\n          f.apply(globalThis.eave.asyncTrackers[j], parameterArray);\n        }\n      }\n    }\n  }\n}\n\n/*\n * Cross-browser helper function to add event handler\n */\nfunction addEventListener(element, eventType, eventHandler, useCapture) {\n  if (element.addEventListener) {\n    element.addEventListener(eventType, eventHandler, useCapture);\n\n    return true;\n  }\n\n  if (element.attachEvent) {\n    return element.attachEvent("on" + eventType, eventHandler);\n  }\n\n  element["on" + eventType] = eventHandler;\n}\n\nfunction trackCallbackOnLoad(callback) {\n  if (globalThis.eave.documentAlias.readyState === "complete") {\n    callback();\n  } else if (globalThis.eave.windowAlias.addEventListener) {\n    globalThis.eave.windowAlias.addEventListener("load", callback, false);\n  } else if (globalThis.eave.windowAlias.attachEvent) {\n    globalThis.eave.windowAlias.attachEvent("onload", callback);\n  }\n}\n\nfunction trackCallbackOnReady(callback) {\n  var loaded = false;\n\n  if (globalThis.eave.documentAlias.attachEvent) {\n    loaded = globalThis.eave.documentAlias.readyState === "complete";\n  } else {\n    loaded = globalThis.eave.documentAlias.readyState !== "loading";\n  }\n\n  if (loaded) {\n    callback();\n    return;\n  }\n\n  var _timer;\n\n  if (globalThis.eave.documentAlias.addEventListener) {\n    addEventListener(\n      globalThis.eave.documentAlias,\n      "DOMContentLoaded",\n      function ready() {\n        globalThis.eave.documentAlias.removeEventListener(\n          "DOMContentLoaded",\n          ready,\n          false,\n        );\n        if (!loaded) {\n          loaded = true;\n          callback();\n        }\n      },\n    );\n  } else if (globalThis.eave.documentAlias.attachEvent) {\n    globalThis.eave.documentAlias.attachEvent(\n      "onreadystatechange",\n      function ready() {\n        if (globalThis.eave.documentAlias.readyState === "complete") {\n          globalThis.eave.documentAlias.detachEvent(\n            "onreadystatechange",\n            ready,\n          );\n          if (!loaded) {\n            loaded = true;\n            callback();\n          }\n        }\n      },\n    );\n\n    if (\n      globalThis.eave.documentAlias.documentElement.doScroll &&\n      globalThis.eave.windowAlias === globalThis.eave.windowAlias.top\n    ) {\n      (function ready() {\n        if (!loaded) {\n          try {\n            globalThis.eave.documentAlias.documentElement.doScroll("left");\n          } catch (error) {\n            setTimeout(ready, 0);\n\n            return;\n          }\n          loaded = true;\n          callback();\n        }\n      })();\n    }\n  }\n\n  // fallback\n  addEventListener(\n    globalThis.eave.windowAlias,\n    "load",\n    function () {\n      if (!loaded) {\n        loaded = true;\n        callback();\n      }\n    },\n    false,\n  );\n}\n\n/*\n * Call plugin hook methods\n */\nfunction executePluginMethod(methodName, params, callback) {\n  if (!methodName) {\n    return "";\n  }\n\n  var result = "",\n    i,\n    pluginMethod,\n    value,\n    isFunction;\n\n  for (i in globalThis.eave.plugins) {\n    if (Object.prototype.hasOwnProperty.call(globalThis.eave.plugins, i)) {\n      isFunction =\n        globalThis.eave.plugins[i] &&\n        "function" === typeof globalThis.eave.plugins[i][methodName];\n\n      if (isFunction) {\n        pluginMethod = globalThis.eave.plugins[i][methodName];\n        value = pluginMethod(params || {}, callback);\n\n        if (value) {\n          result += value;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/*\n * Handle beforeunload event\n *\n * Subject to Safari\'s "Runaway JavaScript Timer" and\n * Chrome V8 extension that terminates JS that exhibits\n * "slow unload", i.e., calling getTime() > 1000 times\n */\nfunction beforeUnloadHandler(event) {\n  var now;\n  globalThis.eave.isPageUnloading = true;\n\n  executePluginMethod("unload");\n  now = new Date();\n  var aliasTime = now.getTimeAlias();\n  if (globalThis.eave.expireDateTime - aliasTime > 3000) {\n    globalThis.eave.expireDateTime = aliasTime + 3000;\n  }\n\n  /*\n   * Delay/pause (blocks UI)\n   */\n  if (globalThis.eave.expireDateTime) {\n    // the things we do for backwards compatibility...\n    // in ECMA-262 5th ed., we could simply use:\n    //     while (Date.now() < globalThis.eave.expireDateTime) { }\n    do {\n      now = new Date();\n    } while (now.getTimeAlias() < globalThis.eave.expireDateTime);\n  }\n}\n\n/*\n * Load JavaScript file (asynchronously)\n */\nfunction loadScript(src, onLoad) {\n  var script = globalThis.eave.documentAlias.createElement("script");\n\n  script.type = "text/javascript";\n  script.src = src;\n\n  if (script.readyState) {\n    script.onreadystatechange = function () {\n      var state = this.readyState;\n\n      if (state === "loaded" || state === "complete") {\n        script.onreadystatechange = null;\n        onLoad();\n      }\n    };\n  } else {\n    script.onload = onLoad;\n  }\n\n  globalThis.eave.documentAlias\n    .getElementsByTagName("head")[0]\n    .appendChild(script);\n}\n\n/*\n * Get page referrer\n */\nfunction getReferrer() {\n  var referrer = "";\n\n  try {\n    referrer = globalThis.eave.windowAlias.top.document.referrer;\n  } catch (e) {\n    if (globalThis.eave.windowAlias.parent) {\n      try {\n        referrer = globalThis.eave.windowAlias.parent.document.referrer;\n      } catch (e2) {\n        referrer = "";\n      }\n    }\n  }\n\n  if (referrer === "") {\n    referrer = globalThis.eave.documentAlias.referrer;\n  }\n\n  return referrer;\n}\n\n/*\n * Extract scheme/protocol from URL\n */\nfunction getProtocolScheme(url) {\n  var e = new RegExp("^([a-z]+):"),\n    matches = e.exec(url);\n\n  return matches ? matches[1] : null;\n}\n\n/*\n * Extract hostname from URL\n */\nfunction getHostName(url) {\n  // scheme : // [username [: password] @] hostame [: port] [/ [path] [? query] [# fragment]]\n  var e = new RegExp("^(?:(?:https?|ftp):)/*(?:[^@]+@)?([^:/#]+)"),\n    matches = e.exec(url);\n\n  return matches ? matches[1] : url;\n}\nfunction isPositiveNumberString(str) {\n  // !isNaN(str) could be used but does not cover \'03\' (octal) and \'0xA\' (hex)\n  // nor negative numbers\n  return /^[0-9][0-9]*(\\.[0-9]+)?$/.test(str);\n}\nfunction filterIn(object, byFunction) {\n  var result = {},\n    k;\n  for (k in object) {\n    if (object.hasOwnProperty(k) && byFunction(object[k])) {\n      result[k] = object[k];\n    }\n  }\n  return result;\n}\nfunction onlyPositiveIntegers(data) {\n  var result = {},\n    k;\n  for (k in data) {\n    if (data.hasOwnProperty(k)) {\n      if (isPositiveNumberString(data[k])) {\n        result[k] = Math.round(data[k]);\n      } else {\n        throw new Error(\n          \'Parameter "\' +\n            k +\n            \'" provided value "\' +\n            data[k] +\n            \'" is not valid. Please provide a numeric value.\',\n        );\n      }\n    }\n  }\n  return result;\n}\nfunction queryStringify(data) {\n  var queryString = "",\n    k;\n  for (k in data) {\n    if (data.hasOwnProperty(k)) {\n      queryString +=\n        "&" +\n        globalThis.eave.encodeWrapper(k) +\n        "=" +\n        globalThis.eave.encodeWrapper(data[k]);\n    }\n  }\n  return queryString;\n}\n\nfunction stringStartsWith(str, prefix) {\n  str = String(str);\n  return str.lastIndexOf(prefix, 0) === 0;\n}\n\nfunction stringEndsWith(str, suffix) {\n  str = String(str);\n  return str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\n\nfunction stringContains(str, needle) {\n  str = String(str);\n  return str.indexOf(needle) !== -1;\n}\n\nfunction removeCharactersFromEndOfString(str, numCharactersToRemove) {\n  str = String(str);\n  return str.substr(0, str.length - numCharactersToRemove);\n}\n\n/**\n * We do not check whether URL contains already url parameter, please use removeUrlParameter() if needed\n * before calling this method.\n * This method makes sure to append URL parameters before a possible hash. Will escape (encode URI component)\n * the set name and value\n */\nfunction addUrlParameter(url, name, value) {\n  url = String(url);\n\n  if (!value) {\n    value = "";\n  }\n\n  var hashPos = url.indexOf("#");\n  var urlLength = url.length;\n\n  if (hashPos === -1) {\n    hashPos = urlLength;\n  }\n\n  var baseUrl = url.substr(0, hashPos);\n  var urlHash = url.substr(hashPos, urlLength - hashPos);\n\n  if (baseUrl.indexOf("?") === -1) {\n    baseUrl += "?";\n  } else if (!stringEndsWith(baseUrl, "?")) {\n    baseUrl += "&";\n  }\n  // nothing to if ends with ?\n\n  return (\n    baseUrl +\n    globalThis.eave.encodeWrapper(name) +\n    "=" +\n    globalThis.eave.encodeWrapper(value) +\n    urlHash\n  );\n}\n\nfunction removeUrlParameter(url, name) {\n  url = String(url);\n\n  if (\n    url.indexOf("?" + name + "=") === -1 &&\n    url.indexOf("&" + name + "=") === -1\n  ) {\n    // nothing to remove, url does not contain this parameter\n    return url;\n  }\n\n  var searchPos = url.indexOf("?");\n  if (searchPos === -1) {\n    // nothing to remove, no query parameters\n    return url;\n  }\n\n  var queryString = url.substr(searchPos + 1);\n  var baseUrl = url.substr(0, searchPos);\n\n  if (queryString) {\n    var urlHash = "";\n    var hashPos = queryString.indexOf("#");\n    if (hashPos !== -1) {\n      urlHash = queryString.substr(hashPos + 1);\n      queryString = queryString.substr(0, hashPos);\n    }\n\n    var param;\n    var paramsArr = queryString.split("&");\n    var i = paramsArr.length - 1;\n\n    for (i; i >= 0; i--) {\n      param = paramsArr[i].split("=")[0];\n      if (param === name) {\n        paramsArr.splice(i, 1);\n      }\n    }\n\n    var newQueryString = paramsArr.join("&");\n\n    if (newQueryString) {\n      baseUrl = baseUrl + "?" + newQueryString;\n    }\n\n    if (urlHash) {\n      baseUrl += "#" + urlHash;\n    }\n  }\n\n  return baseUrl;\n}\n\n/*\n * Extract parameter from URL\n */\nfunction getUrlParameter(url, name) {\n  var regexSearch = "[\\\\?&#]" + name + "=([^&#]*)";\n  var regex = new RegExp(regexSearch);\n  var results = regex.exec(url);\n  return results ? safeDecodeWrapper(results[1]) : "";\n}\n\nfunction trim(text) {\n  if (text && String(text) === text) {\n    return text.replace(/^\\s+|\\s+$/g, "");\n  }\n\n  return text;\n}\n\n/*\n * UTF-8 encoding\n */\nfunction utf8_encode(argString) {\n  return unescape(globalThis.eave.encodeWrapper(argString));\n}\n\n/************************************************************\n * sha1\n * - based on sha1 from http://phpjs.org/functions/sha1:512 (MIT / GPL v2)\n ************************************************************/\n\nfunction sha1(str) {\n  // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n  // + namespaced by: Michael White (http://getsprink.com)\n  // +      input by: Brett Zamir (http://brett-zamir.me)\n  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // +   jslinted by: Anthon Pang (https://matomo.org)\n\n  var rotate_left = function (n, s) {\n      return (n << s) | (n >>> (32 - s));\n    },\n    cvt_hex = function (val) {\n      var strout = "",\n        i,\n        v;\n\n      for (i = 7; i >= 0; i--) {\n        v = (val >>> (i * 4)) & 0x0f;\n        strout += v.toString(16);\n      }\n\n      return strout;\n    },\n    blockstart,\n    i,\n    j,\n    W = [],\n    H0 = 0x67452301,\n    H1 = 0xefcdab89,\n    H2 = 0x98badcfe,\n    H3 = 0x10325476,\n    H4 = 0xc3d2e1f0,\n    A,\n    B,\n    C,\n    D,\n    E,\n    temp,\n    str_len,\n    word_array = [];\n\n  str = utf8_encode(str);\n  str_len = str.length;\n\n  for (i = 0; i < str_len - 3; i += 4) {\n    j =\n      (str.charCodeAt(i) << 24) |\n      (str.charCodeAt(i + 1) << 16) |\n      (str.charCodeAt(i + 2) << 8) |\n      str.charCodeAt(i + 3);\n    word_array.push(j);\n  }\n\n  switch (str_len & 3) {\n    case 0:\n      i = 0x080000000;\n      break;\n    case 1:\n      i = (str.charCodeAt(str_len - 1) << 24) | 0x0800000;\n      break;\n    case 2:\n      i =\n        (str.charCodeAt(str_len - 2) << 24) |\n        (str.charCodeAt(str_len - 1) << 16) |\n        0x08000;\n      break;\n    case 3:\n      i =\n        (str.charCodeAt(str_len - 3) << 24) |\n        (str.charCodeAt(str_len - 2) << 16) |\n        (str.charCodeAt(str_len - 1) << 8) |\n        0x80;\n      break;\n  }\n\n  word_array.push(i);\n\n  while ((word_array.length & 15) !== 14) {\n    word_array.push(0);\n  }\n\n  word_array.push(str_len >>> 29);\n  word_array.push((str_len << 3) & 0x0ffffffff);\n\n  for (blockstart = 0; blockstart < word_array.length; blockstart += 16) {\n    for (i = 0; i < 16; i++) {\n      W[i] = word_array[blockstart + i];\n    }\n\n    for (i = 16; i <= 79; i++) {\n      W[i] = rotate_left(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n    }\n\n    A = H0;\n    B = H1;\n    C = H2;\n    D = H3;\n    E = H4;\n\n    for (i = 0; i <= 19; i++) {\n      temp =\n        (rotate_left(A, 5) + ((B & C) | (~B & D)) + E + W[i] + 0x5a827999) &\n        0x0ffffffff;\n      E = D;\n      D = C;\n      C = rotate_left(B, 30);\n      B = A;\n      A = temp;\n    }\n\n    for (i = 20; i <= 39; i++) {\n      temp =\n        (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ed9eba1) & 0x0ffffffff;\n      E = D;\n      D = C;\n      C = rotate_left(B, 30);\n      B = A;\n      A = temp;\n    }\n\n    for (i = 40; i <= 59; i++) {\n      temp =\n        (rotate_left(A, 5) +\n          ((B & C) | (B & D) | (C & D)) +\n          E +\n          W[i] +\n          0x8f1bbcdc) &\n        0x0ffffffff;\n      E = D;\n      D = C;\n      C = rotate_left(B, 30);\n      B = A;\n      A = temp;\n    }\n\n    for (i = 60; i <= 79; i++) {\n      temp =\n        (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0xca62c1d6) & 0x0ffffffff;\n      E = D;\n      D = C;\n      C = rotate_left(B, 30);\n      B = A;\n      A = temp;\n    }\n\n    H0 = (H0 + A) & 0x0ffffffff;\n    H1 = (H1 + B) & 0x0ffffffff;\n    H2 = (H2 + C) & 0x0ffffffff;\n    H3 = (H3 + D) & 0x0ffffffff;\n    H4 = (H4 + E) & 0x0ffffffff;\n  }\n\n  temp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);\n\n  return temp.toLowerCase();\n}\n\n/************************************************************\n * end sha1\n ************************************************************/\n\n/*\n * Fix-up URL when page rendered from search engine cache or translated page\n */\nfunction urlFixup(hostName, href, referrer) {\n  if (!hostName) {\n    hostName = "";\n  }\n\n  if (!href) {\n    href = "";\n  }\n\n  if (hostName === "translate.googleusercontent.com") {\n    // Google\n    if (referrer === "") {\n      referrer = href;\n    }\n\n    href = getUrlParameter(href, "u");\n    hostName = getHostName(href);\n  } else if (\n    hostName === "cc.bingj.com" || // Bing\n    hostName === "webcache.googleusercontent.com" || // Google\n    hostName.slice(0, 5) === "74.6."\n  ) {\n    // Yahoo (via Inktomi 74.6.0.0/16)\n    href = globalThis.eave.documentAlias.links[0].href;\n    hostName = getHostName(href);\n  }\n\n  return [hostName, href, referrer];\n}\n\n/*\n * Fix-up domain\n */\nfunction domainFixup(domain) {\n  var dl = domain.length;\n\n  // remove trailing \'.\'\n  if (domain.charAt(--dl) === ".") {\n    domain = domain.slice(0, dl);\n  }\n\n  // remove leading \'*\'\n  if (domain.slice(0, 2) === "*.") {\n    domain = domain.slice(1);\n  }\n\n  if (domain.indexOf("/") !== -1) {\n    domain = domain.substr(0, domain.indexOf("/"));\n  }\n\n  return domain;\n}\n\n/*\n * Title fixup\n */\nfunction titleFixup(title) {\n  title = title && title.text ? title.text : title;\n\n  if (!isString(title)) {\n    var tmp = globalThis.eave.documentAlias.getElementsByTagName("title");\n\n    if (tmp && isDefined(tmp[0])) {\n      title = tmp[0].text;\n    }\n  }\n\n  return title;\n}\n\nfunction getChildrenFromNode(node) {\n  if (!node) {\n    return [];\n  }\n\n  if (!isDefined(node.children) && isDefined(node.childNodes)) {\n    return node.children;\n  }\n\n  if (isDefined(node.children)) {\n    return node.children;\n  }\n\n  return [];\n}\n\nfunction containsNodeElement(node, containedNode) {\n  if (!node || !containedNode) {\n    return false;\n  }\n\n  if (node.contains) {\n    return node.contains(containedNode);\n  }\n\n  if (node === containedNode) {\n    return true;\n  }\n\n  if (node.compareDocumentPosition) {\n    return !!(node.compareDocumentPosition(containedNode) & 16);\n  }\n\n  return false;\n}\n\n// Polyfill for IndexOf for IE6-IE8\nfunction indexOfArray(theArray, searchElement) {\n  if (theArray && theArray.indexOf) {\n    return theArray.indexOf(searchElement);\n  }\n\n  // 1. Let O be the result of calling ToObject passing\n  //    the this value as the argument.\n  if (!isDefined(theArray) || theArray === null) {\n    return -1;\n  }\n\n  if (!theArray.length) {\n    return -1;\n  }\n\n  var len = theArray.length;\n\n  if (len === 0) {\n    return -1;\n  }\n\n  var k = 0;\n\n  // 9. Repeat, while k < len\n  while (k < len) {\n    // a. Let Pk be ToString(k).\n    //   This is implicit for LHS operands of the in operator\n    // b. Let kPresent be the result of calling the\n    //    HasProperty internal method of O with argument Pk.\n    //   This step can be combined with c\n    // c. If kPresent is true, then\n    //    i.  Let elementK be the result of calling the Get\n    //        internal method of O with the argument ToString(k).\n    //   ii.  Let same be the result of applying the\n    //        Strict Equality Comparison Algorithm to\n    //        searchElement and elementK.\n    //  iii.  If same is true, return k.\n    if (theArray[k] === searchElement) {\n      return k;\n    }\n    k++;\n  }\n  return -1;\n}\n\nfunction uuidv4() {\n  if (isDefined(crypto) && isDefined(crypto.randomUUID)) {\n    return crypto.randomUUID();\n  }\n  // we are in an insecure env or this is an incompatible browser!\n  // fallback on some manual uuid jank\n  // https://stackoverflow.com/a/2117523/9718199\n  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) =>\n    (\n      +c ^\n      (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (+c / 4)))\n    ).toString(16),\n  );\n}\n\nfunction getCurrentTimestampInSeconds() {\n  return Math.floor(new Date().getTime() / 1000);\n}\n\nfunction sortObjectsByKeys(value) {\n  if (!value || !isObject(value)) {\n    return;\n  }\n\n  // Object.keys(value) is not supported by all browsers, we get the keys manually\n  var keys = [];\n  var key;\n\n  for (key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      keys.push(key);\n    }\n  }\n\n  var normalized = {};\n  keys.sort();\n  var len = keys.length;\n  var i;\n\n  for (i = 0; i < len; i++) {\n    normalized[keys[i]] = value[keys[i]];\n  }\n\n  return normalized;\n}\n\nfunction generateUniqueId() {\n  var id = "";\n  var chars = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";\n  var charLen = chars.length;\n  var i;\n\n  for (i = 0; i < 6; i++) {\n    id += chars.charAt(Math.floor(Math.random() * charLen));\n  }\n\n  return id;\n}\n\nfunction arrayChunk(theArray, chunkSize) {\n  if (!chunkSize || chunkSize >= theArray.length) {\n    return [theArray];\n  }\n\n  var index = 0;\n  var arrLength = theArray.length;\n  var chunks = [];\n\n  for (index; index < arrLength; index += chunkSize) {\n    chunks.push(theArray.slice(index, index + chunkSize));\n  }\n\n  return chunks;\n}\n\nfunction setExpireDateTime(delay) {\n  var now = new Date();\n  var time = now.getTime() + delay;\n\n  if (\n    !globalThis.eave.expireDateTime ||\n    time > globalThis.eave.expireDateTime\n  ) {\n    globalThis.eave.expireDateTime = time;\n  }\n}\n\nfunction isSameHost(hostName, alias) {\n  var offset;\n\n  hostName = String(hostName).toLowerCase();\n  alias = String(alias).toLowerCase();\n\n  if (hostName === alias) {\n    return true;\n  }\n\n  if (alias.slice(0, 1) === ".") {\n    if (hostName === alias.slice(1)) {\n      return true;\n    }\n\n    offset = hostName.length - alias.length;\n\n    if (offset > 0 && hostName.slice(offset) === alias) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isSitePath(path, pathAlias) {\n  if (!stringStartsWith(pathAlias, "/")) {\n    pathAlias = "/" + pathAlias;\n  }\n\n  if (!stringStartsWith(path, "/")) {\n    path = "/" + path;\n  }\n\n  var matchesAnyPath = pathAlias === "/" || pathAlias === "/*";\n\n  if (matchesAnyPath) {\n    return true;\n  }\n\n  if (path === pathAlias) {\n    return true;\n  }\n\n  pathAlias = String(pathAlias).toLowerCase();\n  path = String(path).toLowerCase();\n\n  // wildcard path support\n  if (stringEndsWith(pathAlias, "*")) {\n    // remove the final \'*\' before comparing\n    pathAlias = pathAlias.slice(0, -1);\n\n    // Note: this is almost duplicated from just few lines above\n    matchesAnyPath = !pathAlias || pathAlias === "/";\n\n    if (matchesAnyPath) {\n      return true;\n    }\n\n    if (path === pathAlias) {\n      return true;\n    }\n\n    // wildcard match\n    return path.indexOf(pathAlias) === 0;\n  }\n\n  // we need to append slashes so /foobarbaz won\'t match a site /foobar\n  if (!stringEndsWith(path, "/")) {\n    path += "/";\n  }\n\n  if (!stringEndsWith(pathAlias, "/")) {\n    pathAlias += "/";\n  }\n\n  return path.indexOf(pathAlias) === 0;\n}\n\n/**\n * Convert an object to a query params string\n *\n * @param {object} args\n * @returns {string} query params to attach to a request URL\n */\nfunction argsToQueryParameters(args) {\n  const makeURLSafe = isFunction(encodeURIComponent)\n    ? encodeURIComponent\n    : function (x) {\n        return x;\n      };\n  let qp = "";\n  let key;\n  for (key of Object.keys(args)) {\n    qp += "&" + makeURLSafe(key) + "=" + makeURLSafe(String(args[key]));\n  }\n  return qp;\n}\n\n\n//# sourceURL=webpack://eave-tracing-client/./src/helpers.mjs?')},"./src/query.mjs":
/*!***********************!*\
  !*** ./src/query.mjs ***!
  \***********************/(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ "./src/helpers.mjs");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  htmlCollectionToArray: function (foundNodes) {\n    var nodes = [],\n      index;\n\n    if (!foundNodes || !foundNodes.length) {\n      return nodes;\n    }\n\n    for (index = 0; index < foundNodes.length; index++) {\n      nodes.push(foundNodes[index]);\n    }\n\n    return nodes;\n  },\n  find: function (selector) {\n    // we use querySelectorAll only on document, not on nodes because of its unexpected behavior. See for\n    // instance http://stackoverflow.com/questions/11503534/jquery-vs-document-queryselectorall and\n    // http://jsfiddle.net/QdMc5/ and http://ejohn.org/blog/thoughts-on-queryselectorall\n    if (!document.querySelectorAll || !selector) {\n      return []; // we do not support all browsers\n    }\n\n    var foundNodes = document.querySelectorAll(selector);\n\n    return this.htmlCollectionToArray(foundNodes);\n  },\n  findMultiple: function (selectors) {\n    if (!selectors || !selectors.length) {\n      return [];\n    }\n\n    var index, foundNodes;\n    var nodes = [];\n    for (index = 0; index < selectors.length; index++) {\n      foundNodes = this.find(selectors[index]);\n      nodes = nodes.concat(foundNodes);\n    }\n\n    nodes = this.makeNodesUnique(nodes);\n\n    return nodes;\n  },\n  findNodesByTagName: function (node, tagName) {\n    if (!node || !tagName || !node.getElementsByTagName) {\n      return [];\n    }\n\n    var foundNodes = node.getElementsByTagName(tagName);\n\n    return this.htmlCollectionToArray(foundNodes);\n  },\n  makeNodesUnique: function (nodes) {\n    var copy = [].concat(nodes);\n    nodes.sort(function (n1, n2) {\n      if (n1 === n2) {\n        return 0;\n      }\n\n      var index1 = _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.indexOfArray(copy, n1);\n      var index2 = _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.indexOfArray(copy, n2);\n\n      if (index1 === index2) {\n        return 0;\n      }\n\n      return index1 > index2 ? -1 : 1;\n    });\n\n    if (nodes.length <= 1) {\n      return nodes;\n    }\n\n    var index = 0;\n    var numDuplicates = 0;\n    var duplicates = [];\n    var node;\n\n    node = nodes[index++];\n\n    while (node) {\n      if (node === nodes[index]) {\n        numDuplicates = duplicates.push(index);\n      }\n\n      node = nodes[index++] || null;\n    }\n\n    while (numDuplicates--) {\n      nodes.splice(duplicates[numDuplicates], 1);\n    }\n\n    return nodes;\n  },\n  getAttributeValueFromNode: function (node, attributeName) {\n    if (!this.hasNodeAttribute(node, attributeName)) {\n      return;\n    }\n\n    if (node && node.getAttribute) {\n      return node.getAttribute(attributeName);\n    }\n\n    if (!node || !node.attributes) {\n      return;\n    }\n\n    var typeOfAttr = typeof node.attributes[attributeName];\n    if ("undefined" === typeOfAttr) {\n      return;\n    }\n\n    if (node.attributes[attributeName].value) {\n      return node.attributes[attributeName].value; // nodeValue is deprecated ie Chrome\n    }\n\n    if (node.attributes[attributeName].nodeValue) {\n      return node.attributes[attributeName].nodeValue;\n    }\n\n    var index;\n    var attrs = node.attributes;\n\n    if (!attrs) {\n      return;\n    }\n\n    for (index = 0; index < attrs.length; index++) {\n      if (attrs[index].nodeName === attributeName) {\n        return attrs[index].nodeValue;\n      }\n    }\n\n    return null;\n  },\n  hasNodeAttributeWithValue: function (node, attributeName) {\n    var value = this.getAttributeValueFromNode(node, attributeName);\n\n    return !!value;\n  },\n  hasNodeAttribute: function (node, attributeName) {\n    if (node && node.hasAttribute) {\n      return node.hasAttribute(attributeName);\n    }\n\n    if (node && node.attributes) {\n      var typeOfAttr = typeof node.attributes[attributeName];\n      return "undefined" !== typeOfAttr;\n    }\n\n    return false;\n  },\n  hasNodeCssClass: function (node, klassName) {\n    if (node && klassName && node.className) {\n      var classes =\n        typeof node.className === "string" ? node.className.split(" ") : [];\n      if (-1 !== _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.indexOfArray(classes, klassName)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  findNodesHavingAttribute: function (nodeToSearch, attributeName, nodes) {\n    if (!nodes) {\n      nodes = [];\n    }\n\n    if (!nodeToSearch || !attributeName) {\n      return nodes;\n    }\n\n    var children = _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getChildrenFromNode(nodeToSearch);\n\n    if (!children || !children.length) {\n      return nodes;\n    }\n\n    var index, child;\n    for (index = 0; index < children.length; index++) {\n      child = children[index];\n      if (this.hasNodeAttribute(child, attributeName)) {\n        nodes.push(child);\n      }\n\n      nodes = this.findNodesHavingAttribute(child, attributeName, nodes);\n    }\n\n    return nodes;\n  },\n  findFirstNodeHavingAttribute: function (node, attributeName) {\n    if (!node || !attributeName) {\n      return;\n    }\n\n    if (this.hasNodeAttribute(node, attributeName)) {\n      return node;\n    }\n\n    var nodes = this.findNodesHavingAttribute(node, attributeName);\n\n    if (nodes && nodes.length) {\n      return nodes[0];\n    }\n  },\n  findFirstNodeHavingAttributeWithValue: function (node, attributeName) {\n    if (!node || !attributeName) {\n      return;\n    }\n\n    if (this.hasNodeAttributeWithValue(node, attributeName)) {\n      return node;\n    }\n\n    var nodes = this.findNodesHavingAttribute(node, attributeName);\n\n    if (!nodes || !nodes.length) {\n      return;\n    }\n\n    var index;\n    for (index = 0; index < nodes.length; index++) {\n      if (this.getAttributeValueFromNode(nodes[index], attributeName)) {\n        return nodes[index];\n      }\n    }\n  },\n  findNodesHavingCssClass: function (nodeToSearch, className, nodes) {\n    if (!nodes) {\n      nodes = [];\n    }\n\n    if (!nodeToSearch || !className) {\n      return nodes;\n    }\n\n    if (nodeToSearch.getElementsByClassName) {\n      var foundNodes = nodeToSearch.getElementsByClassName(className);\n      return this.htmlCollectionToArray(foundNodes);\n    }\n\n    var children = _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getChildrenFromNode(nodeToSearch);\n\n    if (!children || !children.length) {\n      return [];\n    }\n\n    var index, child;\n    for (index = 0; index < children.length; index++) {\n      child = children[index];\n      if (this.hasNodeCssClass(child, className)) {\n        nodes.push(child);\n      }\n\n      nodes = this.findNodesHavingCssClass(child, className, nodes);\n    }\n\n    return nodes;\n  },\n  findFirstNodeHavingClass: function (node, className) {\n    if (!node || !className) {\n      return;\n    }\n\n    if (this.hasNodeCssClass(node, className)) {\n      return node;\n    }\n\n    var nodes = this.findNodesHavingCssClass(node, className);\n\n    if (nodes && nodes.length) {\n      return nodes[0];\n    }\n  },\n  isLinkElement: function (node) {\n    if (!node) {\n      return false;\n    }\n\n    var elementName = String(node.nodeName).toLowerCase();\n    var linkElementNames = ["a", "area"];\n    var pos = _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.indexOfArray(linkElementNames, elementName);\n\n    return pos !== -1;\n  },\n  setAnyAttribute: function (node, attrName, attrValue) {\n    if (!node || !attrName) {\n      return;\n    }\n\n    if (node.setAttribute) {\n      node.setAttribute(attrName, attrValue);\n    } else {\n      node[attrName] = attrValue;\n    }\n  },\n});\n\n\n//# sourceURL=webpack://eave-tracing-client/./src/query.mjs?')},"./src/tracker.mjs":
/*!*************************!*\
  !*** ./src/tracker.mjs ***!
  \*************************/(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tracker: () => (/* binding */ Tracker)\n/* harmony export */ });\n/* harmony import */ var _content_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./content.mjs */ "./src/content.mjs");\n/* harmony import */ var _cookies_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cookies.mjs */ "./src/cookies.mjs");\n/* harmony import */ var _globals_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./globals.mjs */ "./src/globals.mjs");\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers.mjs */ "./src/helpers.mjs");\n/* harmony import */ var _query_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./query.mjs */ "./src/query.mjs");\n/* harmony import */ var _visibility_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./visibility.mjs */ "./src/visibility.mjs");\n\n\n\n\n\n\n\n/*\n * eave Tracker class\n *\n * trackerUrl and trackerSiteId are optional arguments to the constructor\n *\n * See: Tracker.setTrackerUrl() and Tracker.setSiteId()\n */\nfunction Tracker(trackerUrl, siteId) {\n  /************************************************************\n   * Private members\n   ************************************************************/\n\n  var /*<DEBUG>*/\n    /*\n     * registered test hooks\n     */\n    registeredHooks = {},\n    /*</DEBUG>*/\n\n    // constants\n    CONTEXT_COOKIE_NAME = "eave.context",\n    trackerInstance = this,\n    // in-memory context to be attached to all atoms. Use getContext()/setContext() to access!\n    _eaveContext = {}, // TODO: set on all fired atom events\n    // Current URL and Referrer URL\n    locationArray = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.urlFixup(\n      globalThis.eave.documentAlias.domain,\n      globalThis.eave.windowAlias.location.href,\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getReferrer(),\n    ),\n    domainAlias = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.domainFixup(locationArray[0]),\n    locationHrefAlias = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.safeDecodeWrapper(locationArray[1]),\n    configReferrerUrl = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.safeDecodeWrapper(locationArray[2]),\n    enableJSErrorTracking = false,\n    defaultRequestMethod = "GET",\n    // Request method (GET or POST)\n    configRequestMethod = defaultRequestMethod,\n    defaultRequestContentType =\n      "application/x-www-form-urlencoded; charset=UTF-8",\n    // Request Content-Type header value; applicable when POST request method is used for submitting tracking events\n    configRequestContentType = defaultRequestContentType,\n    // Tracker URL\n    configTrackerUrl = trackerUrl || "",\n    // API URL (only set if it differs from the Tracker URL)\n    configApiUrl = "",\n    // This string is appended to the Tracker URL Request (eg. to send data that is not handled by the existing setters/getters)\n    configAppendToTrackingUrl = "",\n    // setPagePerformanceTiming sets this manually for SPAs\n    customPagePerformanceTiming = "",\n    // Site ID\n    configTrackerSiteId = siteId || "",\n    // User ID\n    configUserId = "",\n    // Document URL\n    configCustomUrl,\n    // Document title\n    configTitle = "",\n    // Extensions to be treated as download links\n    configDownloadExtensions = [\n      "7z",\n      "aac",\n      "apk",\n      "arc",\n      "arj",\n      "asc",\n      "asf",\n      "asx",\n      "avi",\n      "azw3",\n      "bin",\n      "csv",\n      "deb",\n      "dmg",\n      "doc",\n      "docx",\n      "epub",\n      "exe",\n      "flv",\n      "gif",\n      "gz",\n      "gzip",\n      "hqx",\n      "ibooks",\n      "jar",\n      "jpg",\n      "jpeg",\n      "js",\n      "md5",\n      "mobi",\n      "mp2",\n      "mp3",\n      "mp4",\n      "mpg",\n      "mpeg",\n      "mov",\n      "movie",\n      "msi",\n      "msp",\n      "odb",\n      "odf",\n      "odg",\n      "ods",\n      "odt",\n      "ogg",\n      "ogv",\n      "pdf",\n      "phps",\n      "png",\n      "ppt",\n      "pptx",\n      "qt",\n      "qtm",\n      "ra",\n      "ram",\n      "rar",\n      "rpm",\n      "rtf",\n      "sea",\n      "sha",\n      "sha256",\n      "sha512",\n      "sig",\n      "sit",\n      "tar",\n      "tbz",\n      "tbz2",\n      "bz",\n      "bz2",\n      "tgz",\n      "torrent",\n      "txt",\n      "wav",\n      "wma",\n      "wmv",\n      "wpd",\n      "xls",\n      "xlsx",\n      "xml",\n      "xz",\n      "z",\n      "zip",\n    ],\n    // Hosts or alias(es) to not treat as outlinks\n    configHostsAlias = [domainAlias],\n    // HTML anchor element classes to not track\n    configIgnoreClasses = [],\n    // Referrer URLs that should be excluded\n    configExcludedReferrers = [".paypal.com"],\n    // Query parameters to be excluded\n    configExcludedQueryParams = [],\n    // HTML anchor element classes to treat as downloads\n    configDownloadClasses = [],\n    // HTML anchor element classes to treat at outlinks\n    configLinkClasses = [],\n    // Maximum delay to wait for web bug image to be fetched (in milliseconds)\n    configTrackerPause = 500,\n    // If enabled, always use sendBeacon if the browser supports it\n    configAlwaysUseSendBeacon = true,\n    // Minimum visit time after initial page view (in milliseconds)\n    configMinimumVisitTime,\n    // Recurring heart beat after initial ping (in milliseconds)\n    configHeartBeatDelay,\n    // alias to circumvent circular function dependency (JSLint requires this)\n    heartBeatPingIfActivityAlias,\n    // Disallow hash tags in URL\n    configDiscardHashTag,\n    // Custom data\n    configCustomData,\n    // Campaign names\n    configCampaignNameParameters = [\n      "eave_campaign",\n      "utm_campaign",\n      "utm_source",\n      "utm_medium",\n    ],\n    // Campaign keywords\n    configCampaignKeywordParameters = ["eave_kwd", "utm_term"],\n    // the URL parameter that will store the visitorId if cross domain linking is enabled\n    // ev_vid = visitor ID\n    // first part of this URL parameter will be 16 char visitor Id.\n    // The second part is the 10 char current timestamp and the third and last part will be a 6 characters deviceId\n    // timestamp is needed to prevent reusing the visitorId when the URL is shared. The visitorId will be\n    // only reused if the timestamp is less than 45 seconds old.\n    // deviceId parameter is needed to prevent reusing the visitorId when the URL is shared. The visitorId\n    // will be only reused if the device is still the same when opening the link.\n    // VDI = visitor device identifier\n    configVisitorIdUrlParameter = "ev_vid",\n    configVisitorIdKey = "visitor_id",\n    // Cross domain linking, the visitor ID is transmitted only in the 180 seconds following the click.\n    configVisitorIdUrlParameterTimeoutInSeconds = 180,\n    // Is performance tracking enabled\n    configPerformanceTrackingEnabled = true,\n    // will be set to true automatically once the onload event has finished\n    performanceAvailable = false,\n    // indicates if performance metrics for the page view have been sent with a request\n    performanceTracked = false,\n    // Whether Custom Variables scope "visit" should be stored in a cookie during the time of the visit\n    configStoreCustomVariablesInCookie = false,\n    // Custom Variables read from cookie, scope "visit"\n    customVariables = false,\n    configCustomRequestContentProcessing,\n    // Do Not Track\n    configDoNotTrack,\n    // Count sites which are pre-rendered\n    configCountPreRendered,\n    // Enable sending campaign parameters to backend.\n    configEnableCampaignParameters = true,\n    // Do we attribute the conversion to the first referrer or the most recent referrer?\n    configConversionAttributionFirstReferrer,\n    // Custom Variables, scope "page"\n    customVariablesPage = {},\n    // Custom Variables, scope "event"\n    customVariablesEvent = {},\n    // Custom Dimensions (can be any scope)\n    customDimensions = {},\n    // Custom Variables names and values are each truncated before being sent in the request or recorded in the cookie\n    customVariableMaximumLength = 200,\n    // Ecommerce product view\n    ecommerceProductView = {},\n    // Ecommerce items\n    ecommerceItems = {},\n    // Browser features via client-side data collection\n    browserFeatures = {},\n    // Browser client hints\n    clientHints = {},\n    clientHintsRequestQueue = [],\n    clientHintsResolved = false,\n    clientHintsResolving = false,\n    // Keeps track of previously tracked content impressions\n    trackedContentImpressions = [],\n    isTrackOnlyVisibleContentEnabled = false,\n    // Guard to prevent empty visits see #6415. If there is a new visitor and the first 2 (or 3 or 4)\n    // tracking requests are at nearly same time (eg trackPageView and trackContentImpression) 2 or more\n    // visits will be created\n    timeNextTrackingRequestCanBeExecutedImmediately = false,\n    // Guard against installing the link tracker more than once per Tracker instance\n    clickListenerInstalled = false,\n    linkTrackingEnabled = false,\n    crossDomainTrackingEnabled = false,\n    // Guard against installing route history tracker more than once per instance\n    routeHistoryTrackingEnabled = false,\n    // Guard against installing button click tracker more than once per instance\n    buttonClickTrackingEnabled = false,\n    // Guard against installing the activity tracker more than once per Tracker instance\n    heartBeatSetUp = false,\n    hadWindowFocusAtLeastOnce = false,\n    timeWindowLastFocused = null,\n    // Timestamp of last tracker request sent to eave\n    lastTrackerRequestTime = null,\n    // Internal state of the pseudo click handler\n    lastButton,\n    lastTarget,\n    configIdPageView,\n    // Boolean indicating that a page view ID has been set manually\n    configIdPageViewSetManually = false,\n    // we measure how many pageviews have been tracked so plugins can use it to eg detect if a\n    // pageview was already tracked or not\n    numTrackedPageviews = 0,\n    // whether requireConsent() was called or not\n    configConsentRequired = false,\n    // we always have the concept of consent. by default consent is assumed unless the end user removes it,\n    // or unless a eave user explicitly requires consent (via requireConsent())\n    configHasConsent = null, // initialized below\n    // holds all pending tracking requests that have not been tracked because we need consent\n    consentRequestsQueue = [],\n    // holds the actual javascript errors if enableJSErrorTracking is on, if the very same error is\n    // happening multiple times, then it will be tracked only once within the same page view\n    javaScriptErrors = [],\n    // a unique ID for this tracker during this request\n    uniqueTrackerId = globalThis.eave.trackerIdCounter++,\n    // whether a tracking request has been sent yet during this page view\n    hasSentTrackingRequestYet = false,\n    configBrowserFeatureDetection = true,\n    cookieManager = new _cookies_mjs__WEBPACK_IMPORTED_MODULE_1__.CookieManager(),\n    configFileTracking = false;\n\n  // Document title\n  try {\n    configTitle = globalThis.eave.documentAlias.title;\n  } catch (e) {\n    configTitle = "";\n  }\n\n  configHasConsent = !cookieManager.getCookie(\n    cookieManager.CONSENT_REMOVED_COOKIE_NAME,\n  );\n\n  /*\n   * Extract pathname from URL. element.pathname is actually supported by pretty much all browsers including\n   * IE6 apart from some rare very old ones\n   */\n  function getPathName(url) {\n    var parser = document.createElement("a");\n    if (url.indexOf("//") !== 0 && url.indexOf("http") !== 0) {\n      if (url.indexOf("*") === 0) {\n        url = url.substr(1);\n      }\n      if (url.indexOf(".") === 0) {\n        url = url.substr(1);\n      }\n      url = "http://" + url;\n    }\n\n    parser.href = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].toAbsoluteUrl(url);\n\n    if (parser.pathname) {\n      return parser.pathname;\n    }\n\n    return "";\n  }\n\n  /**\n   * Get a value from the in-memory _eaveContext object\n   *\n   * @param {string} key to fetch a value for\n   * @returns {any} value associated w/ `key` or undefined\n   */\n  function getContext(key) {\n    return _eaveContext[key];\n  }\n\n  /**\n   * Set `value` in the in-memory _eaveContext and save to cookie.\n   *\n   * @param {string} key\n   * @param {any} value\n   */\n  function setContext(key, value) {\n    // set into in-mem ctx\n    _eaveContext[key] = value;\n\n    // save new ctx value to cookie\n    saveContext();\n  }\n\n  function saveContext() {\n    cookieManager.setCookie(\n      CONTEXT_COOKIE_NAME,\n      globalThis.eave.windowAlias.JSON.stringify(_eaveContext),\n      cookieManager.configVisitorCookieTimeout,\n      cookieManager.configCookiePath,\n      cookieManager.configCookieDomain,\n      true, // required true for "None" sameSite\n      "None", // ensure this cookie is attached to our atom event requests\n    );\n  }\n\n  /**\n   * Whether the specified referrer url matches one of the configured excluded referrers.\n   *\n   * @param {string} referrerUrl\n   * @returns {boolean}\n   */\n  function isReferrerExcluded(referrerUrl) {\n    var i, host, path, aliasHost, aliasPath;\n\n    if (!referrerUrl.length || !configExcludedReferrers.length) {\n      return false;\n    }\n\n    host = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getHostName(referrerUrl);\n    path = getPathName(referrerUrl);\n\n    // ignore www subdomain\n    if (host.indexOf("www.") === 0) {\n      host = host.substr(4);\n    }\n\n    for (i = 0; i < configExcludedReferrers.length; i++) {\n      aliasHost = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.domainFixup(configExcludedReferrers[i]);\n      aliasPath = getPathName(configExcludedReferrers[i]);\n\n      // ignore www subdomain\n      if (aliasHost.indexOf("www.") === 0) {\n        aliasHost = aliasHost.substr(4);\n      }\n\n      if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isSameHost(host, aliasHost) && _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isSitePath(path, aliasPath)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /*\n   * Checks if the special query parameter was included in the current URL indicating this\n   * is supposed to be a tracking code install test.\n   */\n  function wasJsTrackingCodeInstallCheckParamProvided() {\n    if (\n      globalThis.eave.trackerInstallCheckNonce &&\n      globalThis.eave.trackerInstallCheckNonce.length > 0\n    ) {\n      return true;\n    }\n\n    globalThis.eave.trackerInstallCheckNonce = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getUrlParameter(\n      globalThis.eave.windowAlias.location.href,\n      "tracker_install_check",\n    );\n\n    return (\n      globalThis.eave.trackerInstallCheckNonce &&\n      globalThis.eave.trackerInstallCheckNonce.length > 0\n    );\n  }\n\n  /**\n   * If the query parameter was included in the current URL indicating it\'s an install check, close the window\n   */\n  function closeWindowIfJsTrackingCodeInstallCheck() {\n    // If the query parameter indicating this is a test exists\n    if (\n      wasJsTrackingCodeInstallCheckParamProvided() &&\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isObject(globalThis.eave.windowAlias)\n    ) {\n      globalThis.eave.windowAlias.close();\n    }\n  }\n\n  /*\n   * Send image request to eave server using GET.\n   * The infamous web bug (or beacon) is a transparent, single pixel (1x1) image\n   */\n  function getImage(request, callback) {\n    // make sure to actually load an image so callback gets invoked\n    request = request.replace("send_image=0", "send_image=1");\n\n    var image = new Image(1, 1);\n    image.onload = function () {\n      if (typeof callback === "function") {\n        callback({\n          request: request,\n          trackerUrl: configTrackerUrl,\n          success: true,\n        });\n      }\n    };\n    image.onerror = function () {\n      if (typeof callback === "function") {\n        callback({\n          request: request,\n          trackerUrl: configTrackerUrl,\n          success: false,\n        });\n      }\n    };\n    image.src =\n      configTrackerUrl +\n      (configTrackerUrl.indexOf("?") < 0 ? "?" : "&") +\n      request;\n\n    // If the query parameter indicating this is a test exists, close after first request is sent\n    closeWindowIfJsTrackingCodeInstallCheck();\n  }\n\n  function shouldForcePost(request) {\n    if (configRequestMethod === "POST") {\n      return true;\n    }\n    // we force long single request urls and bulk requests over post\n    return (\n      request && (request.length > 2000 || request.indexOf(\'{"requests"\') === 0)\n    );\n  }\n\n  function supportsSendBeacon() {\n    return (\n      "object" === typeof globalThis.eave.navigatorAlias &&\n      "function" === typeof globalThis.eave.navigatorAlias.sendBeacon &&\n      "function" === typeof Blob\n    );\n  }\n\n  function sendPostRequestViaSendBeacon(request, callback, fallbackToGet) {\n    var isSupported = supportsSendBeacon();\n\n    if (!isSupported) {\n      return false;\n    }\n\n    var headers = {\n      type: "application/x-www-form-urlencoded; charset=UTF-8",\n    };\n    var success = false;\n\n    var url = configTrackerUrl;\n\n    try {\n      var blob = new Blob([request], headers);\n\n      if (fallbackToGet && !shouldForcePost(request)) {\n        blob = new Blob([], headers);\n        url = url + (url.indexOf("?") < 0 ? "?" : "&") + request;\n      }\n\n      success = globalThis.eave.navigatorAlias.sendBeacon(url, blob);\n      // returns true if the user agent is able to successfully queue the data for transfer,\n      // Otherwise it returns false and we need to try the regular way\n    } catch (e) {\n      return false;\n    }\n\n    if (success && typeof callback === "function") {\n      callback({\n        request: request,\n        trackerUrl: configTrackerUrl,\n        success: true,\n        isSendBeacon: true,\n      });\n    }\n\n    // If the query parameter indicating this is a test exists, close after first request is sent\n    closeWindowIfJsTrackingCodeInstallCheck();\n\n    return success;\n  }\n\n  /*\n   * POST request to eave server using XMLHttpRequest.\n   */\n  function sendXmlHttpRequest(request, callback, fallbackToGet) {\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(fallbackToGet) || null === fallbackToGet) {\n      fallbackToGet = true;\n    }\n\n    if (\n      globalThis.eave.isPageUnloading &&\n      sendPostRequestViaSendBeacon(request, callback, fallbackToGet)\n    ) {\n      return;\n    }\n\n    setTimeout(function () {\n      // we execute it with a little delay in case the unload event occurred just after sending this request\n      // this is to avoid the following behaviour: Eg on form submit a tracking request is sent via POST\n      // in this method. Then a few ms later the browser wants to navigate to the new page and the unload\n      // event occurs and the browser cancels the just triggered POST request. This causes or fallback\n      // method to be triggered and we execute the same request again (either as fallbackGet or sendBeacon).\n      // The problem is that we do not know whether the initial POST request was already fully transferred\n      // to the server or not when the onreadystatechange callback is executed and we might execute the\n      // same request a second time. To avoid this, we delay the actual execution of this POST request just\n      // by 50ms which gives it usually enough time to detect the unload event in most cases.\n\n      if (\n        globalThis.eave.isPageUnloading &&\n        sendPostRequestViaSendBeacon(request, callback, fallbackToGet)\n      ) {\n        return;\n      }\n      var sentViaBeacon;\n\n      try {\n        // we use the progid Microsoft.XMLHTTP because\n        // IE5.5 included MSXML 2.5; the progid MSXML2.XMLHTTP\n        // is pinned to MSXML2.XMLHTTP.3.0\n        var xhr = globalThis.eave.windowAlias.XMLHttpRequest\n          ? new globalThis.eave.windowAlias.XMLHttpRequest()\n          : globalThis.eave.windowAlias.ActiveXObject\n          ? new globalThis.eave.windowAlias.ActiveXObject("Microsoft.XMLHTTP")\n          : null;\n\n        xhr.open("POST", configTrackerUrl, true);\n\n        // fallback on error\n        xhr.onreadystatechange = function () {\n          if (\n            this.readyState === 4 &&\n            !(this.status >= 200 && this.status < 300)\n          ) {\n            var sentViaBeacon =\n              globalThis.eave.isPageUnloading &&\n              sendPostRequestViaSendBeacon(request, callback, fallbackToGet);\n\n            if (!sentViaBeacon && fallbackToGet) {\n              getImage(request, callback);\n            } else if (typeof callback === "function") {\n              callback({\n                request: request,\n                trackerUrl: configTrackerUrl,\n                success: false,\n                xhr: this,\n              });\n            }\n          } else {\n            if (this.readyState === 4 && typeof callback === "function") {\n              callback({\n                request: request,\n                trackerUrl: configTrackerUrl,\n                success: true,\n                xhr: this,\n              });\n            }\n          }\n        };\n\n        xhr.setRequestHeader("Content-Type", configRequestContentType);\n\n        xhr.withCredentials = true;\n\n        xhr.send(request);\n      } catch (e) {\n        sentViaBeacon =\n          globalThis.eave.isPageUnloading &&\n          sendPostRequestViaSendBeacon(request, callback, fallbackToGet);\n        if (!sentViaBeacon && fallbackToGet) {\n          getImage(request, callback);\n        } else if (typeof callback === "function") {\n          callback({\n            request: request,\n            trackerUrl: configTrackerUrl,\n            success: false,\n          });\n        }\n      }\n\n      // If the query parameter indicating this is a test exists, close after first request is sent\n      closeWindowIfJsTrackingCodeInstallCheck();\n    }, 50);\n  }\n\n  function setExpireDateTime(delay) {\n    var now = new Date();\n    var time = now.getTime() + delay;\n\n    if (\n      !globalThis.eave.expireDateTime ||\n      time > globalThis.eave.expireDateTime\n    ) {\n      globalThis.eave.expireDateTime = time;\n    }\n  }\n\n  function heartBeatOnFocus() {\n    hadWindowFocusAtLeastOnce = true;\n    timeWindowLastFocused = new Date().getTime();\n  }\n\n  function hadWindowMinimalFocusToConsiderViewed() {\n    // we ping on blur or unload only if user was active for more than configHeartBeatDelay seconds on\n    // the page otherwise we can assume user was not really on the page and for example only switching\n    // through tabs\n    var now = new Date().getTime();\n    return (\n      !timeWindowLastFocused ||\n      now - timeWindowLastFocused > configHeartBeatDelay\n    );\n  }\n\n  function heartBeatOnBlur() {\n    if (hadWindowMinimalFocusToConsiderViewed()) {\n      heartBeatPingIfActivityAlias();\n    }\n  }\n\n  function heartBeatOnVisible() {\n    if (\n      globalThis.eave.documentAlias.visibilityState === "hidden" &&\n      hadWindowMinimalFocusToConsiderViewed()\n    ) {\n      heartBeatPingIfActivityAlias();\n    } else if (globalThis.eave.documentAlias.visibilityState === "visible") {\n      timeWindowLastFocused = new Date().getTime();\n    }\n  }\n\n  /*\n   * Setup event handlers and timeout for initial heart beat.\n   */\n  function setUpHeartBeat() {\n    if (heartBeatSetUp || !configHeartBeatDelay) {\n      return;\n    }\n\n    heartBeatSetUp = true;\n\n    _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addEventListener(globalThis.eave.windowAlias, "focus", heartBeatOnFocus);\n    _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addEventListener(globalThis.eave.windowAlias, "blur", heartBeatOnBlur);\n    _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addEventListener(\n      globalThis.eave.windowAlias,\n      "visibilitychange",\n      heartBeatOnVisible,\n    );\n\n    // when using multiple trackers then we need to add this event for each tracker\n    globalThis.eave.coreHeartBeatCounter++;\n    globalThis.eave.eave.addPlugin(\n      "HeartBeat" + globalThis.eave.coreHeartBeatCounter,\n      {\n        unload: function () {\n          // we can\'t remove the unload plugin event when disabling heart beat timer but we at least\n          // check if it is still enabled... note: when enabling heart beat, then disabling, then\n          // enabling then this could trigger two requests under circumstances maybe. it\'s edge case though\n\n          // we only send the heartbeat if onunload the user spent at least 15seconds since last focus\n          // or the configured heatbeat timer\n          if (heartBeatSetUp && hadWindowMinimalFocusToConsiderViewed()) {\n            heartBeatPingIfActivityAlias();\n          }\n        },\n      },\n    );\n  }\n\n  function makeSureThereIsAGapAfterFirstTrackingRequestToPreventMultipleVisitorCreation(\n    callback,\n  ) {\n    var now = new Date();\n    var timeNow = now.getTime();\n\n    lastTrackerRequestTime = timeNow;\n\n    if (\n      timeNextTrackingRequestCanBeExecutedImmediately &&\n      timeNow < timeNextTrackingRequestCanBeExecutedImmediately\n    ) {\n      // we are in the time frame shortly after the first request. we have to delay this request a bit to make sure\n      // a visitor has been created meanwhile.\n\n      var timeToWait =\n        timeNextTrackingRequestCanBeExecutedImmediately - timeNow;\n\n      setTimeout(callback, timeToWait);\n      setExpireDateTime(timeToWait + 50); // set timeout is not necessarily executed at timeToWait so delay a bit more\n      timeNextTrackingRequestCanBeExecutedImmediately += 50; // delay next tracking request by further 50ms to next execute them at same time\n\n      return;\n    }\n\n    if (timeNextTrackingRequestCanBeExecutedImmediately === false) {\n      // it is the first request, we want to execute this one directly and delay all the next one(s) within a delay.\n      // All requests after this delay can be executed as usual again\n      var delayInMs = 800;\n      timeNextTrackingRequestCanBeExecutedImmediately = timeNow + delayInMs;\n    }\n\n    callback();\n  }\n\n  function processClientHintsQueue() {\n    var i, requestType;\n\n    for (i = 0; i < clientHintsRequestQueue.length; i++) {\n      requestType = typeof clientHintsRequestQueue[i][0];\n      if (requestType === "string") {\n        sendRequest(\n          clientHintsRequestQueue[i][0],\n          configTrackerPause,\n          clientHintsRequestQueue[i][1],\n        );\n      } else if (requestType === "object") {\n        sendBulkRequest(clientHintsRequestQueue[i][0], configTrackerPause);\n      }\n    }\n    clientHintsRequestQueue = [];\n  }\n\n  /*\n   * Browser features (plugins, resolution, cookies)\n   */\n  function detectBrowserFeatures() {\n    // Browser Feature is disabled return empty object\n    if (!configBrowserFeatureDetection) {\n      return {};\n    }\n\n    if (supportsClientHints()) {\n      detectClientHints(processClientHintsQueue);\n    }\n\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(browserFeatures.res)) {\n      return browserFeatures;\n    }\n    var i,\n      mimeType,\n      pluginMap = {\n        // document types\n        pdf: "application/pdf",\n\n        // media players\n        qt: "video/quicktime",\n        realp: "audio/x-pn-realaudio-plugin",\n        wma: "application/x-mplayer2",\n\n        // interactive multimedia\n        fla: "application/x-shockwave-flash",\n\n        // RIA\n        java: "application/x-java-vm",\n        ag: "application/x-silverlight",\n      };\n\n    // detect browser features except IE < 11 (IE 11 user agent is no longer MSIE)\n    if (!new RegExp("MSIE").test(globalThis.eave.navigatorAlias.userAgent)) {\n      // general plugin detection\n      if (\n        globalThis.eave.navigatorAlias.mimeTypes &&\n        globalThis.eave.navigatorAlias.mimeTypes.length\n      ) {\n        for (i in pluginMap) {\n          if (Object.prototype.hasOwnProperty.call(pluginMap, i)) {\n            mimeType = globalThis.eave.navigatorAlias.mimeTypes[pluginMap[i]];\n            browserFeatures[i] = mimeType && mimeType.enabledPlugin ? "1" : "0";\n          }\n        }\n      }\n\n      // Safari and Opera\n      // IE6/IE7 navigator.javaEnabled can\'t be aliased, so test directly\n      // on Edge navigator.javaEnabled() always returns `true`, so ignore it\n      if (\n        !new RegExp("Edge[ /](\\\\d+[\\\\.\\\\d]+)").test(\n          globalThis.eave.navigatorAlias.userAgent,\n        ) &&\n        typeof navigator.javaEnabled !== "undefined" &&\n        _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(globalThis.eave.navigatorAlias.javaEnabled) &&\n        globalThis.eave.navigatorAlias.javaEnabled()\n      ) {\n        browserFeatures.java = "1";\n      }\n\n      if (\n        !_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(globalThis.eave.windowAlias.showModalDialog) &&\n        _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(globalThis.eave.navigatorAlias.cookieEnabled)\n      ) {\n        browserFeatures.cookie = globalThis.eave.navigatorAlias.cookieEnabled\n          ? "1"\n          : "0";\n      } else {\n        // Eg IE11 ... prevent error when cookieEnabled is requested within modal dialog. see #11507\n        browserFeatures.cookie = cookieManager.hasCookies();\n      }\n    }\n\n    var width = parseInt(globalThis.eave.screenAlias.width, 10);\n    var height = parseInt(globalThis.eave.screenAlias.height, 10);\n    browserFeatures.res = parseInt(width, 10) + "x" + parseInt(height, 10);\n    return browserFeatures;\n  }\n\n  function injectBrowserFeaturesAndClientHints(request) {\n    var i,\n      appendix = "",\n      bfAppendix = "";\n\n    for (i in browserFeatures) {\n      if (Object.prototype.hasOwnProperty.call(browserFeatures, i)) {\n        bfAppendix += "&" + i + "=" + browserFeatures[i];\n      }\n    }\n\n    if (clientHints) {\n      appendix =\n        "&uadata=" +\n        globalThis.eave.encodeWrapper(\n          globalThis.eave.windowAlias.JSON.stringify(clientHints),\n        );\n    }\n\n    if (request instanceof Array) {\n      for (i = 0; i < request.length; i++) {\n        request[i] += appendix + bfAppendix;\n      }\n    } else {\n      request += appendix + bfAppendix;\n    }\n\n    return request;\n  }\n\n  function supportsClientHints() {\n    return (\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(globalThis.eave.navigatorAlias.userAgentData) &&\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction(\n        globalThis.eave.navigatorAlias.userAgentData.getHighEntropyValues,\n      )\n    );\n  }\n\n  function detectClientHints(callback) {\n    if (clientHintsResolved || clientHintsResolving) {\n      // skip if client hints were already resolved or a previous request already triggered it\n      return;\n    }\n\n    clientHintsResolving = true;\n\n    // Initialize with low entropy values that are always available\n    clientHints = {\n      brands: globalThis.eave.navigatorAlias.userAgentData.brands,\n      platform: globalThis.eave.navigatorAlias.userAgentData.platform,\n    };\n\n    // try to gather high entropy values\n    // currently this methods simply returns the requested values through a Promise\n    // In later versions it might require a user permission\n    globalThis.eave.navigatorAlias.userAgentData\n      .getHighEntropyValues([\n        "brands",\n        "model",\n        "platform",\n        "platformVersion",\n        "uaFullVersion",\n        "fullVersionList",\n      ])\n      .then(\n        function (ua) {\n          if (ua.fullVersionList) {\n            // if fullVersionList is available, brands and uaFullVersion isn\'t needed\n            delete ua.brands;\n            delete ua.uaFullVersion;\n          }\n\n          clientHints = ua;\n          clientHintsResolved = true;\n          clientHintsResolving = false;\n          callback();\n        },\n        function (message) {\n          clientHintsResolved = true;\n          clientHintsResolving = false;\n          callback();\n        },\n      );\n  }\n\n  function generateBrowserSpecificId() {\n    var browserFeatures = detectBrowserFeatures();\n\n    return _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.sha1(\n        (globalThis.eave.navigatorAlias.userAgent || "") +\n          (globalThis.eave.navigatorAlias.platform || "") +\n          globalThis.eave.windowAlias.JSON.stringify(browserFeatures),\n      )\n      .slice(0, 6);\n  }\n\n  function makeCrossDomainDeviceId() {\n    var timestamp = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getCurrentTimestampInSeconds();\n    var browserId = generateBrowserSpecificId();\n    var deviceId = String(timestamp) + browserId;\n\n    return deviceId;\n  }\n\n  /**\n   * Is the host local? (i.e., not an outlink)\n   */\n  function isSiteHostName(hostName) {\n    var i, alias, offset;\n\n    for (i = 0; i < configHostsAlias.length; i++) {\n      alias = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.domainFixup(configHostsAlias[i].toLowerCase());\n\n      if (hostName === alias) {\n        return true;\n      }\n\n      if (alias.slice(0, 1) === ".") {\n        if (hostName === alias.slice(1)) {\n          return true;\n        }\n\n        offset = hostName.length - alias.length;\n\n        if (offset > 0 && hostName.slice(offset) === alias) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Whether the specified domain name and path belong to any of the alias domains (eg. set via setDomains).\n   *\n   * Note: this function is used to determine whether a click on a URL will be considered an "Outlink".\n   *\n   * @param host\n   * @param path\n   * @returns {boolean}\n   */\n  function isSiteHostPath(host, path) {\n    var i, aliasHost, aliasPath;\n\n    for (i = 0; i < configHostsAlias.length; i++) {\n      aliasHost = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.domainFixup(configHostsAlias[i]);\n      aliasPath = getPathName(configHostsAlias[i]);\n\n      if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isSameHost(host, aliasHost) && _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isSitePath(path, aliasPath)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Removes hash tag from the URL\n   * Removes ignore_referrer/ignore_referer\n   * Removes configVisitorIdUrlParameter\n   * Removes campaign parameters\n   *\n   * URLs are purified before being recorded in the cookie,\n   * or before being sent as GET parameters\n   */\n  function purify(url) {\n    var targetPattern, i;\n\n    // Remove campaign names/keywords from URL\n    if (configEnableCampaignParameters !== true) {\n      for (i = 0; i < configCampaignNameParameters.length; i++) {\n        url = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.removeUrlParameter(url, configCampaignNameParameters[i]);\n      }\n\n      for (i = 0; i < configCampaignKeywordParameters.length; i++) {\n        url = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.removeUrlParameter(url, configCampaignKeywordParameters[i]);\n      }\n    }\n\n    // we need to remove this parameter here, they wouldn\'t be removed in eave tracker otherwise eg\n    // for outlinks or referrers\n    url = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.removeUrlParameter(url, configVisitorIdUrlParameter);\n\n    // remove ignore referrer parameter if present\n    url = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.removeUrlParameter(url, "ignore_referrer");\n    url = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.removeUrlParameter(url, "ignore_referer");\n\n    for (i = 0; i < configExcludedQueryParams.length; i++) {\n      url = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.removeUrlParameter(url, configExcludedQueryParams[i]);\n    }\n\n    if (configDiscardHashTag) {\n      targetPattern = new RegExp("#.*");\n\n      return url.replace(targetPattern, "");\n    }\n\n    return url;\n  }\n\n  /*\n   * Send request\n   */\n  function sendRequest(request, delay, callback) {\n    refreshConsentStatus();\n    if (!configHasConsent) {\n      consentRequestsQueue.push([request, callback]);\n      return;\n    }\n\n    if (\n      configBrowserFeatureDetection &&\n      !clientHintsResolved &&\n      supportsClientHints()\n    ) {\n      clientHintsRequestQueue.push([request, callback]);\n      return;\n    }\n\n    hasSentTrackingRequestYet = true;\n\n    if (!configDoNotTrack && request) {\n      if (configConsentRequired && configHasConsent) {\n        // send a consent=1 when explicit consent is given for the apache logs\n        request += "&consent=1";\n      }\n\n      request = injectBrowserFeaturesAndClientHints(request);\n\n      makeSureThereIsAGapAfterFirstTrackingRequestToPreventMultipleVisitorCreation(\n        function () {\n          if (\n            configAlwaysUseSendBeacon &&\n            sendPostRequestViaSendBeacon(request, callback, true)\n          ) {\n            setExpireDateTime(100);\n            return;\n          }\n\n          if (shouldForcePost(request)) {\n            sendXmlHttpRequest(request, callback);\n          } else {\n            getImage(request, callback);\n          }\n\n          setExpireDateTime(delay);\n        },\n      );\n    }\n    if (!heartBeatSetUp) {\n      setUpHeartBeat(); // setup window events too, but only once\n    }\n  }\n\n  function canSendBulkRequest(requests) {\n    if (configDoNotTrack) {\n      return false;\n    }\n\n    return requests && requests.length;\n  }\n\n  /*\n   * Send requests using bulk\n   */\n  function sendBulkRequest(requests, delay) {\n    if (!canSendBulkRequest(requests)) {\n      return;\n    }\n\n    if (\n      configBrowserFeatureDetection &&\n      !clientHintsResolved &&\n      supportsClientHints()\n    ) {\n      clientHintsRequestQueue.push([requests, null]);\n      return;\n    }\n\n    if (!configHasConsent) {\n      consentRequestsQueue.push([requests, null]);\n      return;\n    }\n\n    hasSentTrackingRequestYet = true;\n\n    makeSureThereIsAGapAfterFirstTrackingRequestToPreventMultipleVisitorCreation(\n      function () {\n        var chunks = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.arrayChunk(requests, 50);\n\n        var i = 0,\n          bulk;\n        for (i; i < chunks.length; i++) {\n          bulk =\n            \'{"requests":["?\' +\n            injectBrowserFeaturesAndClientHints(chunks[i]).join(\'","?\') +\n            \'"],"send_image":0}\';\n          if (\n            configAlwaysUseSendBeacon &&\n            sendPostRequestViaSendBeacon(bulk, null, false)\n          ) {\n            // makes sure to load the next page faster by not waiting as long\n            // we apply this once we know send beacon works\n            setExpireDateTime(100);\n          } else {\n            sendXmlHttpRequest(bulk, null, false);\n          }\n        }\n\n        setExpireDateTime(delay);\n      },\n    );\n  }\n\n  function setSiteId(siteId) {\n    configTrackerSiteId = siteId;\n  }\n\n  function appendAvailablePerformanceMetrics(request) {\n    if (customPagePerformanceTiming !== "") {\n      request += customPagePerformanceTiming;\n      performanceTracked = true;\n      return request;\n    }\n\n    if (!globalThis.eave.performanceAlias) {\n      return request;\n    }\n\n    var performanceData =\n      typeof globalThis.eave.performanceAlias.timing === "object" &&\n      globalThis.eave.performanceAlias.timing\n        ? globalThis.eave.performanceAlias.timing\n        : undefined;\n\n    if (!performanceData) {\n      performanceData =\n        typeof globalThis.eave.performanceAlias.getEntriesByType ===\n          "function" &&\n        globalThis.eave.performanceAlias.getEntriesByType("navigation")\n          ? globalThis.eave.performanceAlias.getEntriesByType("navigation")[0]\n          : undefined;\n    }\n\n    if (!performanceData) {\n      return request;\n    }\n\n    // note: there might be negative values because of browser bugs see https://github.com/matomo-org/matomo/pull/16516 in this case we ignore the values\n    var timings = "";\n\n    if (performanceData.connectEnd && performanceData.fetchStart) {\n      if (performanceData.connectEnd < performanceData.fetchStart) {\n        return request;\n      }\n\n      timings +=\n        "&pf_net=" +\n        Math.round(performanceData.connectEnd - performanceData.fetchStart);\n    }\n\n    if (performanceData.responseStart && performanceData.requestStart) {\n      if (performanceData.responseStart < performanceData.requestStart) {\n        return request;\n      }\n\n      timings +=\n        "&pf_srv=" +\n        Math.round(\n          performanceData.responseStart - performanceData.requestStart,\n        );\n    }\n\n    if (performanceData.responseStart && performanceData.responseEnd) {\n      if (performanceData.responseEnd < performanceData.responseStart) {\n        return request;\n      }\n\n      timings +=\n        "&pf_tfr=" +\n        Math.round(performanceData.responseEnd - performanceData.responseStart);\n    }\n\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(performanceData.domLoading)) {\n      if (performanceData.domInteractive && performanceData.domLoading) {\n        if (performanceData.domInteractive < performanceData.domLoading) {\n          return request;\n        }\n\n        timings +=\n          "&pf_dm1=" +\n          Math.round(\n            performanceData.domInteractive - performanceData.domLoading,\n          );\n      }\n    } else {\n      if (performanceData.domInteractive && performanceData.responseEnd) {\n        if (performanceData.domInteractive < performanceData.responseEnd) {\n          return request;\n        }\n\n        timings +=\n          "&pf_dm1=" +\n          Math.round(\n            performanceData.domInteractive - performanceData.responseEnd,\n          );\n      }\n    }\n\n    if (performanceData.domComplete && performanceData.domInteractive) {\n      if (performanceData.domComplete < performanceData.domInteractive) {\n        return request;\n      }\n\n      timings +=\n        "&pf_dm2=" +\n        Math.round(\n          performanceData.domComplete - performanceData.domInteractive,\n        );\n    }\n\n    if (performanceData.loadEventEnd && performanceData.loadEventStart) {\n      if (performanceData.loadEventEnd < performanceData.loadEventStart) {\n        return request;\n      }\n\n      timings +=\n        "&pf_onl=" +\n        Math.round(\n          performanceData.loadEventEnd - performanceData.loadEventStart,\n        );\n    }\n\n    return request + timings;\n  }\n\n  /**\n   * Returns if the given url contains a parameter to ignore the referrer\n   * e.g. ignore_referer or ignore_referrer\n   * @param url\n   * @returns {boolean}\n   */\n  function hasIgnoreReferrerParameter(url) {\n    return (\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getUrlParameter(url, "ignore_referrer") === "1" ||\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getUrlParameter(url, "ignore_referer") === "1"\n    );\n  }\n\n  function detectReferrerAttribution() {\n    var i,\n      now = new Date(),\n      nowTs = Math.round(now.getTime() / 1000),\n      referralTs,\n      referralUrl,\n      referralUrlMaxLength = 1024,\n      currentReferrerHostName,\n      originalReferrerHostName,\n      cookieSessionName = cookieManager.getCookieName("ses"),\n      cookieReferrerName = cookieManager.getCookieName("ref"),\n      cookieSessionValue = cookieManager.getCookie(cookieSessionName),\n      attributionCookie = cookieManager.loadReferrerAttributionCookie(),\n      currentUrl = configCustomUrl || locationHrefAlias,\n      campaignNameDetected,\n      campaignKeywordDetected,\n      attributionValues = {};\n\n    campaignNameDetected = attributionCookie[0];\n    campaignKeywordDetected = attributionCookie[1];\n    referralTs = attributionCookie[2];\n    referralUrl = attributionCookie[3];\n\n    if (!hasIgnoreReferrerParameter(currentUrl) && !cookieSessionValue) {\n      // cookie \'ses\' was not found: we consider this the start of a \'session\'\n\n      // Detect the campaign information from the current URL\n      // Only if campaign wasn\'t previously set\n      // Or if it was set but we must attribute to the most recent one\n      // Note: we are working on the currentUrl before purify() since we can parse the campaign parameters in the hash tag\n      if (\n        (!configConversionAttributionFirstReferrer ||\n          !campaignNameDetected.length) &&\n        configEnableCampaignParameters\n      ) {\n        for (i in configCampaignNameParameters) {\n          if (\n            Object.prototype.hasOwnProperty.call(\n              configCampaignNameParameters,\n              i,\n            )\n          ) {\n            campaignNameDetected = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getUrlParameter(\n              currentUrl,\n              configCampaignNameParameters[i],\n            );\n\n            if (campaignNameDetected.length) {\n              break;\n            }\n          }\n        }\n\n        for (i in configCampaignKeywordParameters) {\n          if (\n            Object.prototype.hasOwnProperty.call(\n              configCampaignKeywordParameters,\n              i,\n            )\n          ) {\n            campaignKeywordDetected = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getUrlParameter(\n              currentUrl,\n              configCampaignKeywordParameters[i],\n            );\n\n            if (campaignKeywordDetected.length) {\n              break;\n            }\n          }\n        }\n      }\n\n      // Store the referrer URL and time in the cookie;\n      // referral URL depends on the first or last referrer attribution\n      currentReferrerHostName = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getHostName(configReferrerUrl);\n      originalReferrerHostName = referralUrl.length\n        ? _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getHostName(referralUrl)\n        : "";\n\n      if (\n        currentReferrerHostName.length && // there is a referrer\n        !isSiteHostName(currentReferrerHostName) && // domain is not the current domain\n        !isReferrerExcluded(configReferrerUrl) && // referrer is excluded\n        (!configConversionAttributionFirstReferrer || // attribute to last known referrer\n          !originalReferrerHostName.length || // previously empty\n          isSiteHostName(originalReferrerHostName) || // previously set but in current domain\n          isReferrerExcluded(referralUrl)) // previously set but excluded\n      ) {\n        referralUrl = configReferrerUrl;\n      }\n\n      // Set the referral cookie if we have either a Referrer URL, or detected a Campaign (or both)\n      if (referralUrl.length || campaignNameDetected.length) {\n        referralTs = nowTs;\n        attributionCookie = [\n          campaignNameDetected,\n          campaignKeywordDetected,\n          referralTs,\n          purify(referralUrl.slice(0, referralUrlMaxLength)),\n        ];\n\n        cookieManager.setCookie(\n          cookieReferrerName,\n          globalThis.eave.windowAlias.JSON.stringify(attributionCookie),\n          cookieManager.configReferralCookieTimeout,\n          cookieManager.configCookiePath,\n          cookieManager.configCookieDomain,\n          cookieManager.configCookieIsSecure,\n          cookieManager.configCookieSameSite,\n        );\n      }\n    }\n\n    if (campaignNameDetected.length) {\n      attributionValues._rcn =\n        globalThis.eave.encodeWrapper(campaignNameDetected);\n    }\n\n    if (campaignKeywordDetected.length) {\n      attributionValues._rck = globalThis.eave.encodeWrapper(\n        campaignKeywordDetected,\n      );\n    }\n\n    attributionValues._refts = referralTs;\n\n    if (String(referralUrl).length) {\n      attributionValues._ref = globalThis.eave.encodeWrapper(\n        purify(referralUrl.slice(0, referralUrlMaxLength)),\n      );\n    }\n\n    return attributionValues;\n  }\n\n  /**\n   * Resolve relative reference\n   *\n   * Note: not as described in rfc3986 section 5.2\n   */\n  function resolveRelativeReference(baseUrl, url) {\n    var protocol = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getProtocolScheme(url),\n      i;\n\n    if (protocol) {\n      return url;\n    }\n\n    if (url.slice(0, 1) === "/") {\n      return (\n        _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getProtocolScheme(baseUrl) + "://" + _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getHostName(baseUrl) + url\n      );\n    }\n\n    baseUrl = purify(baseUrl);\n\n    i = baseUrl.indexOf("?");\n    if (i >= 0) {\n      baseUrl = baseUrl.slice(0, i);\n    }\n\n    i = baseUrl.lastIndexOf("/");\n    if (i !== baseUrl.length - 1) {\n      baseUrl = baseUrl.slice(0, i + 1);\n    }\n\n    return baseUrl + url;\n  }\n\n  /**\n   * Build args to pass with event request being fired\n   */\n  function buildRequest(customData) {\n    const now = new Date();\n    const currentUrl = configCustomUrl || locationHrefAlias;\n    const hasIgnoreReferrerParam = hasIgnoreReferrerParameter(currentUrl);\n    const cookieVisitorId = getContext(configVisitorIdKey);\n    // send charset if document charset is not utf-8. sometimes encoding\n    // of urls will be the same as this and not utf-8, which will cause problems\n    // do not send charset if it is utf8 since it\'s assumed by default in eave\n    let charSet =\n      globalThis.eave.documentAlias.characterSet ||\n      globalThis.eave.documentAlias.charset;\n    if (!charSet || charSet.toLowerCase() === "utf-8") {\n      charSet = null;\n    }\n    let i;\n    const customVariablesCopy = customVariables;\n    const cookieCustomVariablesName = cookieManager.getCookieName("cvar");\n\n    const args = {\n      idsite: configTrackerSiteId,\n      rec: 1,\n      r: String(Math.random()).slice(2, 8), // keep the string to a minimum\n      h: now.getHours(),\n      m: now.getMinutes(),\n      s: now.getSeconds(),\n      url: globalThis.eave.encodeWrapper(purify(currentUrl)),\n      _id: cookieVisitorId,\n      send_image: 0,\n    };\n\n    if (\n      configReferrerUrl.length &&\n      !isReferrerExcluded(configReferrerUrl) &&\n      !hasIgnoreReferrerParam\n    ) {\n      args["urlref"] = globalThis.eave.encodeWrapper(purify(configReferrerUrl));\n    }\n\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumberOrHasLength(configUserId)) {\n      args["uid"] = globalThis.eave.encodeWrapper(configUserId);\n    }\n\n    if (charSet) {\n      args["cs"] = globalThis.eave.encodeWrapper(charSet);\n    }\n\n    // TODO: convert to args obj stuff\n    var referrerAttribution = detectReferrerAttribution();\n    // referrer attribution\n    for (i in referrerAttribution) {\n      if (Object.prototype.hasOwnProperty.call(referrerAttribution, i)) {\n        args[i] = referrerAttribution[i];\n      }\n    }\n\n    var customDimensionIdsAlreadyHandled = [];\n    if (customData) {\n      for (i in customData) {\n        if (\n          Object.prototype.hasOwnProperty.call(customData, i) &&\n          /^dimension\\d+$/.test(i)\n        ) {\n          var index = i.replace("dimension", "");\n          customDimensionIdsAlreadyHandled.push(parseInt(index, 10));\n          customDimensionIdsAlreadyHandled.push(String(index));\n          args[i] = globalThis.eave.encodeWrapper(customData[i]);\n          delete customData[i];\n        }\n      }\n    }\n\n    if (customData && _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isObjectEmpty(customData)) {\n      customData = null;\n      // we deleted all keys from custom data\n    }\n\n    // product page view\n    for (i in ecommerceProductView) {\n      if (Object.prototype.hasOwnProperty.call(ecommerceProductView, i)) {\n        args[i] = globalThis.eave.encodeWrapper(ecommerceProductView[i]);\n      }\n    }\n\n    // custom dimensions\n    for (i in customDimensions) {\n      if (Object.prototype.hasOwnProperty.call(customDimensions, i)) {\n        var isNotSetYet =\n          -1 === _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.indexOfArray(customDimensionIdsAlreadyHandled, i);\n        if (isNotSetYet) {\n          args["dimension" + i] = globalThis.eave.encodeWrapper(\n            customDimensions[i],\n          );\n        }\n      }\n    }\n\n    // custom data\n    if (customData) {\n      args["data"] = globalThis.eave.encodeWrapper(\n        globalThis.eave.windowAlias.JSON.stringify(customData),\n      );\n    } else if (configCustomData) {\n      args["data"] = globalThis.eave.encodeWrapper(\n        globalThis.eave.windowAlias.JSON.stringify(configCustomData),\n      );\n    }\n\n    // Custom Variables, scope "page"\n    function appendCustomVariablesToArgs(args, customVariables, parameterName) {\n      var customVariablesStringified =\n        globalThis.eave.windowAlias.JSON.stringify(customVariables);\n      if (customVariablesStringified.length > 2) {\n        args[parameterName] = globalThis.eave.encodeWrapper(\n          customVariablesStringified,\n        );\n      }\n    }\n\n    var sortedCustomVarPage = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.sortObjectsByKeys(customVariablesPage);\n    var sortedCustomVarEvent = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.sortObjectsByKeys(customVariablesEvent);\n\n    appendCustomVariablesToArgs(args, sortedCustomVarPage, "cvar");\n    appendCustomVariablesToArgs(args, sortedCustomVarEvent, "e_cvar");\n\n    // Custom Variables, scope "visit"\n    if (customVariables) {\n      appendCustomVariablesToArgs(args, customVariables, "_cvar");\n\n      // Don\'t save deleted custom variables in the cookie\n      for (i in customVariablesCopy) {\n        if (Object.prototype.hasOwnProperty.call(customVariablesCopy, i)) {\n          if (customVariables[i][0] === "" || customVariables[i][1] === "") {\n            delete customVariables[i];\n          }\n        }\n      }\n\n      if (configStoreCustomVariablesInCookie) {\n        cookieManager.setCookie(\n          cookieCustomVariablesName,\n          globalThis.eave.windowAlias.JSON.stringify(customVariables),\n          cookieManager.configSessionCookieTimeout,\n          cookieManager.configCookiePath,\n          cookieManager.configCookieDomain,\n          cookieManager.configCookieIsSecure,\n          cookieManager.configCookieSameSite,\n        );\n      }\n    }\n\n    if (configIdPageView) {\n      args["pv_id"] = configIdPageView;\n    }\n\n    if (wasJsTrackingCodeInstallCheckParamProvided()) {\n      args["tracker_install_check"] = globalThis.eave.tracker.InstallCheckNonce;\n    }\n\n    return args;\n  }\n\n  /**\n   * Returns the URL to send event to,\n   * with the standard parameters (plugins, resolution, url, referrer, etc.).\n   * Sends the pageview and browser settings with every request in case of race conditions.\n   */\n  function getRequest(request, customData, pluginMethod) {\n    var currentUrl = configCustomUrl || locationHrefAlias;\n\n    if (cookieManager.configCookiesDisabled) {\n      cookieManager.deleteCookies();\n    }\n\n    if (configDoNotTrack) {\n      return "";\n    }\n\n    var fileRegex = new RegExp("^file://", "i");\n    if (\n      !configFileTracking &&\n      (globalThis.eave.windowAlias.location.protocol === "file:" ||\n        fileRegex.test(currentUrl))\n    ) {\n      return "";\n    }\n\n    // trigger detection of browser feature to ensure a request might not end up in the client hints queue without being processed\n    detectBrowserFeatures();\n\n    // build out the rest of the request\n    request += _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.argsToQueryParameters(buildRequest(customData));\n\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction(configCustomRequestContentProcessing)) {\n      request = configCustomRequestContentProcessing(request);\n    }\n\n    // performance tracking\n    if (\n      configPerformanceTrackingEnabled &&\n      performanceAvailable &&\n      !performanceTracked\n    ) {\n      request = appendAvailablePerformanceMetrics(request);\n      performanceTracked = true;\n    }\n\n    // tracker plugin hook\n    request += _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.executePluginMethod(pluginMethod, {\n      tracker: trackerInstance,\n      request: request,\n    });\n\n    if (configAppendToTrackingUrl.length) {\n      request += "&" + configAppendToTrackingUrl;\n    }\n\n    return request;\n  }\n\n  /*\n   * If there was user activity since the last check, and it\'s been configHeartBeatDelay seconds\n   * since the last tracker, send a ping request (the heartbeat timeout will be reset by sendRequest).\n   */\n  heartBeatPingIfActivityAlias = function heartBeatPingIfActivity() {\n    var now = new Date();\n    now = now.getTime();\n\n    if (!lastTrackerRequestTime) {\n      return false; // no tracking request was ever sent so lets not send heartbeat now\n    }\n\n    if (lastTrackerRequestTime + configHeartBeatDelay <= now) {\n      trackerInstance.ping();\n\n      return true;\n    }\n\n    return false;\n  };\n\n  function logEcommerce(\n    orderId,\n    grandTotal,\n    subTotal,\n    tax,\n    shipping,\n    discount,\n  ) {\n    var request = "idgoal=0",\n      now = new Date(),\n      items = [],\n      sku,\n      isEcommerceOrder = String(orderId).length;\n\n    if (isEcommerceOrder) {\n      request += "&ec_id=" + globalThis.eave.encodeWrapper(orderId);\n    }\n\n    request += "&revenue=" + grandTotal;\n\n    if (String(subTotal).length) {\n      request += "&ec_st=" + subTotal;\n    }\n\n    if (String(tax).length) {\n      request += "&ec_tx=" + tax;\n    }\n\n    if (String(shipping).length) {\n      request += "&ec_sh=" + shipping;\n    }\n\n    if (String(discount).length) {\n      request += "&ec_dt=" + discount;\n    }\n\n    if (ecommerceItems) {\n      // Removing the SKU index in the array before JSON encoding\n      for (sku in ecommerceItems) {\n        if (Object.prototype.hasOwnProperty.call(ecommerceItems, sku)) {\n          // Ensure name and category default to healthy value\n          if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(ecommerceItems[sku][1])) {\n            ecommerceItems[sku][1] = "";\n          }\n\n          if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(ecommerceItems[sku][2])) {\n            ecommerceItems[sku][2] = "";\n          }\n\n          // Set price to zero\n          if (\n            !_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(ecommerceItems[sku][3]) ||\n            String(ecommerceItems[sku][3]).length === 0\n          ) {\n            ecommerceItems[sku][3] = 0;\n          }\n\n          // Set quantity to 1\n          if (\n            !_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(ecommerceItems[sku][4]) ||\n            String(ecommerceItems[sku][4]).length === 0\n          ) {\n            ecommerceItems[sku][4] = 1;\n          }\n\n          items.push(ecommerceItems[sku]);\n        }\n      }\n      request +=\n        "&ec_items=" +\n        globalThis.eave.encodeWrapper(\n          globalThis.eave.windowAlias.JSON.stringify(items),\n        );\n    }\n    request = getRequest(request, configCustomData, "ecommerce");\n    sendRequest(request, configTrackerPause);\n\n    if (isEcommerceOrder) {\n      ecommerceItems = {};\n    }\n  }\n\n  function logEcommerceOrder(\n    orderId,\n    grandTotal,\n    subTotal,\n    tax,\n    shipping,\n    discount,\n  ) {\n    if (String(orderId).length && _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(grandTotal)) {\n      logEcommerce(orderId, grandTotal, subTotal, tax, shipping, discount);\n    }\n  }\n\n  function logEcommerceCartUpdate(grandTotal) {\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(grandTotal)) {\n      logEcommerce("", grandTotal, "", "", "", "");\n    }\n  }\n\n  /**\n   * Log the page view / visit\n   */\n  function logPageView(customTitle, customData, callback) {\n    cookieManager.resetOrExtendSession();\n\n    if (!configIdPageViewSetManually) {\n      configIdPageView = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.generateUniqueId();\n    }\n\n    var request = getRequest(\n      "action_name=" +\n        globalThis.eave.encodeWrapper(_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.titleFixup(customTitle || configTitle)),\n      customData,\n      "log",\n    );\n\n    // append already available performance metrics if they were not already tracked (or appended)\n    if (configPerformanceTrackingEnabled && !performanceTracked) {\n      request = appendAvailablePerformanceMetrics(request);\n    }\n\n    sendRequest(request, configTrackerPause, callback);\n  }\n\n  /*\n   * Construct regular expression of classes\n   */\n  function getClassesRegExp(configClasses, defaultClass) {\n    var i,\n      classesRegExp = "(^| )(eave[_-]" + defaultClass;\n\n    if (configClasses) {\n      for (i = 0; i < configClasses.length; i++) {\n        classesRegExp += "|" + configClasses[i];\n      }\n    }\n\n    classesRegExp += ")( |$)";\n\n    return new RegExp(classesRegExp);\n  }\n\n  function startsUrlWithTrackerUrl(url) {\n    return (\n      configTrackerUrl && url && 0 === String(url).indexOf(configTrackerUrl)\n    );\n  }\n\n  /*\n   * Link or Download?\n   */\n  function getLinkType(className, href, isInLink, hasDownloadAttribute) {\n    if (startsUrlWithTrackerUrl(href)) {\n      return 0;\n    }\n\n    // does class indicate whether it is an (explicit/forced) outlink or a download?\n    var downloadPattern = getClassesRegExp(configDownloadClasses, "download"),\n      linkPattern = getClassesRegExp(configLinkClasses, "link"),\n      // does file extension indicate that it is a download?\n      downloadExtensionsPattern = new RegExp(\n        "\\\\.(" + configDownloadExtensions.join("|") + ")([?&#]|$)",\n        "i",\n      );\n\n    if (linkPattern.test(className)) {\n      return "link";\n    }\n\n    if (\n      hasDownloadAttribute ||\n      downloadPattern.test(className) ||\n      downloadExtensionsPattern.test(href)\n    ) {\n      return "download";\n    }\n\n    if (isInLink) {\n      return 0;\n    }\n\n    return "link";\n  }\n\n  /**\n   * Traverse up DOM from `target` to find node passing `isTargetNode` check\n   *\n   * @param {function (string) => boolean} isTargetNode check for matching html element nodeName\n   * @param {object} target DOM node to traverse from\n   * @return {object|undefined} the matching DOM node, if any\n   */\n  function getTargetNode(isTargetNode, target) {\n    var ignorePattern = getClassesRegExp(configIgnoreClasses, "ignore");\n    while (target && target.parentNode && !isTargetNode(target.nodeName)) {\n      target = target.parentNode;\n    }\n\n    if (\n      target &&\n      isTargetNode(target.nodeName) &&\n      !ignorePattern.test(target.className)\n    ) {\n      return target;\n    }\n    return undefined;\n  }\n\n  function getLinkIfShouldBeProcessed(sourceElement) {\n    sourceElement = getTargetNode(isLinkNode, sourceElement);\n\n    if (!_query_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].hasNodeAttribute(sourceElement, "href")) {\n      return;\n    }\n\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(sourceElement.href)) {\n      return;\n    }\n\n    var originalSourcePath =\n      sourceElement.pathname || getPathName(sourceElement.href);\n\n    // browsers, such as Safari, don\'t downcase hostname and href\n    var originalSourceHostName =\n      sourceElement.hostname || _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getHostName(sourceElement.href);\n    var sourceHostName = originalSourceHostName.toLowerCase();\n    var sourceHref = sourceElement.href.replace(\n      originalSourceHostName,\n      sourceHostName,\n    );\n\n    // browsers, such as Safari, don\'t downcase hostname and href\n    var scriptProtocol = new RegExp(\n      "^(javascript|vbscript|jscript|mocha|livescript|ecmascript|mailto|tel):",\n      "i",\n    );\n\n    if (!scriptProtocol.test(sourceHref)) {\n      // track outlinks and all downloads\n      var linkType = getLinkType(\n        sourceElement.className,\n        sourceHref,\n        isSiteHostPath(sourceHostName, originalSourcePath),\n        _query_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].hasNodeAttribute(sourceElement, "download"),\n      );\n\n      if (linkType) {\n        return {\n          type: linkType,\n          href: sourceHref,\n        };\n      }\n    }\n  }\n\n  function buildContentInteractionRequest(interaction, name, piece, target) {\n    var params = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].buildInteractionRequestParams(\n      interaction,\n      name,\n      piece,\n      target,\n    );\n\n    if (!params) {\n      return;\n    }\n\n    return getRequest(params, null, "contentInteraction");\n  }\n\n  function isNodeAuthorizedToTriggerInteraction(contentNode, interactedNode) {\n    if (!contentNode || !interactedNode) {\n      return false;\n    }\n\n    var targetNode = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].findTargetNode(contentNode);\n\n    if (_content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].shouldIgnoreInteraction(targetNode)) {\n      // interaction should be ignored\n      return false;\n    }\n\n    targetNode = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].findTargetNodeNoDefault(contentNode);\n    if (targetNode && !_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.containsNodeElement(targetNode, interactedNode)) {\n      /**\n       * There is a target node defined but the clicked element is not within the target node. example:\n       * <div data-track-content><a href="Y" data-content-target>Y</a><img src=""/><a href="Z">Z</a></div>\n       *\n       * The user clicked in this case on link Z and not on target Y\n       */\n      return false;\n    }\n\n    return true;\n  }\n\n  function getContentInteractionToRequestIfPossible(\n    anyNode,\n    interaction,\n    fallbackTarget,\n  ) {\n    if (!anyNode) {\n      return;\n    }\n\n    var contentNode = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].findParentContentNode(anyNode);\n\n    if (!contentNode) {\n      // we are not within a content block\n      return;\n    }\n\n    if (!isNodeAuthorizedToTriggerInteraction(contentNode, anyNode)) {\n      return;\n    }\n\n    var contentBlock = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].buildContentBlock(contentNode);\n\n    if (!contentBlock) {\n      return;\n    }\n\n    if (!contentBlock.target && fallbackTarget) {\n      contentBlock.target = fallbackTarget;\n    }\n\n    return _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].buildInteractionRequestParams(\n      interaction,\n      contentBlock.name,\n      contentBlock.piece,\n      contentBlock.target,\n    );\n  }\n\n  function wasContentImpressionAlreadyTracked(contentBlock) {\n    if (!trackedContentImpressions || !trackedContentImpressions.length) {\n      return false;\n    }\n\n    var index, trackedContent;\n\n    for (index = 0; index < trackedContentImpressions.length; index++) {\n      trackedContent = trackedContentImpressions[index];\n\n      if (\n        trackedContent &&\n        trackedContent.name === contentBlock.name &&\n        trackedContent.piece === contentBlock.piece &&\n        trackedContent.target === contentBlock.target\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function trackContentImpressionClickInteraction(targetNode) {\n    return function (event) {\n      if (!targetNode) {\n        return;\n      }\n\n      var contentBlock = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].findParentContentNode(targetNode);\n\n      var interactedElement;\n      if (event) {\n        interactedElement = event.target || event.srcElement;\n      }\n      if (!interactedElement) {\n        interactedElement = targetNode;\n      }\n\n      if (\n        !isNodeAuthorizedToTriggerInteraction(contentBlock, interactedElement)\n      ) {\n        return;\n      }\n\n      if (!contentBlock) {\n        return false;\n      }\n\n      var theTargetNode = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].findTargetNode(contentBlock);\n\n      if (!theTargetNode || _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].shouldIgnoreInteraction(theTargetNode)) {\n        return false;\n      }\n\n      var link = getLinkIfShouldBeProcessed(theTargetNode);\n\n      if (linkTrackingEnabled && link && link.type) {\n        return link.type; // will be handled via outlink or download.\n      }\n\n      return trackerInstance.trackContentInteractionNode(\n        interactedElement,\n        "click",\n      );\n    };\n  }\n\n  function setupInteractionsTracking(contentNodes) {\n    if (!contentNodes || !contentNodes.length) {\n      return;\n    }\n\n    var index, targetNode;\n    for (index = 0; index < contentNodes.length; index++) {\n      targetNode = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].findTargetNode(contentNodes[index]);\n\n      if (targetNode && !targetNode.contentInteractionTrackingSetupDone) {\n        targetNode.contentInteractionTrackingSetupDone = true;\n\n        _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addEventListener(\n          targetNode,\n          "click",\n          trackContentImpressionClickInteraction(targetNode),\n        );\n      }\n    }\n  }\n\n  /*\n   * Log all content pieces\n   */\n  function buildContentImpressionsRequests(contents, contentNodes) {\n    if (!contents || !contents.length) {\n      return [];\n    }\n\n    var index, request;\n\n    for (index = 0; index < contents.length; index++) {\n      if (wasContentImpressionAlreadyTracked(contents[index])) {\n        contents.splice(index, 1);\n        index--;\n      } else {\n        trackedContentImpressions.push(contents[index]);\n      }\n    }\n\n    if (!contents || !contents.length) {\n      return [];\n    }\n\n    setupInteractionsTracking(contentNodes);\n\n    var requests = [];\n\n    for (index = 0; index < contents.length; index++) {\n      request = getRequest(\n        _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].buildImpressionRequestParams(\n          contents[index].name,\n          contents[index].piece,\n          contents[index].target,\n        ),\n        undefined,\n        "contentImpressions",\n      );\n\n      if (request) {\n        requests.push(request);\n      }\n    }\n\n    return requests;\n  }\n\n  /*\n   * Log all content pieces\n   */\n  function getContentImpressionsRequestsFromNodes(contentNodes) {\n    var contents = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].collectContent(contentNodes);\n\n    return buildContentImpressionsRequests(contents, contentNodes);\n  }\n\n  /*\n   * Log currently visible content pieces\n   */\n  function getCurrentlyVisibleContentImpressionsRequestsIfNotTrackedYet(\n    contentNodes,\n  ) {\n    if (!contentNodes || !contentNodes.length) {\n      return [];\n    }\n\n    var index;\n\n    for (index = 0; index < contentNodes.length; index++) {\n      if (!_content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNodeVisible(contentNodes[index])) {\n        contentNodes.splice(index, 1);\n        index--;\n      }\n    }\n\n    if (!contentNodes || !contentNodes.length) {\n      return [];\n    }\n\n    return getContentImpressionsRequestsFromNodes(contentNodes);\n  }\n\n  function buildContentImpressionRequest(\n    contentName,\n    contentPiece,\n    contentTarget,\n  ) {\n    var params = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].buildImpressionRequestParams(\n      contentName,\n      contentPiece,\n      contentTarget,\n    );\n\n    return getRequest(params, null, "contentImpression");\n  }\n\n  function buildContentInteractionRequestNode(node, contentInteraction) {\n    if (!node) {\n      return;\n    }\n\n    var contentNode = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].findParentContentNode(node);\n    var contentBlock = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].buildContentBlock(contentNode);\n\n    if (!contentBlock) {\n      return;\n    }\n\n    if (!contentInteraction) {\n      contentInteraction = "Unknown";\n    }\n\n    return buildContentInteractionRequest(\n      contentInteraction,\n      contentBlock.name,\n      contentBlock.piece,\n      contentBlock.target,\n    );\n  }\n\n  function buildEventRequest(category, action, name, value) {\n    return (\n      "e_c=" +\n      globalThis.eave.encodeWrapper(category) +\n      "&e_a=" +\n      globalThis.eave.encodeWrapper(action) +\n      (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(name) ? "&e_n=" + globalThis.eave.encodeWrapper(name) : "") +\n      (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(value)\n        ? "&e_v=" + globalThis.eave.encodeWrapper(value)\n        : "") +\n      "&ca=1"\n    );\n  }\n\n  /*\n   * Log the event\n   */\n  function logEvent(category, action, name, value, customData, callback) {\n    // Category and Action are required parameters\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumberOrHasLength(category) || !_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumberOrHasLength(action)) {\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.logConsoleError(\n        "Error while logging event: Parameters `category` and `action` must not be empty or filled with whitespaces",\n      );\n      return false;\n    }\n    var request = getRequest(\n      buildEventRequest(category, action, name, value),\n      customData,\n      "event",\n    );\n\n    sendRequest(request, configTrackerPause, callback);\n  }\n\n  /*\n   * Log the site search request\n   */\n  function logSiteSearch(keyword, category, resultsCount, customData) {\n    var request = getRequest(\n      "search=" +\n        globalThis.eave.encodeWrapper(keyword) +\n        (category\n          ? "&search_cat=" + globalThis.eave.encodeWrapper(category)\n          : "") +\n        (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(resultsCount) ? "&search_count=" + resultsCount : ""),\n      customData,\n      "sitesearch",\n    );\n\n    sendRequest(request, configTrackerPause);\n  }\n\n  /*\n   * Log the goal with the server\n   */\n  function logGoal(idGoal, customRevenue, customData, callback) {\n    var request = getRequest(\n      "idgoal=" + idGoal + (customRevenue ? "&revenue=" + customRevenue : ""),\n      customData,\n      "goal",\n    );\n\n    sendRequest(request, configTrackerPause, callback);\n  }\n\n  /*\n   * Log the link or click with the server\n   */\n  function logLink(url, linkType, customData, callback, sourceElement) {\n    var linkParams =\n      linkType + "=" + globalThis.eave.encodeWrapper(purify(url));\n\n    var interaction = getContentInteractionToRequestIfPossible(\n      sourceElement,\n      "click",\n      url,\n    );\n\n    if (interaction) {\n      linkParams += "&" + interaction;\n    }\n\n    var request = getRequest(linkParams, customData, "link");\n\n    sendRequest(request, configTrackerPause, callback);\n  }\n\n  /*\n   * Browser prefix\n   */\n  function prefixPropertyName(prefix, propertyName) {\n    if (prefix !== "") {\n      return (\n        prefix + propertyName.charAt(0).toUpperCase() + propertyName.slice(1)\n      );\n    }\n\n    return propertyName;\n  }\n\n  /*\n   * Check for pre-rendered web pages, and log the page view/link/goal\n   * according to the configuration and/or visibility\n   *\n   * @see http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/PageVisibility/Overview.html\n   */\n  function trackCallback(callback) {\n    var isPreRendered,\n      i,\n      // Chrome 13, IE10, FF10\n      prefixes = ["", "webkit", "ms", "moz"],\n      prefix;\n\n    if (!configCountPreRendered) {\n      for (i = 0; i < prefixes.length; i++) {\n        prefix = prefixes[i];\n\n        // does this browser support the page visibility API?\n        if (\n          Object.prototype.hasOwnProperty.call(\n            globalThis.eave.documentAlias,\n            prefixPropertyName(prefix, "hidden"),\n          )\n        ) {\n          // if pre-rendered, then defer callback until page visibility changes\n          if (\n            globalThis.eave.documentAlias[\n              prefixPropertyName(prefix, "visibilityState")\n            ] === "prerender"\n          ) {\n            isPreRendered = true;\n          }\n          break;\n        }\n      }\n    }\n\n    if (isPreRendered) {\n      // note: the event name doesn\'t follow the same naming convention as vendor properties\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addEventListener(\n        globalThis.eave.documentAlias,\n        prefix + "visibilitychange",\n        function ready() {\n          globalThis.eave.documentAlias.removeEventListener(\n            prefix + "visibilitychange",\n            ready,\n            false,\n          );\n          callback();\n        },\n      );\n\n      return;\n    }\n\n    // configCountPreRendered === true || isPreRendered === false\n    callback();\n  }\n\n  function getCrossDomainVisitorId() {\n    var visitorId = trackerInstance.getVisitorId();\n    var deviceId = makeCrossDomainDeviceId();\n    return visitorId + deviceId;\n  }\n\n  function replaceHrefForCrossDomainLink(element) {\n    if (!element) {\n      return;\n    }\n\n    if (!_query_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].hasNodeAttribute(element, "href")) {\n      return;\n    }\n\n    var link = _query_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getAttributeValueFromNode(element, "href");\n\n    if (!link || startsUrlWithTrackerUrl(link)) {\n      return;\n    }\n\n    if (!trackerInstance.getVisitorId()) {\n      return; // cookies are disabled.\n    }\n\n    // we need to remove the parameter and add it again if needed to make sure we have latest timestamp\n    // and visitorId (eg userId might be set etc)\n    link = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.removeUrlParameter(link, configVisitorIdUrlParameter);\n\n    var crossDomainVisitorId = getCrossDomainVisitorId();\n\n    link = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addUrlParameter(\n      link,\n      configVisitorIdUrlParameter,\n      crossDomainVisitorId,\n    );\n\n    _query_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].setAnyAttribute(element, "href", link);\n  }\n\n  function isLinkToDifferentDomainButSameEaveWebsite(element) {\n    var targetLink = _query_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getAttributeValueFromNode(element, "href");\n\n    if (!targetLink) {\n      return false;\n    }\n\n    targetLink = String(targetLink);\n\n    var isOutlink =\n      targetLink.indexOf("//") === 0 ||\n      targetLink.indexOf("http://") === 0 ||\n      targetLink.indexOf("https://") === 0;\n\n    if (!isOutlink) {\n      return false;\n    }\n\n    var originalSourcePath = element.pathname || getPathName(element.href);\n    var originalSourceHostName = (\n      element.hostname || _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getHostName(element.href)\n    ).toLowerCase();\n\n    if (isSiteHostPath(originalSourceHostName, originalSourcePath)) {\n      // we could also check against config cookie domain but this would require that other website\n      // sets actually same cookie domain and we cannot rely on it.\n      if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isSameHost(domainAlias, _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.domainFixup(originalSourceHostName))) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return false;\n  }\n\n  /**\n   * Process clicks on button elements\n   */\n  function processButtonClick(sourceElement) {\n    // TODO improve data values passed...\n    // fire event\n    logEvent(\n      "button",\n      "click",\n      "button click",\n      sourceElement.innerText,\n      null,\n      null,\n    );\n  }\n\n  /**\n   * Process clicks on link elements\n   */\n  function processLinkClick(sourceElement) {\n    var link = getLinkIfShouldBeProcessed(sourceElement);\n\n    // not a link to same domain or the same website (as set in setDomains())\n    if (link && link.type) {\n      link.href = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.safeDecodeWrapper(link.href);\n      logLink(link.href, link.type, undefined, null, sourceElement);\n      return;\n    }\n\n    // a link to same domain or the same website (as set in setDomains())\n    if (crossDomainTrackingEnabled) {\n      // in case the clicked element is within the <a> (for example there is a <div> within the <a>) this will get the actual <a> link element\n      sourceElement = getTargetNode(isLinkNode, sourceElement);\n\n      if (isLinkToDifferentDomainButSameEaveWebsite(sourceElement)) {\n        replaceHrefForCrossDomainLink(sourceElement);\n      }\n    }\n  }\n\n  function isIE8orOlder() {\n    return (\n      globalThis.eave.documentAlias.all &&\n      !globalThis.eave.documentAlias.h.addEventListener\n    );\n  }\n\n  function getKeyCodeFromEvent(event) {\n    // event.which is deprecated https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which\n    var which = event.which;\n\n    /**\n          1 : Left mouse button\n          2 : Wheel button or middle button\n          3 : Right mouse button\n          */\n\n    var typeOfEventButton = typeof event.button;\n\n    if (!which && typeOfEventButton !== "undefined") {\n      /**\n           -1: No button pressed\n            0 : Main button pressed, usually the left button\n            1 : Auxiliary button pressed, usually the wheel button or themiddle button (if present)\n            2 : Secondary button pressed, usually the right button\n            3 : Fourth button, typically the Browser Back button\n            4 : Fifth button, typically the Browser Forward button\n\n            IE8 and earlier has different values:\n            1 : Left mouse button\n            2 : Right mouse button\n            4 : Wheel button or middle button\n\n            For a left-hand configured mouse, the return values are reversed. We do not take care of that.\n            */\n\n      if (isIE8orOlder()) {\n        if (event.button & 1) {\n          which = 1;\n        } else if (event.button & 2) {\n          which = 3;\n        } else if (event.button & 4) {\n          which = 2;\n        }\n      } else {\n        if (event.button === 0 || event.button === "0") {\n          which = 1;\n        } else if (event.button & 1) {\n          which = 2;\n        } else if (event.button & 2) {\n          which = 3;\n        }\n      }\n    }\n\n    return which;\n  }\n\n  function getNameOfClickedMouseButton(event) {\n    switch (getKeyCodeFromEvent(event)) {\n      case 1:\n        return "left";\n      case 2:\n        return "middle";\n      case 3:\n        return "right";\n    }\n  }\n\n  function getTargetElementFromEvent(event) {\n    return event.target || event.srcElement;\n  }\n\n  function isLinkNode(nodeName) {\n    return nodeName === "A" || nodeName === "AREA";\n  }\n\n  function isButtonNode(nodeName) {\n    return nodeName === "BUTTON";\n  }\n\n  /**\n   * Handle click event\n   *\n   * @param {boolean} enable\n   */\n  function clickHandler(enable) {\n    /*\n        List of element tracking to check for in priority order.\n        This click handler will only fire 1 event per click, so higher\n        priority tracked elements should appear earlier in the list.\n\n        e.g. \n        linkTracking comes before buttonClickTracking.\n        Therefore, we expect clicking on the button element of\n        `<a href="#"><button>click!</button></a>`\n        Will trigger a link click event rather than a button click event.\n        */\n    var trackers = [\n      {\n        trackingEnabled: function () {\n          return linkTrackingEnabled;\n        },\n        nodeFilter: isLinkNode,\n        clickProcessor: processLinkClick,\n      },\n      {\n        trackingEnabled: function () {\n          return buttonClickTrackingEnabled;\n        },\n        nodeFilter: isButtonNode,\n        clickProcessor: processButtonClick,\n      },\n    ];\n    var activeTracker;\n\n    /**\n     * From a click listener callback event, get a target element we\n     * are tracking, if any.\n     *\n     * @param {*} event h.addEventListener callback param\n     */\n    function getClickTarget(event) {\n      var initialTarget = getTargetElementFromEvent(event);\n\n      /* \n          loop over all enabled element trackers, returning the first\n          (aka highest priority) node found\n          */\n      var targetNode = undefined;\n      var i;\n      for (i = 0; i < trackers.length; i++) {\n        var targetTrackingEnabled = trackers[i].trackingEnabled();\n        var targetNodeFilter = trackers[i].nodeFilter;\n        if (targetTrackingEnabled) {\n          targetNode = getTargetNode(targetNodeFilter, initialTarget);\n          if (targetNode) {\n            // TODO: separate this side affect\n            activeTracker = trackers[i];\n            break;\n          }\n        }\n      }\n      return targetNode;\n    }\n\n    return function (event) {\n      event = event || globalThis.eave.windowAlias.event;\n\n      var target = getClickTarget(event);\n      // we arent tracking the clicked element(s)\n      if (!target || !activeTracker) {\n        return;\n      }\n\n      var button = getNameOfClickedMouseButton(event);\n\n      if (event.type === "click") {\n        var ignoreClick = false;\n        if (enable && button === "middle") {\n          // if enabled, we track middle clicks via mouseup\n          // some browsers (eg chrome) trigger click and mousedown/up events when middle is clicked,\n          // whereas some do not. This way we make "sure" to track them only once, either in click\n          // (default) or in mouseup (if enable == true)\n          ignoreClick = true;\n        }\n\n        if (target && !ignoreClick) {\n          activeTracker.clickProcessor(target);\n        }\n      } else if (event.type === "mousedown") {\n        if (button === "middle" && target) {\n          lastButton = button;\n          lastTarget = target;\n        } else {\n          lastButton = lastTarget = null;\n        }\n      } else if (event.type === "mouseup") {\n        if (button === lastButton && target === lastTarget) {\n          activeTracker.clickProcessor(target);\n        }\n        lastButton = lastTarget = null;\n      } else if (event.type === "contextmenu") {\n        activeTracker.clickProcessor(target);\n      }\n    };\n  }\n\n  /*\n   * Add click listener to a DOM element\n   */\n  function addClickListener(element, enable, useCapture) {\n    var enableType = typeof enable;\n    if (enableType === "undefined") {\n      enable = true;\n    }\n\n    _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addEventListener(element, "click", clickHandler(enable), useCapture);\n\n    if (enable) {\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addEventListener(element, "mouseup", clickHandler(enable), useCapture);\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addEventListener(\n        element,\n        "mousedown",\n        clickHandler(enable),\n        useCapture,\n      );\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addEventListener(\n        element,\n        "contextmenu",\n        clickHandler(enable),\n        useCapture,\n      );\n    }\n  }\n\n  function enableTrackOnlyVisibleContent(\n    checkOnScroll,\n    timeIntervalInMs,\n    tracker,\n  ) {\n    if (isTrackOnlyVisibleContentEnabled) {\n      // already enabled, do not register intervals again\n      return true;\n    }\n\n    isTrackOnlyVisibleContentEnabled = true;\n\n    var didScroll = false;\n    var events, index;\n\n    function setDidScroll() {\n      didScroll = true;\n    }\n\n    _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trackCallbackOnLoad(function () {\n      function checkContent(intervalInMs) {\n        setTimeout(function () {\n          if (!isTrackOnlyVisibleContentEnabled) {\n            return; // the tests stopped tracking only visible content\n          }\n          didScroll = false;\n          tracker.trackVisibleContentImpressions();\n          checkContent(intervalInMs);\n        }, intervalInMs);\n      }\n\n      function checkContentIfDidScroll(intervalInMs) {\n        setTimeout(function () {\n          if (!isTrackOnlyVisibleContentEnabled) {\n            return; // the tests stopped tracking only visible content\n          }\n\n          if (didScroll) {\n            didScroll = false;\n            tracker.trackVisibleContentImpressions();\n          }\n\n          checkContentIfDidScroll(intervalInMs);\n        }, intervalInMs);\n      }\n\n      if (checkOnScroll) {\n        // scroll event is executed after each pixel, so we make sure not to\n        // execute event too often. otherwise FPS goes down a lot!\n        events = ["scroll", "resize"];\n        for (index = 0; index < events.length; index++) {\n          if (globalThis.eave.documentAlias.h.addEventListener) {\n            globalThis.eave.documentAlias.h.addEventListener(\n              events[index],\n              setDidScroll,\n              false,\n            );\n          } else {\n            globalThis.eave.windowAlias.attachEvent(\n              "on" + events[index],\n              setDidScroll,\n            );\n          }\n        }\n\n        checkContentIfDidScroll(100);\n      }\n\n      if (timeIntervalInMs && timeIntervalInMs > 0) {\n        timeIntervalInMs = parseInt(timeIntervalInMs, 10);\n        checkContent(timeIntervalInMs);\n      }\n    });\n  }\n\n  /**\n   * Set visitor ID if it hasnt yet been set.\n   * Then trys to save eaveContext to cookie, in case\n   * cookie consent has changed.\n   */\n  function setVisitorId() {\n    if (!getContext(configVisitorIdKey)) {\n      setContext(configVisitorIdKey, _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.uuidv4());\n    } else {\n      // try save cookie, in case of consent change\n      saveContext();\n    }\n  }\n\n  /*<DEBUG>*/\n  /*\n   * Register a test hook. Using eval() permits access to otherwise\n   * privileged members.\n   */\n  function registerHook(hookName, userHook) {\n    var hookObj = null;\n\n    if (\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(hookName) &&\n      !_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(registeredHooks[hookName]) &&\n      userHook\n    ) {\n      if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isObject(userHook)) {\n        hookObj = userHook;\n      } else if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(userHook)) {\n        try {\n          eval("hookObj =" + userHook);\n        } catch (ignore) {}\n      }\n\n      registeredHooks[hookName] = hookObj;\n    }\n\n    return hookObj;\n  }\n\n  /*</DEBUG>*/\n\n  var requestQueue = {\n    enabled: true,\n    requests: [],\n    timeout: null,\n    interval: 2500,\n    sendRequests: function () {\n      var requestsToTrack = this.requests;\n      this.requests = [];\n      if (requestsToTrack.length === 1) {\n        sendRequest(requestsToTrack[0], configTrackerPause);\n      } else {\n        sendBulkRequest(requestsToTrack, configTrackerPause);\n      }\n    },\n    canQueue: function () {\n      return !globalThis.eave.isPageUnloading && this.enabled;\n    },\n    pushMultiple: function (requests) {\n      if (!this.canQueue()) {\n        sendBulkRequest(requests, configTrackerPause);\n        return;\n      }\n\n      var i;\n      for (i = 0; i < requests.length; i++) {\n        this.push(requests[i]);\n      }\n    },\n    push: function (requestUrl) {\n      if (!requestUrl) {\n        return;\n      }\n      if (!this.canQueue()) {\n        // we don\'t queue as we need to ensure the request will be sent when the page is unloading...\n        sendRequest(requestUrl, configTrackerPause);\n        return;\n      }\n\n      requestQueue.requests.push(requestUrl);\n\n      if (this.timeout) {\n        clearTimeout(this.timeout);\n        this.timeout = null;\n      }\n      // we always extend by another 2.5 seconds after receiving a tracking request\n      this.timeout = setTimeout(function () {\n        requestQueue.timeout = null;\n        requestQueue.sendRequests();\n      }, requestQueue.interval);\n\n      var trackerQueueId = "RequestQueue" + uniqueTrackerId;\n      if (\n        !Object.prototype.hasOwnProperty.call(\n          globalThis.eave.plugins,\n          trackerQueueId,\n        )\n      ) {\n        // we setup one unload handler per tracker...\n        // eave.addPlugin might not be defined at this point, we add the plugin directly also to make\n        // JSLint happy.\n        globalThis.eave.plugins[trackerQueueId] = {\n          unload: function () {\n            if (requestQueue.timeout) {\n              clearTimeout(requestQueue.timeout);\n            }\n            requestQueue.sendRequests();\n          },\n        };\n      }\n    },\n  };\n  /************************************************************\n   * Constructor\n   ************************************************************/\n\n  /*\n   * initialize tracker\n   */\n\n  /*<DEBUG>*/\n  /*\n   * initialize test plugin\n   */\n  _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.executePluginMethod("run", null, registerHook);\n  /*</DEBUG>*/\n\n  /************************************************************\n   * Public data and methods\n   ************************************************************/\n\n  /*<DEBUG>*/\n  /*\n   * Test hook accessors\n   */\n  this.hook = registeredHooks;\n  this.getHook = function (hookName) {\n    return registeredHooks[hookName];\n  };\n  this.getQuery = function () {\n    return _query_mjs__WEBPACK_IMPORTED_MODULE_4__["default"];\n  };\n  this.getContent = function () {\n    return _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"];\n  };\n  this.isUsingAlwaysUseSendBeacon = function () {\n    return configAlwaysUseSendBeacon;\n  };\n\n  this.buildContentImpressionRequest = buildContentImpressionRequest;\n  this.buildContentInteractionRequest = buildContentInteractionRequest;\n  this.buildContentInteractionRequestNode = buildContentInteractionRequestNode;\n  this.getContentImpressionsRequestsFromNodes =\n    getContentImpressionsRequestsFromNodes;\n  this.getCurrentlyVisibleContentImpressionsRequestsIfNotTrackedYet =\n    getCurrentlyVisibleContentImpressionsRequestsIfNotTrackedYet;\n  this.trackCallbackOnLoad = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trackCallbackOnLoad;\n  this.trackCallbackOnReady = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trackCallbackOnReady;\n  this.buildContentImpressionsRequests = buildContentImpressionsRequests;\n  this.wasContentImpressionAlreadyTracked = wasContentImpressionAlreadyTracked;\n  this.appendContentInteractionToRequestIfPossible =\n    getContentInteractionToRequestIfPossible;\n  this.setupInteractionsTracking = setupInteractionsTracking;\n  this.trackContentImpressionClickInteraction =\n    trackContentImpressionClickInteraction;\n  this.internalIsNodeVisible = _visibility_mjs__WEBPACK_IMPORTED_MODULE_5__.isVisible;\n  this.isNodeAuthorizedToTriggerInteraction =\n    isNodeAuthorizedToTriggerInteraction;\n  this.getDomains = function () {\n    return configHostsAlias;\n  };\n  this.getExcludedReferrers = function () {\n    return configExcludedReferrers;\n  };\n  this.getConfigIdPageView = function () {\n    return configIdPageView;\n  };\n  this.getConfigDownloadExtensions = function () {\n    return configDownloadExtensions;\n  };\n  this.enableTrackOnlyVisibleContent = function (\n    checkOnScroll,\n    timeIntervalInMs,\n  ) {\n    return enableTrackOnlyVisibleContent(checkOnScroll, timeIntervalInMs, this);\n  };\n  this.clearTrackedContentImpressions = function () {\n    trackedContentImpressions = [];\n  };\n  this.getTrackedContentImpressions = function () {\n    return trackedContentImpressions;\n  };\n  this.clearEnableTrackOnlyVisibleContent = function () {\n    isTrackOnlyVisibleContentEnabled = false;\n  };\n  this.disableLinkTracking = function () {\n    clickListenerInstalled = false;\n    linkTrackingEnabled = false;\n  };\n  this.getCustomPagePerformanceTiming = function () {\n    return customPagePerformanceTiming;\n  };\n  this.removeAllAsyncTrackersButFirst = function () {\n    var firstTracker = globalThis.eave.asyncTrackers[0];\n    globalThis.eave.asyncTrackers = [firstTracker];\n  };\n  this.getConsentRequestsQueue = function () {\n    var i,\n      requests = [];\n\n    for (i = 0; i < consentRequestsQueue.length; i++) {\n      requests.push(consentRequestsQueue[i][0]);\n    }\n\n    return requests;\n  };\n  this.getRequestQueue = function () {\n    return requestQueue;\n  };\n  this.getJavascriptErrors = function () {\n    return javaScriptErrors;\n  };\n  this.unsetPageIsUnloading = function () {\n    globalThis.eave.isPageUnloading = false;\n  };\n  /*</DEBUG>*/\n  this.hasConsent = function () {\n    return configHasConsent;\n  };\n\n  /**\n   * Get visitor ID (from first party cookie)\n   *\n   * @returns {string} Visitor ID in hexits (or empty string, if not yet known)\n   */\n  this.getVisitorId = function () {\n    return getContext(configVisitorIdKey) || "";\n  };\n\n  /**\n   * Get the Attribution information, which is an array that contains\n   * the Referrer used to reach the site as well as the campaign name and keyword\n   * It is useful only when used in conjunction with Tracker API function setAttributionInfo()\n   * To access specific data point, you should use the other functions getAttributionReferrer* and getAttributionCampaign*\n   *\n   * @returns {Array} Attribution array, Example use:\n   *   1) Call globalThis.eave.windowAlias.JSON.stringify(eaveTracker.getAttributionInfo())\n   *   2) Pass this json encoded string to the Tracking API (php or java client): setAttributionInfo()\n   */\n  this.getAttributionInfo = function () {\n    return cookieManager.loadReferrerAttributionCookie();\n  };\n\n  /**\n   * Get the Campaign name that was parsed from the landing page URL when the visitor\n   * landed on the site originally\n   *\n   * @returns {string}\n   */\n  this.getAttributionCampaignName = function () {\n    return cookieManager.loadReferrerAttributionCookie()[0];\n  };\n\n  /**\n   * Get the Campaign keyword that was parsed from the landing page URL when the visitor\n   * landed on the site originally\n   *\n   * @returns {string}\n   */\n  this.getAttributionCampaignKeyword = function () {\n    return cookieManager.loadReferrerAttributionCookie()[1];\n  };\n\n  /**\n   * Get the time at which the referrer (used for Goal Attribution) was detected\n   *\n   * @returns {int} Timestamp or 0 if no referrer currently set\n   */\n  this.getAttributionReferrerTimestamp = function () {\n    return cookieManager.loadReferrerAttributionCookie()[2];\n  };\n\n  /**\n   * Get the full referrer URL that will be used for Goal Attribution\n   *\n   * @returns {string} Raw URL, or empty string \'\' if no referrer currently set\n   */\n  this.getAttributionReferrerUrl = function () {\n    return cookieManager.loadReferrerAttributionCookie()[3];\n  };\n\n  /**\n   * Specify the eave tracking URL\n   *\n   * @param {string} trackerUrl\n   */\n  this.setTrackerUrl = function (trackerUrl) {\n    configTrackerUrl = trackerUrl;\n  };\n\n  /**\n   * Returns the eave tracking URL\n   * @returns {string}\n   */\n  this.getTrackerUrl = function () {\n    return configTrackerUrl;\n  };\n\n  /**\n   * Returns the eave server URL.\n   *\n   * @returns {string}\n   */\n  this.getEaveUrl = function () {\n    // TODO: we could hardcode this?\n    return this.getTrackerUrl();\n  };\n\n  /**\n   * Adds a new tracker. All sent requests will be also sent to the given siteId and eaveUrl.\n   *\n   * @param {string} eaveUrl  The tracker URL of the current tracker instance\n   * @param {int|string} siteId\n   * @returns {Tracker}\n   */\n  this.addTracker = function (eaveUrl, siteId) {\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(eaveUrl) || null === eaveUrl) {\n      eaveUrl = this.getTrackerUrl();\n    }\n\n    var tracker = new Tracker(eaveUrl, siteId);\n\n    globalThis.eave.asyncTrackers.push(tracker);\n\n    globalThis.eave.eave.trigger("TrackerAdded", [this]);\n\n    return tracker;\n  };\n\n  /**\n   * Returns the site ID\n   *\n   * @returns {int}\n   */\n  this.getSiteId = function () {\n    return configTrackerSiteId;\n  };\n\n  /**\n   * Specify the site ID\n   *\n   * @param {int|string} siteId\n   */\n  this.setSiteId = function (siteId) {\n    setSiteId(siteId);\n  };\n\n  /**\n   * Clears the User ID\n   */\n  this.resetUserId = function () {\n    configUserId = "";\n  };\n\n  /**\n   * Sets a User ID to this user (such as an email address or a username)\n   *\n   * @param {string} userId User ID\n   */\n  this.setUserId = function (userId) {\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumberOrHasLength(userId)) {\n      configUserId = userId;\n    }\n  };\n\n  /**\n   * Gets the User ID if set.\n   *\n   * @returns {string} User ID\n   */\n  this.getUserId = function () {\n    return configUserId;\n  };\n\n  /**\n   * Pass custom data to the server\n   *\n   * Examples:\n   *   tracker.setCustomData(object);\n   *   tracker.setCustomData(key, value);\n   *\n   * @param {*} key_or_obj\n   * @param {*} opt_value\n   */\n  this.setCustomData = function (key_or_obj, opt_value) {\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isObject(key_or_obj)) {\n      configCustomData = key_or_obj;\n    } else {\n      if (!configCustomData) {\n        configCustomData = {};\n      }\n      configCustomData[key_or_obj] = opt_value;\n    }\n  };\n\n  /**\n   * Get custom data\n   *\n   * @returns {*}\n   */\n  this.getCustomData = function () {\n    return configCustomData;\n  };\n\n  /**\n   * Configure function with custom request content processing logic.\n   * It gets called after request content in form of query parameters string has been prepared and before request content gets sent.\n   *\n   * Examples:\n   *   tracker.setCustomRequestProcessing(function(request){\n   *     var pairs = request.split(\'&\');\n   *     var result = {};\n   *     pairs.forEach(function(pair) {\n   *       pair = pair.split(\'=\');\n   *       result[pair[0]] = decodeURIComponent(pair[1] || \'\');\n   *     });\n   *     return JSON.stringify(result);\n   *   });\n   *\n   * @param {Function} customRequestContentProcessingLogic\n   */\n  this.setCustomRequestProcessing = function (\n    customRequestContentProcessingLogic,\n  ) {\n    configCustomRequestContentProcessing = customRequestContentProcessingLogic;\n  };\n\n  /**\n   * Appends the specified query string to the Tracking API URL\n   *\n   * @param {string} queryString eg. \'lat=140&long=100\'\n   */\n  this.appendToTrackingUrl = function (queryString) {\n    configAppendToTrackingUrl = queryString;\n  };\n\n  /**\n   * Returns the query string for the current HTTP Tracking API request.\n   * eave would prepend the hostname and path to eave: http://example.org/eave/api?\n   * prior to sending the request.\n   *\n   * @param request eg. "param=value&param2=value2"\n   */\n  this.getRequest = function (request) {\n    return getRequest(request);\n  };\n\n  /**\n   * Add plugin defined by a name and a callback function.\n   * The callback function will be called whenever a tracking request is sent.\n   * This can be used to append data to the tracking request, or execute other custom logic.\n   *\n   * @param {string} pluginName\n   * @param {Object} pluginObj\n   */\n  this.addPlugin = function (pluginName, pluginObj) {\n    globalThis.eave.plugins[pluginName] = pluginObj;\n  };\n\n  /**\n   * Lazy loads the custom variables from the cookie, only once during this page view\n   */\n  function loadCustomVariables() {\n    if (customVariables === false) {\n      customVariables = cookieManager.getCustomVariablesFromCookie();\n    }\n  }\n\n  /**\n   * Set Custom Dimensions. Set Custom Dimensions will not be cleared after a tracked pageview and will\n   * be sent along all following tracking requests. It is possible to remove/clear a value via `deleteCustomDimension`.\n   *\n   * @param {int} customDimensionId A Custom Dimension index\n   * @param {string} value\n   */\n  this.setCustomDimension = function (customDimensionId, value) {\n    customDimensionId = parseInt(customDimensionId, 10);\n    if (customDimensionId > 0) {\n      if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(value)) {\n        value = "";\n      }\n      if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(value)) {\n        value = String(value);\n      }\n      customDimensions[customDimensionId] = value;\n    }\n  };\n\n  /**\n   * Get a stored value for a specific Custom Dimension index.\n   *\n   * @param {int} customDimensionId A Custom Dimension index\n   */\n  this.getCustomDimension = function (customDimensionId) {\n    customDimensionId = parseInt(customDimensionId, 10);\n    if (\n      customDimensionId > 0 &&\n      Object.prototype.hasOwnProperty.call(customDimensions, customDimensionId)\n    ) {\n      return customDimensions[customDimensionId];\n    }\n  };\n\n  /**\n   * Delete a custom dimension.\n   *\n   * @param {int} customDimensionId Custom dimension Id\n   */\n  this.deleteCustomDimension = function (customDimensionId) {\n    customDimensionId = parseInt(customDimensionId, 10);\n    if (customDimensionId > 0) {\n      delete customDimensions[customDimensionId];\n    }\n  };\n\n  /**\n   * Set custom variable within this visit\n   *\n   * @param {int} index Custom variable slot ID from 1-5\n   * @param {string} name\n   * @param {string} value\n   * @param {string} scope Scope of Custom Variable:\n   *                     - "visit" will store the name/value in the visit and will persist it in the cookie for the duration of the visit,\n   *                     - "page" will store the name/value in the next page view tracked.\n   *                     - "event" will store the name/value in the next event tracked.\n   */\n  this.setCustomVariable = function (index, name, value, scope) {\n    var toRecord;\n\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(scope)) {\n      scope = "visit";\n    }\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(name)) {\n      return;\n    }\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(value)) {\n      value = "";\n    }\n    if (index > 0) {\n      name = !_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(name) ? String(name) : name;\n      value = !_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(value) ? String(value) : value;\n      toRecord = [\n        name.slice(0, customVariableMaximumLength),\n        value.slice(0, customVariableMaximumLength),\n      ];\n      // numeric scope is there for GA compatibility\n      if (scope === "visit" || scope === 2) {\n        loadCustomVariables();\n        customVariables[index] = toRecord;\n      } else if (scope === "page" || scope === 3) {\n        customVariablesPage[index] = toRecord;\n      } else if (scope === "event") {\n        /* GA does not have \'event\' scope but we do */\n        customVariablesEvent[index] = toRecord;\n      }\n    }\n  };\n\n  /**\n   * Get custom variable\n   *\n   * @param {int} index Custom variable slot ID from 1-5\n   * @param {string} scope Scope of Custom Variable: "visit" or "page" or "event"\n   */\n  this.getCustomVariable = function (index, scope) {\n    var cvar;\n\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(scope)) {\n      scope = "visit";\n    }\n\n    if (scope === "page" || scope === 3) {\n      cvar = customVariablesPage[index];\n    } else if (scope === "event") {\n      cvar = customVariablesEvent[index];\n    } else if (scope === "visit" || scope === 2) {\n      loadCustomVariables();\n      cvar = customVariables[index];\n    }\n\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(cvar) || (cvar && cvar[0] === "")) {\n      return false;\n    }\n\n    return cvar;\n  };\n\n  /**\n   * Delete custom variable\n   *\n   * @param {int} index Custom variable slot ID from 1-5\n   * @param {string} scope\n   */\n  this.deleteCustomVariable = function (index, scope) {\n    // Only delete if it was there already\n    if (this.getCustomVariable(index, scope)) {\n      this.setCustomVariable(index, "", "", scope);\n    }\n  };\n\n  /**\n   * Deletes all custom variables for a certain scope.\n   *\n   * @param {string} scope\n   */\n  this.deleteCustomVariables = function (scope) {\n    if (scope === "page" || scope === 3) {\n      customVariablesPage = {};\n    } else if (scope === "event") {\n      customVariablesEvent = {};\n    } else if (scope === "visit" || scope === 2) {\n      customVariables = {};\n    }\n  };\n\n  /**\n   * When called then the Custom Variables of scope "visit" will be stored (persisted) in a first party cookie\n   * for the duration of the visit. This is useful if you want to call getCustomVariable later in the visit.\n   *\n   * By default, Custom Variables of scope "visit" are not stored on the visitor\'s computer.\n   */\n  this.storeCustomVariablesInCookie = function () {\n    configStoreCustomVariablesInCookie = true;\n  };\n\n  /**\n   * Set delay for link tracking (in milliseconds)\n   *\n   * @param {int} delay Delay [ms]\n   */\n  this.setLinkTrackingTimer = function (delay) {\n    configTrackerPause = delay;\n  };\n\n  /**\n   * Get delay for link tracking (in milliseconds)\n   *\n   * @returns {int} Delay [ms]\n   */\n  this.getLinkTrackingTimer = function () {\n    return configTrackerPause;\n  };\n\n  /**\n   * Set list of file extensions to be recognized as downloads\n   *\n   * @param {string|Array} extensions\n   */\n  this.setDownloadExtensions = function (extensions) {\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(extensions)) {\n      extensions = extensions.split("|");\n    }\n    configDownloadExtensions = extensions;\n  };\n\n  /**\n   * Specify additional file extensions to be recognized as downloads\n   *\n   * @param {string|Array} extensions  for example \'custom\' or [\'custom1\',\'custom2\',\'custom3\']\n   */\n  this.addDownloadExtensions = function (extensions) {\n    var i;\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(extensions)) {\n      extensions = extensions.split("|");\n    }\n    for (i = 0; i < extensions.length; i++) {\n      configDownloadExtensions.push(extensions[i]);\n    }\n  };\n\n  /**\n   * Removes specified file extensions from the list of recognized downloads\n   *\n   * @param {string|Array} extensions  for example \'custom\' or [\'custom1\',\'custom2\',\'custom3\']\n   */\n  this.removeDownloadExtensions = function (extensions) {\n    var i,\n      newExtensions = [];\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(extensions)) {\n      extensions = extensions.split("|");\n    }\n    for (i = 0; i < configDownloadExtensions.length; i++) {\n      if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.indexOfArray(extensions, configDownloadExtensions[i]) === -1) {\n        newExtensions.push(configDownloadExtensions[i]);\n      }\n    }\n    configDownloadExtensions = newExtensions;\n  };\n\n  /**\n   * Set array of domains to be treated as local. Also supports path, eg \'.eave.org/subsite1\'. In this\n   * case all links that don\'t go to \'*.eave.org/subsite1/ *\' would be treated as outlinks.\n   * For example a link to \'eave.org/\' or \'eave.org/subsite2\' both would be treated as outlinks.\n   *\n   * Also supports page wildcard, eg \'eave.org/index*\'. In this case all links\n   * that don\'t go to eave.org/index* would be treated as outlinks.\n   *\n   * The current domain will be added automatically if no given host alias contains a path and if no host\n   * alias is already given for the current host alias. Say you are on "example.org" and set\n   * "hostAlias = [\'example.com\', \'example.org/test\']" then the current "example.org" domain will not be\n   * added as there is already a more restrictive hostAlias \'example.org/test\' given. We also do not add\n   * it automatically if there was any other host specifying any path like\n   * "[\'example.com\', \'example2.com/test\']". In this case we would also not add the current\n   * domain "example.org" automatically as the "path" feature is used. As soon as someone uses the path\n   * feature, for eave JS Tracker to work correctly in all cases, one needs to specify all hosts\n   * manually.\n   *\n   * @param {string|Array} hostsAlias\n   */\n  this.setDomains = function (hostsAlias) {\n    configHostsAlias = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(hostsAlias) ? [hostsAlias] : hostsAlias;\n\n    var hasDomainAliasAlready = false,\n      i = 0,\n      alias;\n    for (i; i < configHostsAlias.length; i++) {\n      alias = String(configHostsAlias[i]);\n\n      if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isSameHost(domainAlias, _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.domainFixup(alias))) {\n        hasDomainAliasAlready = true;\n        break;\n      }\n\n      var pathName = getPathName(alias);\n      if (pathName && pathName !== "/" && pathName !== "/*") {\n        hasDomainAliasAlready = true;\n        break;\n      }\n    }\n\n    // The current domain will be added automatically if no given host alias contains a path\n    // and if no host alias is already given for the current host alias.\n    if (!hasDomainAliasAlready) {\n      /**\n       * eg if domainAlias = \'eave.org\' and someone set hostsAlias = [\'eave.org/foo\'] then we should\n       * not add eave.org as it would increase the allowed scope.\n       */\n      configHostsAlias.push(domainAlias);\n    }\n  };\n\n  /**\n   * Set array of domains to be excluded as referrer. Also supports path, eg \'.eave.org/subsite1\'. In this\n   * case all referrers that don\'t match \'*.eave.org/subsite1/ *\' would still be used as referrer.\n   * For example \'eave.org/\' or \'eave.org/subsite2\' would both be used as referrer.\n   *\n   * Also supports page wildcard, eg \'eave.org/index*\'. In this case all referrers\n   * that don\'t match eave.org/index* would still be treated as referrer.\n   *\n   * Domains added with setDomains will automatically be excluded as referrers.\n   *\n   * @param {string|Array} excludedReferrers\n   */\n  this.setExcludedReferrers = function (excludedReferrers) {\n    configExcludedReferrers = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(excludedReferrers)\n      ? [excludedReferrers]\n      : excludedReferrers;\n  };\n\n  /**\n   * Enables cross domain linking. By default, the visitor ID that identifies a unique visitor is stored in\n   * the browser\'s first party cookies. This means the cookie can only be accessed by pages on the same domain.\n   * If you own multiple domains and would like to track all the actions and pageviews of a specific visitor\n   * into the same visit, you may enable cross domain linking. Whenever a user clicks on a link it will append\n   * a URL parameter pk_vid to the clicked URL which consists of these parts: 16 char visitorId, a 10 character\n   * current timestamp and the last 6 characters are an id based on the userAgent to identify the users device).\n   * This way the current visitorId is forwarded to the page of the different domain.\n   *\n   * On the different domain, the eave tracker will recognize the set visitorId from the URL parameter and\n   * reuse this parameter if the page was loaded within 45 seconds. If cross domain linking was not enabled,\n   * it would create a new visit on that page because we wouldn\'t be able to access the previously created\n   * cookie. By enabling cross domain linking you can track several different domains into one website and\n   * won\'t lose for example the original referrer.\n   *\n   * To make cross domain linking work you need to set which domains should be considered as your domains by\n   * calling the method "setDomains()" first. We will add the URL parameter to links that go to a\n   * different domain but only if the domain was previously set with "setDomains()" to make sure not to append\n   * the URL parameters when a link actually goes to a third-party URL.\n   */\n  this.enableCrossDomainLinking = function () {\n    crossDomainTrackingEnabled = true;\n  };\n\n  /**\n   * Disable cross domain linking if it was previously enabled. See enableCrossDomainLinking();\n   */\n  this.disableCrossDomainLinking = function () {\n    crossDomainTrackingEnabled = false;\n  };\n\n  /**\n   * Detect whether cross domain linking is enabled or not. See enableCrossDomainLinking();\n   * @returns {boolean}\n   */\n  this.isCrossDomainLinkingEnabled = function () {\n    return crossDomainTrackingEnabled;\n  };\n\n  /**\n   * By default, the two visits across domains will be linked together\n   * when the link is click and the page is loaded within 180 seconds.\n   * @param timeout in seconds\n   */\n  this.setCrossDomainLinkingTimeout = function (timeout) {\n    configVisitorIdUrlParameterTimeoutInSeconds = timeout;\n  };\n\n  /**\n   * Returns the query parameter appended to link URLs so cross domain visits\n   * can be detected.\n   *\n   * If your application creates links dynamically, then you\'ll have to add this\n   * query parameter manually to those links (since the JavaScript tracker cannot\n   * detect when those links are added).\n   *\n   * Eg:\n   *\n   * var url = \'http://myotherdomain.com/?\' + eaveTracker.getCrossDomainLinkingUrlParameter();\n   * $element.append(\'<a href="\' + url + \'"/>\');\n   */\n  this.getCrossDomainLinkingUrlParameter = function () {\n    return (\n      globalThis.eave.encodeWrapper(configVisitorIdUrlParameter) +\n      "=" +\n      globalThis.eave.encodeWrapper(getCrossDomainVisitorId())\n    );\n  };\n\n  /**\n   * Set array of classes to be ignored if present in link\n   *\n   * @param {string|Array} ignoreClasses\n   */\n  this.setIgnoreClasses = function (ignoreClasses) {\n    configIgnoreClasses = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(ignoreClasses)\n      ? [ignoreClasses]\n      : ignoreClasses;\n  };\n\n  /**\n   * Set request method. If you specify GET then it will automatically disable sendBeacon.\n   *\n   * @param {string} method GET or POST; default is GET\n   */\n  this.setRequestMethod = function (method) {\n    if (method) {\n      configRequestMethod = String(method).toUpperCase();\n    } else {\n      configRequestMethod = defaultRequestMethod;\n    }\n\n    if (configRequestMethod === "GET") {\n      // send beacon always sends a POST request so we have to disable it to make GET work\n      this.disableAlwaysUseSendBeacon();\n    }\n  };\n\n  /**\n   * Set request Content-Type header value, applicable when POST request method is used for submitting tracking events.\n   * See XMLHttpRequest Level 2 spec, section 4.7.2 for invalid headers\n   * @link http://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html\n   *\n   * @param {string} requestContentType; default is \'application/x-www-form-urlencoded; charset=UTF-8\'\n   */\n  this.setRequestContentType = function (requestContentType) {\n    configRequestContentType = requestContentType || defaultRequestContentType;\n  };\n\n  /**\n   * Replace setGenerationTimeMs with this more generic function\n   * Use in SPA\n   * @param networkTimeInMs\n   * @param serverTimeInMs\n   * @param transferTimeInMs\n   * @param domProcessingTimeInMs\n   * @param domCompletionTimeInMs\n   * @param onloadTimeInMs\n   */\n  this.setPagePerformanceTiming = function (\n    networkTimeInMs,\n    serverTimeInMs,\n    transferTimeInMs,\n    domProcessingTimeInMs,\n    domCompletionTimeInMs,\n    onloadTimeInMs,\n  ) {\n    /*members pf_net, pf_srv, pf_tfr, pf_dm1, pf_dm2, pf_onl */\n    var data = {\n      pf_net: networkTimeInMs,\n      pf_srv: serverTimeInMs,\n      pf_tfr: transferTimeInMs,\n      pf_dm1: domProcessingTimeInMs,\n      pf_dm2: domCompletionTimeInMs,\n      pf_onl: onloadTimeInMs,\n    };\n\n    try {\n      data = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.filterIn(data, _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined);\n      data = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.onlyPositiveIntegers(data);\n      customPagePerformanceTiming = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.queryStringify(data);\n      if (customPagePerformanceTiming === "") {\n        _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.logConsoleError(\n          "setPagePerformanceTiming() called without parameters. This function needs to be called with at least one performance parameter.",\n        );\n        return;\n      }\n\n      performanceTracked = false; // to ensure the values are sent (again)\n      performanceAvailable = true; // so appendAvailablePerformanceMetrics will be called directly\n      // Otherwise performanceAvailable will be set when the pageload finished, but there is no need\n      // to wait for that, when the values are set manually.\n    } catch (error) {\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.logConsoleError("setPagePerformanceTiming: " + error.toString());\n    }\n  };\n\n  /**\n   * Override referrer\n   *\n   * @param {string} url\n   */\n  this.setReferrerUrl = function (url) {\n    configReferrerUrl = url;\n  };\n\n  /**\n   * Override url\n   *\n   * @param {string} url\n   */\n  this.setCustomUrl = function (url) {\n    configCustomUrl = resolveRelativeReference(locationHrefAlias, url);\n  };\n\n  /**\n   * Returns the current url of the page that is currently being visited. If a custom URL was set, the\n   * previously defined custom URL will be returned.\n   */\n  this.getCurrentUrl = function () {\n    return configCustomUrl || locationHrefAlias;\n  };\n\n  /**\n   * Override document.title\n   *\n   * @param {string} title\n   */\n  this.setDocumentTitle = function (title) {\n    configTitle = title;\n  };\n\n  /**\n   * Override PageView id for every use of logPageView(). Do not use this if you call trackPageView()\n   * multiple times during tracking (if, for example, you are tracking a single page application).\n   *\n   * @param {string} pageView\n   */\n  this.setPageViewId = function (pageView) {\n    configIdPageView = pageView;\n    configIdPageViewSetManually = true;\n  };\n\n  /**\n   * Returns the PageView id. If the id was manually set using setPageViewId(), that id will be returned.\n   * If the id was not set manually, the id that was automatically generated in last trackPageView() will be\n   * returned. If there was no last page view, this will be undefined.\n   *\n   * @returns {string}\n   */\n  this.getPageViewId = function () {\n    return configIdPageView;\n  };\n\n  /**\n   * Set the URL of the eave API. It is used for Page Overlay.\n   * This method should only be called when the API URL differs from the tracker URL.\n   *\n   * @param {string} apiUrl\n   */\n  this.setAPIUrl = function (apiUrl) {\n    configApiUrl = apiUrl;\n  };\n\n  /**\n   * Set array of classes to be treated as downloads\n   *\n   * @param {string|Array} downloadClasses\n   */\n  this.setDownloadClasses = function (downloadClasses) {\n    configDownloadClasses = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(downloadClasses)\n      ? [downloadClasses]\n      : downloadClasses;\n  };\n\n  /**\n   * Set array of classes to be treated as outlinks\n   *\n   * @param {string|Array} linkClasses\n   */\n  this.setLinkClasses = function (linkClasses) {\n    configLinkClasses = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(linkClasses) ? [linkClasses] : linkClasses;\n  };\n\n  /**\n   * Set array of campaign name parameters\n   *\n   * @see https://matomo.org/faq/how-to/faq_120\n   * @param {string|Array} campaignNames\n   */\n  this.setCampaignNameKey = function (campaignNames) {\n    configCampaignNameParameters = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(campaignNames)\n      ? [campaignNames]\n      : campaignNames;\n  };\n\n  /**\n   * Set array of campaign keyword parameters\n   *\n   * @see https://matomo.org/faq/how-to/faq_120\n   * @param {string|Array} campaignKeywords\n   */\n  this.setCampaignKeywordKey = function (campaignKeywords) {\n    configCampaignKeywordParameters = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(campaignKeywords)\n      ? [campaignKeywords]\n      : campaignKeywords;\n  };\n\n  /**\n   * Set an array of query parameters to be excluded if in the url\n   *\n   * @param {string|Array} excludedQueryParams  \'uid\' or [\'uid\', \'sid\']\n   */\n  this.setExcludedQueryParams = function (excludedQueryParams) {\n    configExcludedQueryParams = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString(excludedQueryParams)\n      ? [excludedQueryParams]\n      : excludedQueryParams;\n  };\n\n  /**\n   * Detect if cookies are enabled and supported by browser.\n   */\n  this.hasCookies = function () {\n    return "1" === cookieManager.hasCookies();\n  };\n\n  /**\n   * Get first-party cookie value.\n   *\n   * Returns null if cookies are disabled or if no cookie could be found for this name.\n   *\n   * @param {string} cookieName\n   */\n  this.getCookie = function (cookieName) {\n    var cookieValue = cookieManager.getCookie(\n      cookieManager.getCookieName(cookieName),\n    );\n\n    if (cookieValue === 0) {\n      return null;\n    }\n\n    return cookieValue;\n  };\n\n  /**\n   * Set conversion attribution to first referrer and campaign\n   *\n   * @param {boolean} enable If true, use first referrer (and first campaign)\n   *             if false, use the last referrer (or campaign)\n   */\n  this.setConversionAttributionFirstReferrer = function (enable) {\n    configConversionAttributionFirstReferrer = enable;\n  };\n\n  /**\n   * Disables all cookies from being set\n   *\n   * Existing cookies will be deleted on the next call to track\n   */\n  this.disableCookies = function () {\n    cookieManager.configCookiesDisabled = true;\n\n    if (configTrackerSiteId) {\n      cookieManager.deleteCookies();\n    }\n  };\n\n  /**\n   * Detects if cookies are enabled or not\n   * @returns {boolean}\n   */\n  this.areCookiesEnabled = function () {\n    return !cookieManager.configCookiesDisabled;\n  };\n\n  /**\n   * Enables cookies if they were disabled previously.\n   */\n  this.setCookieConsentGiven = function () {\n    if (cookieManager.configCookiesDisabled && !configDoNotTrack) {\n      cookieManager.configCookiesDisabled = false;\n      if (!configBrowserFeatureDetection) {\n        this.enableBrowserFeatureDetection();\n      }\n      if (configTrackerSiteId && hasSentTrackingRequestYet) {\n        setVisitorId();\n\n        // sets attribution cookie, and updates visitorId in the backend\n        // because hasSentTrackingRequestYet=true we assume there might not be another tracking\n        // request within this page view so we trigger one ourselves.\n        // if no tracking request has been sent yet, we don\'t set the attribution cookie cause eave\n        // sets the cookie only when there is a tracking request. It\'ll be set if the user sends\n        // a tracking request afterwards\n        var request = getRequest("ping=1", null, "ping");\n        sendRequest(request, configTrackerPause);\n      }\n    }\n  };\n\n  /**\n   * Check first-party cookies and update the <code>configHasConsent</code> value.  Ensures that any\n   * change to the user opt-in/out status in another browser window will be respected.\n   */\n  function refreshConsentStatus() {\n    if (cookieManager.getCookie(cookieManager.CONSENT_REMOVED_COOKIE_NAME)) {\n      configHasConsent = false;\n    } else if (cookieManager.getCookie(cookieManager.CONSENT_COOKIE_NAME)) {\n      configHasConsent = true;\n    }\n  }\n\n  /**\n   * When called, no cookies will be set until you have called `setCookieConsentGiven()`\n   * unless consent was given previously AND you called {@link rememberCookieConsentGiven()} when the user\n   * gave consent.\n   *\n   * This may be useful when you want to implement for example a popup to ask for cookie consent.\n   * Once the user has given consent, you should call {@link setCookieConsentGiven()}\n   * or {@link rememberCookieConsentGiven()}.\n   *\n   * If you require tracking consent for example because you are tracking personal data and GDPR applies to you,\n   * then have a look at `_paq.push([\'requireConsent\'])` instead.\n   *\n   * If the user has already given consent in the past, you can either decide to not call `requireCookieConsent` at all\n   * or call `_paq.push([\'setCookieConsentGiven\'])` on each page view at any time after calling `requireCookieConsent`.\n   *\n   * When the user gives you the consent to set cookies, you can also call `_paq.push([\'rememberCookieConsentGiven\', optionalTimeoutInHours])`\n   * and for the duration while the cookie consent is remembered, any call to `requireCoookieConsent` will be automatically ignored\n   * until you call `forgetCookieConsentGiven`.\n   * `forgetCookieConsentGiven` needs to be called when the user removes consent for using cookies. This means if you call `rememberCookieConsentGiven` at the\n   * time the user gives you consent, you do not need to ever call `_paq.push([\'setCookieConsentGiven\'])` as the consent\n   * will be detected automatically through cookies.\n   */\n  this.requireCookieConsent = function () {\n    if (this.getRememberedCookieConsent()) {\n      return false;\n    }\n    this.disableCookies();\n    return true;\n  };\n\n  /**\n   * If the user has given cookie consent previously and this consent was remembered, it will return the number\n   * in milliseconds since 1970/01/01 which is the date when the user has given cookie consent. Please note that\n   * the returned time depends on the users local time which may not always be correct.\n   *\n   * @returns {number|string}\n   */\n  this.getRememberedCookieConsent = function () {\n    return cookieManager.getCookie(cookieManager.COOKIE_CONSENT_COOKIE_NAME);\n  };\n\n  /**\n   * Calling this method will remove any previously given cookie consent and it disables cookies for subsequent\n   * page views. You may call this method if the user removes cookie consent manually, or if you\n   * want to re-ask for cookie consent after a specific time period.\n   */\n  this.forgetCookieConsentGiven = function () {\n    cookieManager.deleteCookie(\n      cookieManager.COOKIE_CONSENT_COOKIE_NAME,\n      cookieManager.configCookiePath,\n      cookieManager.configCookieDomain,\n    );\n    this.disableCookies();\n  };\n\n  /**\n   * Calling this method will remember that the user has given cookie consent across multiple requests by setting\n   * a cookie named "mtm_cookie_consent". You can optionally define the lifetime of that cookie in hours\n   * using a parameter.\n   *\n   * When you call this method, we imply that the user has given cookie consent for this page view, and will also\n   * imply consent for all future page views unless the cookie expires or the user\n   * deletes all their cookies. Remembering cookie consent means even if you call {@link disableCookies()},\n   * then cookies will still be enabled and it won\'t disable cookies since the user has given consent for cookies.\n   *\n   * Please note that this feature requires you to set the `cookieDomain` and `cookiePath` correctly. Please\n   * also note that when you call this method, consent will be implied for all sites that match the configured\n   * cookieDomain and cookiePath. Depending on your website structure, you may need to restrict or widen the\n   * scope of the cookie domain/path to ensure the consent is applied to the sites you want.\n   *\n   * @param {int} hoursToExpire After how many hours the cookie consent should expire. By default the consent is valid\n   *                          for 30 years unless cookies are deleted by the user or the browser prior to this\n   */\n  this.rememberCookieConsentGiven = function (hoursToExpire) {\n    if (hoursToExpire) {\n      // convert hours to ms\n      hoursToExpire = hoursToExpire * 60 * 60 * 1000;\n    } else {\n      // 30 years ms\n      hoursToExpire = 30 * 365 * 24 * 60 * 60 * 1000;\n    }\n    this.setCookieConsentGiven();\n    var now = new Date().getTime();\n    cookieManager.setCookie(\n      cookieManager.COOKIE_CONSENT_COOKIE_NAME,\n      now,\n      hoursToExpire,\n      cookieManager.configCookiePath,\n      cookieManager.configCookieDomain,\n      cookieManager.configCookieIsSecure,\n      cookieManager.configCookieSameSite,\n    );\n  };\n\n  /**\n   * One off cookies clearing. Useful to call this when you know for sure a new visitor is using the same browser,\n   * it maybe helps to "reset" tracking cookies to prevent data reuse for different users.\n   */\n  this.deleteCookies = function () {\n    cookieManager.deleteCookies();\n  };\n\n  /**\n   * Handle do-not-track requests\n   *\n   * @param {boolean} enable If true, don\'t track if user agent sends \'do-not-track\' header\n   */\n  this.setDoNotTrack = function (enable) {\n    var dnt =\n      globalThis.eave.navigatorAlias.doNotTrack ||\n      globalThis.eave.navigatorAlias.msDoNotTrack;\n    configDoNotTrack = enable && (dnt === "yes" || dnt === "1");\n\n    // do not track also disables cookies and deletes existing cookies\n    if (configDoNotTrack) {\n      this.disableCookies();\n    }\n  };\n\n  /**\n   * Prevent campaign parameters being sent to the tracker, unless consent given.\n   */\n  this.disableCampaignParameters = function () {\n    configEnableCampaignParameters = false;\n  };\n\n  /**\n   * Allow campaign parameters to be sent to the tracker.\n   */\n  this.enableCampaignParameters = function () {\n    configEnableCampaignParameters = true;\n  };\n\n  /**\n   * Enables send beacon usage instead of regular XHR which reduces the link tracking time to a minimum\n   * of 100ms instead of 500ms (default). This means when a user clicks for example on an outlink, the\n   * navigation to this page will happen 400ms faster.\n   * In case you are setting a callback method when issuing a tracking request, the callback method will\n   *  be executed as soon as the tracking request was sent through "sendBeacon" and not after the tracking\n   *  request finished as it is not possible to find out when the request finished.\n   * Send beacon will only be used if the browser actually supports it.\n   */\n  this.alwaysUseSendBeacon = function () {\n    configAlwaysUseSendBeacon = true;\n  };\n\n  /**\n   * Disables send beacon usage instead and instead enables using regular XHR when possible. This makes\n   * callbacks work and also tracking requests will appear in the browser developer tools console.\n   */\n  this.disableAlwaysUseSendBeacon = function () {\n    configAlwaysUseSendBeacon = false;\n  };\n\n  /**\n   * Add click listener to a specific link element.\n   * When clicked, eave will log the click automatically.\n   *\n   * @param {Element} element\n   * @param {boolean} enable If false, do not use pseudo click-handler (middle click + context menu)\n   */\n  this.addListener = function (element, enable) {\n    addClickListener(element, enable, false);\n  };\n\n  /**\n   * Install link tracker.\n   *\n   * If you change the DOM of your website or web application eave will automatically detect links\n   * that were added newly.\n   *\n   * The default behaviour is to use actual click events. However, some browsers\n   * (e.g., Firefox, Opera, and Konqueror) don\'t generate click events for the middle mouse button.\n   *\n   * To capture more "clicks", the pseudo click-handler uses mousedown + mouseup events.\n   * This is not industry standard and is vulnerable to false positives (e.g., drag events).\n   *\n   * There is a Safari/Chrome/Webkit bug that prevents tracking requests from being sent\n   * by either click handler.  The workaround is to set a target attribute (which can\'t\n   * be "_self", "_top", or "_parent").\n   *\n   * @see https://bugs.webkit.org/show_bug.cgi?id=54783\n   *\n   * @param {boolean} enable Defaults to true.\n   *                    * If "true", use pseudo click-handler (treat middle click and open contextmenu as\n   *                    left click). A right click (or any click that opens the context menu) on a link\n   *                    will be tracked as clicked even if "Open in new tab" is not selected.\n   *                    * If "false" (default), nothing will be tracked on open context menu or middle click.\n   *                    The context menu is usually opened to open a link / download in a new tab\n   *                    therefore you can get more accurate results by treat it as a click but it can lead\n   *                    to wrong click numbers.\n   */\n  this.enableLinkTracking = function (enable) {\n    if (linkTrackingEnabled) {\n      return;\n    }\n    linkTrackingEnabled = true;\n\n    var self = this;\n\n    if (!clickListenerInstalled) {\n      clickListenerInstalled = true;\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trackCallbackOnReady(function () {\n        var element = globalThis.eave.documentAlias.body;\n        addClickListener(element, enable, true);\n      });\n    }\n  };\n\n  /**\n   * Track button element clicks\n   */\n  this.enableButtonClickTracking = function (enable) {\n    if (buttonClickTrackingEnabled) {\n      return;\n    }\n    buttonClickTrackingEnabled = true;\n\n    if (!clickListenerInstalled) {\n      clickListenerInstalled = true;\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trackCallbackOnReady(function () {\n        var element = globalThis.eave.documentAlias.body;\n        addClickListener(element, enable, true);\n      });\n    }\n  };\n\n  /**\n   * Tracks route-change history for single page applications, since\n   * normal page view events aren\'t triggered for navigation without a GET request.\n   *\n   * @param {boolean} enable Whether to allow tracking route history. Defaults to true.\n   */\n  this.enableRouteHistoryTracking = function (enable) {\n    if (routeHistoryTrackingEnabled) {\n      return;\n    }\n    routeHistoryTrackingEnabled = true;\n\n    function getCurrentUrl() {\n      return globalThis.eave.windowAlias.location.href;\n    }\n    function getEventUrl(event) {\n      if (\n        event &&\n        event.target &&\n        event.target.location &&\n        event.target.location.href\n      ) {\n        return event.target.location.href;\n      }\n      return getCurrentUrl();\n    }\n    function parseUrl(urlToParse, urlPart) {\n      try {\n        var loc = globalThis.eave.documentAlias.createElement("a");\n        loc.href = urlToParse;\n        var absUrl = loc.href;\n\n        // needed to make tests work in IE10... we first need to convert URL to abs url\n        loc = globalThis.eave.documentAlias.createElement("a");\n        loc.href = absUrl;\n\n        if (urlPart && urlPart in loc) {\n          if ("hash" === urlPart) {\n            return String(loc[urlPart]).replace("#", "");\n          } else if ("protocol" === urlPart) {\n            return String(loc[urlPart]).replace(":", "");\n          } else if ("search" === urlPart) {\n            return String(loc[urlPart]).replace("?", "");\n          } else if ("port" === urlPart && !loc[urlPart]) {\n            if (loc.protocol === "https:") {\n              return "443";\n            } else if (loc.protocol === "http:") {\n              return "80";\n            }\n          }\n\n          if (\n            "pathname" === urlPart &&\n            loc[urlPart] &&\n            String(loc[urlPart]).substr(0, 1) !== "/"\n          ) {\n            return "/" + loc[urlPart]; // ie 10 doesn\'t return leading slash when not added to the dom\n          }\n\n          if ("port" === urlPart && loc[urlPart]) {\n            return String(loc[urlPart]); // ie 10 returns int\n          }\n\n          return loc[urlPart];\n        }\n\n        if ("origin" === urlPart && "protocol" in loc && loc.protocol) {\n          // fix for ie10\n          return (\n            loc.protocol +\n            "//" +\n            loc.hostname +\n            (loc.port ? ":" + loc.port : "")\n          );\n        }\n        return;\n      } catch (e) {\n        if ("function" === typeof URL) {\n          var theUrl = new URL(urlToParse);\n          if (urlPart && urlPart in theUrl) {\n            if ("hash" === urlPart) {\n              return String(theUrl[urlPart]).replace("#", "");\n            } else if ("protocol" === urlPart) {\n              return String(theUrl[urlPart]).replace(":", "");\n            } else if ("search" === urlPart) {\n              return String(theUrl[urlPart]).replace("?", "");\n            } else if ("port" === urlPart && !theUrl[urlPart]) {\n              if (theUrl.protocol === "https:") {\n                return "443";\n              } else if (theUrl.protocol === "http:") {\n                return "80";\n              }\n            }\n            return theUrl[urlPart];\n          }\n          return;\n        }\n      }\n    }\n\n    _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trackCallbackOnReady(function () {\n      var initialUrl = getCurrentUrl();\n      var origin = parseUrl(initialUrl, "origin");\n\n      var lastEvent = {\n        eventType: null,\n        hash: parseUrl(initialUrl, "hash"),\n        search: parseUrl(initialUrl, "search"),\n        path: parseUrl(initialUrl, "pathname"),\n        state: globalThis.eave.windowAlias.state || null,\n      };\n\n      function trigger(eventType, newUrl, newState) {\n        var newEvent = {\n          eventType: eventType,\n          hash: parseUrl(newUrl, "hash"),\n          search: parseUrl(newUrl, "search"),\n          path: parseUrl(newUrl, "pathname"),\n          state: newState,\n        };\n\n        var shouldForceEvent =\n          (lastEvent.eventType === "popstate" &&\n            newEvent.eventType === "hashchange") ||\n          (lastEvent.eventType === "hashchange" &&\n            newEvent.eventType === "popstate") ||\n          (lastEvent.eventType === "hashchange" &&\n            newEvent.eventType === "hashchange") ||\n          (lastEvent.eventType === "popstate" &&\n            newEvent.eventType === "popstate");\n        shouldForceEvent = !shouldForceEvent;\n\n        var oldUrl = lastEvent.path;\n        if (lastEvent.search) {\n          oldUrl += "?" + lastEvent.search;\n        }\n        if (lastEvent.hash) {\n          oldUrl += "#" + lastEvent.hash;\n        }\n        var nowUrl = newEvent.path;\n        if (newEvent.search) {\n          nowUrl += "?" + newEvent.search;\n        }\n        if (newEvent.hash) {\n          nowUrl += "#" + newEvent.hash;\n        }\n        if (shouldForceEvent || oldUrl !== nowUrl) {\n          var tmpLast = lastEvent;\n          lastEvent = newEvent; // overwrite as early as possible in case event gets triggered again\n\n          trackCallback(function () {\n            logPageView(\n              {},\n              {\n                event: "mtm.HistoryChange",\n                "mtm.historyChangeSource": newEvent.eventType,\n                "mtm.oldUrl": origin + oldUrl,\n                "mtm.newUrl": origin + nowUrl,\n                "mtm.oldUrlHash": tmpLast.hash,\n                "mtm.newUrlHash": newEvent.hash,\n                "mtm.oldUrlPath": tmpLast.path,\n                "mtm.newUrlPath": newEvent.path,\n                "mtm.oldUrlSearch": tmpLast.search,\n                "mtm.newUrlSearch": newEvent.search,\n                "mtm.oldHistoryState": tmpLast.state,\n                "mtm.newHistoryState": newEvent.state,\n              },\n              null,\n            );\n          });\n        }\n      }\n      function setMethodWrapIfNeeded(\n        contextObject,\n        methodNameToReplace,\n        callback,\n      ) {\n        if (!(methodNameToReplace in contextObject)) {\n          contextObject[methodNameToReplace] = callback;\n          return;\n        }\n\n        var oldMethodBackup = contextObject[methodNameToReplace];\n\n        if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction(oldMethodBackup)) {\n          contextObject[methodNameToReplace] = callback;\n          return;\n        }\n\n        try {\n          contextObject[methodNameToReplace] = function () {\n            try {\n              var value = oldMethodBackup.apply(\n                contextObject,\n                [].slice.call(arguments, 0),\n              );\n            } catch (e) {\n              callback.apply(contextObject, [].slice.call(arguments, 0));\n              throw e;\n            }\n            callback.apply(contextObject, [].slice.call(arguments, 0));\n            return value;\n          };\n        } catch (ignore) {}\n      }\n\n      function replaceHistoryMethod(methodNameToReplace) {\n        setMethodWrapIfNeeded(\n          globalThis.eave.windowAlias.history,\n          methodNameToReplace,\n          function (state, title, urlParam) {\n            trigger(methodNameToReplace, getCurrentUrl(), state);\n          },\n        );\n      }\n\n      replaceHistoryMethod("replaceState");\n      replaceHistoryMethod("pushState");\n\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addEventListener(\n        globalThis.eave.windowAlias,\n        "hashchange",\n        function (event) {\n          var newUrl = getEventUrl(event);\n          trigger("hashchange", newUrl, null);\n        },\n        false,\n      );\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addEventListener(\n        globalThis.eave.windowAlias,\n        "popstate",\n        function (event) {\n          var newUrl = getEventUrl(event);\n          trigger("popstate", newUrl, event.state);\n        },\n        false,\n      );\n    });\n  };\n\n  /**\n   * Enable tracking of uncatched JavaScript errors\n   *\n   * If enabled, uncaught JavaScript Errors will be tracked as an event by defining a\n   * window.onerror handler. If a window.onerror handler is already defined we will make\n   * sure to call this previously registered error handler after tracking the error.\n   *\n   * By default we return false in the window.onerror handler to make sure the error still\n   * appears in the browser\'s console etc. Note: Some older browsers might behave differently\n   * so it could happen that an actual JavaScript error will be suppressed.\n   * If a window.onerror handler was registered we will return the result of this handler.\n   *\n   * Make sure not to overwrite the window.onerror handler after enabling the JS error\n   * tracking as the error tracking won\'t work otherwise. To capture all JS errors we\n   * recommend to include the eave JavaScript tracker in the HTML as early as possible.\n   * If possible directly in <head></head> before loading any other JavaScript.\n   */\n  this.enableJSErrorTracking = function () {\n    if (enableJSErrorTracking) {\n      return;\n    }\n\n    enableJSErrorTracking = true;\n    var onError = globalThis.eave.windowAlias.onerror;\n\n    globalThis.eave.windowAlias.onerror = function (\n      message,\n      url,\n      linenumber,\n      column,\n      error,\n    ) {\n      trackCallback(function () {\n        var category = "JavaScript Errors";\n\n        var action = url + ":" + linenumber;\n        if (column) {\n          action += ":" + column;\n        }\n\n        if (\n          _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.indexOfArray(javaScriptErrors, category + action + message) === -1\n        ) {\n          javaScriptErrors.push(category + action + message);\n\n          logEvent(category, action, message);\n        }\n      });\n\n      if (onError) {\n        return onError(message, url, linenumber, column, error);\n      }\n\n      return false;\n    };\n  };\n\n  /**\n   * Disable automatic performance tracking\n   */\n  this.disablePerformanceTracking = function () {\n    configPerformanceTrackingEnabled = false;\n  };\n\n  /**\n   * Set heartbeat (in seconds)\n   *\n   * @param {int} heartBeatDelayInSeconds Defaults to 15s. Cannot be lower than 5.\n   */\n  this.enableHeartBeatTimer = function (heartBeatDelayInSeconds) {\n    heartBeatDelayInSeconds = Math.max(heartBeatDelayInSeconds || 15, 5);\n    configHeartBeatDelay = heartBeatDelayInSeconds * 1000;\n\n    // if a tracking request has already been sent, start the heart beat timeout\n    if (lastTrackerRequestTime !== null) {\n      setUpHeartBeat();\n    }\n  };\n\n  /**\n   * Disable heartbeat if it was previously activated.\n   */\n  this.disableHeartBeatTimer = function () {\n    if (configHeartBeatDelay || heartBeatSetUp) {\n      if (globalThis.eave.windowAlias.removeEventListener) {\n        globalThis.eave.windowAlias.removeEventListener(\n          "focus",\n          heartBeatOnFocus,\n        );\n        globalThis.eave.windowAlias.removeEventListener(\n          "blur",\n          heartBeatOnBlur,\n        );\n        globalThis.eave.windowAlias.removeEventListener(\n          "visibilitychange",\n          heartBeatOnVisible,\n        );\n      } else if (globalThis.eave.windowAlias.detachEvent) {\n        globalThis.eave.windowAlias.detachEvent("onfocus", heartBeatOnFocus);\n        globalThis.eave.windowAlias.detachEvent("onblur", heartBeatOnBlur);\n        globalThis.eave.windowAlias.detachEvent(\n          "visibilitychange",\n          heartBeatOnVisible,\n        );\n      }\n    }\n\n    configHeartBeatDelay = null;\n    heartBeatSetUp = false;\n  };\n\n  /**\n   * Frame buster\n   */\n  this.killFrame = function () {\n    if (\n      globalThis.eave.windowAlias.location !==\n      globalThis.eave.windowAlias.top.location\n    ) {\n      globalThis.eave.windowAlias.top.location =\n        globalThis.eave.windowAlias.location;\n    }\n  };\n\n  /**\n   * Redirect if browsing offline (aka file: buster)\n   *\n   * @param {string} url Redirect to this URL\n   */\n  this.redirectFile = function (url) {\n    if (globalThis.eave.windowAlias.location.protocol === "file:") {\n      globalThis.eave.windowAlias.location = url;\n    }\n  };\n\n  /**\n   * Count sites in pre-rendered state\n   *\n   * @param {boolean} enable If true, track when in pre-rendered state\n   */\n  this.setCountPreRendered = function (enable) {\n    configCountPreRendered = enable;\n  };\n\n  /**\n   * Trigger a goal\n   *\n   * @param {int|string} idGoal\n   * @param {int|float} customRevenue\n   * @param {*} customData\n   * @param {Function} callback\n   */\n  this.trackGoal = function (idGoal, customRevenue, customData, callback) {\n    trackCallback(function () {\n      logGoal(idGoal, customRevenue, customData, callback);\n    });\n  };\n\n  /**\n   * Manually log a click from your own code\n   *\n   * @param {string} sourceUrl\n   * @param {string} linkType\n   * @param {*} customData\n   * @param {Function} callback\n   */\n  this.trackLink = function (sourceUrl, linkType, customData, callback) {\n    trackCallback(function () {\n      logLink(sourceUrl, linkType, customData, callback);\n    });\n  };\n\n  /**\n   * Get the number of page views that have been tracked so far within the currently loaded page.\n   */\n  this.getNumTrackedPageViews = function () {\n    return numTrackedPageviews;\n  };\n\n  /**\n   * Log visit to this page\n   *\n   * @param {string} customTitle\n   * @param {*} customData\n   * @param {Function} callback\n   */\n  this.trackPageView = function (customTitle, customData, callback) {\n    trackedContentImpressions = [];\n    consentRequestsQueue = [];\n    javaScriptErrors = [];\n\n    trackCallback(function () {\n      numTrackedPageviews++;\n      logPageView(customTitle, customData, callback);\n    });\n  };\n\n  this.disableBrowserFeatureDetection = function () {\n    configBrowserFeatureDetection = false;\n    browserFeatures = {};\n    if (supportsClientHints()) {\n      // ensure already queue requests are still processed\n      processClientHintsQueue();\n    }\n  };\n\n  this.enableBrowserFeatureDetection = function () {\n    configBrowserFeatureDetection = true;\n    detectBrowserFeatures();\n  };\n\n  /**\n   * Scans the entire DOM for all content blocks and tracks all impressions once the DOM ready event has\n   * been triggered.\n   *\n   * If you only want to track visible content impressions have a look at `trackVisibleContentImpressions()`.\n   * We do not track an impression of the same content block twice if you call this method multiple times\n   * unless `trackPageView()` is called meanwhile. This is useful for single page applications.\n   */\n  this.trackAllContentImpressions = function () {\n    trackCallback(function () {\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trackCallbackOnReady(function () {\n        // we have to wait till DOM ready\n        var contentNodes = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].findContentNodes();\n        var requests = getContentImpressionsRequestsFromNodes(contentNodes);\n\n        requestQueue.pushMultiple(requests);\n      });\n    });\n  };\n\n  /**\n   * Scans the entire DOM for all content blocks as soon as the page is loaded. It tracks an impression\n   * only if a content block is actually visible. Meaning it is not hidden and the content is or was at\n   * some point in the viewport.\n   *\n   * If you want to track all content blocks have a look at `trackAllContentImpressions()`.\n   * We do not track an impression of the same content block twice if you call this method multiple times\n   * unless `trackPageView()` is called meanwhile. This is useful for single page applications.\n   *\n   * Once you have called this method you can no longer change `checkOnScroll` or `timeIntervalInMs`.\n   *\n   * If you do want to only track visible content blocks but not want us to perform any automatic checks\n   * as they can slow down your frames per second you can call `trackVisibleContentImpressions()` or\n   * `trackContentImpressionsWithinNode()` manually at  any time to rescan the entire DOM for newly\n   * visible content blocks.\n   * o Call `trackVisibleContentImpressions(false, 0)` to initially track only visible content impressions\n   * o Call `trackVisibleContentImpressions()` at any time again to rescan the entire DOM for newly visible content blocks or\n   * o Call `trackContentImpressionsWithinNode(node)` at any time to rescan only a part of the DOM for newly visible content blocks\n   *\n   * @param {boolean} [checkOnScroll=true] Optional, you can disable rescanning the entire DOM automatically\n   *                                     after each scroll event by passing the value `false`. If enabled,\n   *                                     we check whether a previously hidden content blocks became visible\n   *                                     after a scroll and if so track the impression.\n   *                                     Note: If a content block is placed within a scrollable element\n   *                                     (`overflow: scroll`), we can currently not detect when this block\n   *                                     becomes visible.\n   * @param {int} [timeIntervalInMs=750] Optional, you can define an interval to rescan the entire DOM\n   *                                     for new impressions every X milliseconds by passing\n   *                                     for instance `timeIntervalInMs=500` (rescan DOM every 500ms).\n   *                                     Rescanning the entire DOM and detecting the visible state of content\n   *                                     blocks can take a while depending on the browser and amount of content.\n   *                                     In case your frames per second goes down you might want to increase\n   *                                     this value or disable it by passing the value `0`.\n   */\n  this.trackVisibleContentImpressions = function (\n    checkOnScroll,\n    timeIntervalInMs,\n  ) {\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(checkOnScroll)) {\n      checkOnScroll = true;\n    }\n\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(timeIntervalInMs)) {\n      timeIntervalInMs = 750;\n    }\n\n    enableTrackOnlyVisibleContent(checkOnScroll, timeIntervalInMs, this);\n\n    trackCallback(function () {\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trackCallbackOnLoad(function () {\n        // we have to wait till CSS parsed and applied\n        var contentNodes = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].findContentNodes();\n        var requests =\n          getCurrentlyVisibleContentImpressionsRequestsIfNotTrackedYet(\n            contentNodes,\n          );\n\n        requestQueue.pushMultiple(requests);\n      });\n    });\n  };\n\n  /**\n   * Tracks a content impression using the specified values. You should not call this method too often\n   * as each call causes an XHR tracking request and can slow down your site or your server.\n   *\n   * @param {string} contentName  For instance "Ad Sale".\n   * @param {string} [contentPiece=\'Unknown\'] For instance a path to an image or the text of a text ad.\n   * @param {string} [contentTarget] For instance the URL of a landing page.\n   */\n  this.trackContentImpression = function (\n    contentName,\n    contentPiece,\n    contentTarget,\n  ) {\n    contentName = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trim(contentName);\n    contentPiece = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trim(contentPiece);\n    contentTarget = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trim(contentTarget);\n\n    if (!contentName) {\n      return;\n    }\n\n    contentPiece = contentPiece || "Unknown";\n\n    trackCallback(function () {\n      var request = buildContentImpressionRequest(\n        contentName,\n        contentPiece,\n        contentTarget,\n      );\n      requestQueue.push(request);\n    });\n  };\n\n  /**\n   * Scans the given DOM node and its children for content blocks and tracks an impression for them if\n   * no impression was already tracked for it. If you have called `trackVisibleContentImpressions()`\n   * upfront only visible content blocks will be tracked. You can use this method if you, for instance,\n   * dynamically add an element using JavaScript to your DOM after we have tracked the initial impressions.\n   *\n   * @param {Element} domNode\n   */\n  this.trackContentImpressionsWithinNode = function (domNode) {\n    trackCallback(function () {\n      if (isTrackOnlyVisibleContentEnabled) {\n        _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trackCallbackOnLoad(function () {\n          // we have to wait till CSS parsed and applied\n          var contentNodes = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].findContentNodesWithinNode(domNode);\n\n          var requests =\n            getCurrentlyVisibleContentImpressionsRequestsIfNotTrackedYet(\n              contentNodes,\n            );\n          requestQueue.pushMultiple(requests);\n        });\n      } else {\n        _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trackCallbackOnReady(function () {\n          // we have to wait till DOM ready\n          var contentNodes = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].findContentNodesWithinNode(domNode);\n\n          var requests = getContentImpressionsRequestsFromNodes(contentNodes);\n          requestQueue.pushMultiple(requests);\n        });\n      }\n    });\n  };\n\n  /**\n   * Tracks a content interaction using the specified values. You should use this method only in conjunction\n   * with `trackContentImpression()`. The specified `contentName` and `contentPiece` has to be exactly the\n   * same as the ones that were used in `trackContentImpression()`. Otherwise the interaction will not count.\n   *\n   * @param {string} contentInteraction The type of interaction that happened. For instance \'click\' or \'submit\'.\n   * @param {string} contentName  The name of the content. For instance "Ad Sale".\n   * @param {string} [contentPiece=\'Unknown\'] The actual content. For instance a path to an image or the text of a text ad.\n   * @param {string} [contentTarget] For instance the URL of a landing page.\n   */\n  this.trackContentInteraction = function (\n    contentInteraction,\n    contentName,\n    contentPiece,\n    contentTarget,\n  ) {\n    contentInteraction = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trim(contentInteraction);\n    contentName = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trim(contentName);\n    contentPiece = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trim(contentPiece);\n    contentTarget = _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trim(contentTarget);\n\n    if (!contentInteraction || !contentName) {\n      return;\n    }\n\n    contentPiece = contentPiece || "Unknown";\n\n    trackCallback(function () {\n      var request = buildContentInteractionRequest(\n        contentInteraction,\n        contentName,\n        contentPiece,\n        contentTarget,\n      );\n      if (request) {\n        requestQueue.push(request);\n      }\n    });\n  };\n\n  /**\n   * Tracks an interaction with the given DOM node / content block.\n   *\n   * By default we track interactions on click but sometimes you might want to track interactions yourself.\n   * For instance you might want to track an interaction manually on a double click or a form submit.\n   * Make sure to disable the automatic interaction tracking in this case by specifying either the CSS\n   * class `eaveContentIgnoreInteraction` or the attribute `data-content-ignoreinteraction`.\n   *\n   * @param {Element} domNode  This element itself or any of its parent elements has to be a content block\n   *                         element. Meaning one of those has to have a `eaveTrackContent` CSS class or\n   *                         a `data-track-content` attribute.\n   * @param {string} [contentInteraction=\'Unknown] The name of the interaction that happened. For instance\n   *                                             \'click\', \'formSubmit\', \'DblClick\', ...\n   */\n  this.trackContentInteractionNode = function (domNode, contentInteraction) {\n    var theRequest = null;\n\n    trackCallback(function () {\n      theRequest = buildContentInteractionRequestNode(\n        domNode,\n        contentInteraction,\n      );\n      if (theRequest) {\n        requestQueue.push(theRequest);\n      }\n    });\n    //note: return value is only for tests... will only work if dom is already ready...\n    return theRequest;\n  };\n\n  /**\n   * Useful to debug content tracking. This method will log all detected content blocks to console\n   * (if the browser supports the console). It will list the detected name, piece, and target of each\n   * content block.\n   */\n  this.logAllContentBlocksOnPage = function () {\n    var contentNodes = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].findContentNodes();\n    var contents = _content_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].collectContent(contentNodes);\n\n    // needed to write it this way for jslint\n    var consoleType = typeof console;\n    if (consoleType !== "undefined" && console && console.log) {\n      console.log(contents);\n    }\n  };\n\n  /**\n   * Records an event\n   *\n   * @param {string} category The Event Category (Videos, Music, Games...)\n   * @param {string} action The Event\'s Action (Play, Pause, Duration, Add Playlist, Downloaded, Clicked...)\n   * @param {string} name (optional) The Event\'s object Name (a particular Movie name, or Song name, or File name...)\n   * @param {float} value (optional) The Event\'s value\n   * @param {Function} callback\n   * @param {*} customData\n   */\n  this.trackEvent = function (\n    category,\n    action,\n    name,\n    value,\n    customData,\n    callback,\n  ) {\n    trackCallback(function () {\n      logEvent(category, action, name, value, customData, callback);\n    });\n  };\n\n  /**\n   * Log special pageview: Internal search\n   *\n   * @param {string} keyword\n   * @param {string} category\n   * @param {int} resultsCount\n   * @param {*} customData\n   */\n  this.trackSiteSearch = function (\n    keyword,\n    category,\n    resultsCount,\n    customData,\n  ) {\n    trackedContentImpressions = [];\n    trackCallback(function () {\n      logSiteSearch(keyword, category, resultsCount, customData);\n    });\n  };\n\n  /**\n   * Used to record that the current page view is an item (product) page view, or a Ecommerce Category page view.\n   * This must be called before trackPageView() on the product/category page.\n   *\n   * On a category page, you can set the parameter category, and set the other parameters to empty string or false\n   *\n   * Tracking Product/Category page views will allow eave to report on Product & Categories\n   * conversion rates (Conversion rate = Ecommerce orders containing this product or category / Visits to the product or category)\n   *\n   * @param {string} sku Item\'s SKU code being viewed\n   * @param {string} name Item\'s Name being viewed\n   * @param {string} category Category page being viewed. On an Item\'s page, this is the item\'s category\n   * @param {float} price Item\'s display price, not use in standard eave reports, but output in API product reports.\n   */\n  this.setEcommerceView = function (sku, name, category, price) {\n    ecommerceProductView = {};\n\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumberOrHasLength(category)) {\n      category = String(category);\n    }\n    if (\n      !_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(category) ||\n      category === null ||\n      category === false ||\n      !category.length\n    ) {\n      category = "";\n    } else if (category instanceof Array) {\n      category = globalThis.eave.windowAlias.JSON.stringify(category);\n    }\n\n    var param = "_pkc";\n    ecommerceProductView[param] = category;\n\n    if (\n      _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(price) &&\n      price !== null &&\n      price !== false &&\n      String(price).length\n    ) {\n      param = "_pkp";\n      ecommerceProductView[param] = price;\n    }\n\n    // On a category page, do not track Product name not defined\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumberOrHasLength(sku) && !_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumberOrHasLength(name)) {\n      return;\n    }\n\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumberOrHasLength(sku)) {\n      param = "_pks";\n      ecommerceProductView[param] = sku;\n    }\n\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumberOrHasLength(name)) {\n      name = "";\n    }\n\n    param = "_pkn";\n    ecommerceProductView[param] = name;\n  };\n\n  /**\n   * Returns the list of ecommerce items that will be sent when a cart update or order is tracked.\n   * The returned value is read-only, modifications will not change what will be tracked. Use\n   * addEcommerceItem/removeEcommerceItem/clearEcommerceCart to modify what items will be tracked.\n   *\n   * Note: the cart will be cleared after an order.\n   *\n   * @returns {Array}\n   */\n  this.getEcommerceItems = function () {\n    return globalThis.eave.windowAlias.JSON.parse(\n      globalThis.eave.windowAlias.JSON.stringify(ecommerceItems),\n    );\n  };\n\n  /**\n   * Adds an item (product) that is in the current Cart or in the Ecommerce order.\n   * This function is called for every item (product) in the Cart or the Order.\n   * The only required parameter is sku.\n   * The items are deleted from this JavaScript object when the Ecommerce order is tracked via the method trackEcommerceOrder.\n   *\n   * If there is already a saved item for the given sku, it will be updated with the\n   * new information.\n   *\n   * @param {string} sku (required) Item\'s SKU Code. This is the unique identifier for the product.\n   * @param {string} name (optional) Item\'s name\n   * @param {string} category (optional) Item\'s category, or array of up to 5 categories\n   * @param {float} price (optional) Item\'s price. If not specified, will default to 0\n   * @param {float} quantity (optional) Item\'s quantity. If not specified, will default to 1\n   */\n  this.addEcommerceItem = function (sku, name, category, price, quantity) {\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumberOrHasLength(sku)) {\n      ecommerceItems[sku] = [String(sku), name, category, price, quantity];\n    }\n  };\n\n  /**\n   * Removes a single ecommerce item by SKU from the current cart.\n   *\n   * @param {string} sku (required) Item\'s SKU Code. This is the unique identifier for the product.\n   */\n  this.removeEcommerceItem = function (sku) {\n    if (_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumberOrHasLength(sku)) {\n      sku = String(sku);\n      delete ecommerceItems[sku];\n    }\n  };\n\n  /**\n   * Clears the current cart, removing all saved ecommerce items. Call this method to manually clear\n   * the cart before sending an ecommerce order.\n   */\n  this.clearEcommerceCart = function () {\n    ecommerceItems = {};\n  };\n\n  /**\n   * Tracks an Ecommerce order.\n   * If the Ecommerce order contains items (products), you must call first the addEcommerceItem() for each item in the order.\n   * All revenues (grandTotal, subTotal, tax, shipping, discount) will be individually summed and reported in eave reports.\n   * Parameters orderId and grandTotal are required. For others, you can set to false if you don\'t need to specify them.\n   * After calling this method, items added to the cart will be removed from this JavaScript object.\n   *\n   * @param {string|int} orderId (required) Unique Order ID.\n   *                   This will be used to count this order only once in the event the order page is reloaded several times.\n   *                   orderId must be unique for each transaction, even on different days, or the transaction will not be recorded by eave.\n   * @param {float} grandTotal (required) Grand Total revenue of the transaction (including tax, shipping, etc.)\n   * @param {float} subTotal (optional) Sub total amount, typically the sum of items prices for all items in this order (before Tax and Shipping costs are applied)\n   * @param {float} tax (optional) Tax amount for this order\n   * @param {float} shipping (optional) Shipping amount for this order\n   * @param {float} discount (optional) Discounted amount in this order\n   */\n  this.trackEcommerceOrder = function (\n    orderId,\n    grandTotal,\n    subTotal,\n    tax,\n    shipping,\n    discount,\n  ) {\n    logEcommerceOrder(orderId, grandTotal, subTotal, tax, shipping, discount);\n  };\n\n  /**\n   * Tracks a Cart Update (add item, remove item, update item).\n   * On every Cart update, you must call addEcommerceItem() for each item (product) in the cart, including the items that haven\'t been updated since the last cart update.\n   * Then you can call this function with the Cart grandTotal (typically the sum of all items\' prices)\n   * Calling this method does not remove from this JavaScript object the items that were added to the cart via addEcommerceItem\n   *\n   * @param {float} grandTotal (required) Items (products) amount in the Cart\n   */\n  this.trackEcommerceCartUpdate = function (grandTotal) {\n    logEcommerceCartUpdate(grandTotal);\n  };\n\n  /**\n   * Sends a tracking request with custom request parameters.\n   * eave will prepend the hostname and path to eave, as well as all other needed tracking request\n   * parameters prior to sending the request. Useful eg if you track custom dimensions via a plugin.\n   *\n   * @param request eg. "param=value&param2=value2"\n   * @param customData\n   * @param callback\n   * @param pluginMethod\n   */\n  this.trackRequest = function (request, customData, callback, pluginMethod) {\n    trackCallback(function () {\n      var fullRequest = getRequest(request, customData, pluginMethod);\n      sendRequest(fullRequest, configTrackerPause, callback);\n    });\n  };\n\n  /**\n   * Sends a ping request.\n   *\n   * Ping requests do not track new actions. If they are sent within the standard visit length, they will\n   * extend the existing visit and the current last action for the visit. If after the standard visit\n   * length, ping requests will create a new visit using the last action in the last known visit.\n   */\n  this.ping = function () {\n    this.trackRequest("ping=1", null, null, "ping");\n  };\n\n  /**\n   * Disables sending requests queued\n   */\n  this.disableQueueRequest = function () {\n    requestQueue.enabled = false;\n  };\n\n  /**\n   * Defines after how many ms a queued requests will be executed after the request was queued initially.\n   * The higher the value the more tracking requests can be send together at once.\n   */\n  this.setRequestQueueInterval = function (interval) {\n    if (interval < 1000) {\n      throw new Error("Request queue interval needs to be at least 1000ms");\n    }\n    requestQueue.interval = interval;\n  };\n\n  /**\n   * Won\'t send the tracking request directly but wait for a short time to possibly send this tracking request\n   * along with other tracking requests in one go. This can reduce the number of requests send to your server.\n   * If the page unloads (user navigates to another page or closes the browser), then all remaining queued\n   * requests will be sent immediately so that no tracking request gets lost.\n   * Note: Any queued request may not be possible to be replayed in case a POST request is sent. Only queue\n   * requests that don\'t have to be replayed.\n   *\n   * @param request eg. "param=value&param2=value2"\n   * @param isFullRequest whether request is a full tracking request or not. If true, we don\'t call\n   *                      call getRequest() before pushing to the queue.\n   */\n  this.queueRequest = function (request, isFullRequest) {\n    trackCallback(function () {\n      var fullRequest = isFullRequest ? request : getRequest(request);\n      requestQueue.push(fullRequest);\n    });\n  };\n\n  /**\n   * Returns whether consent is required or not.\n   *\n   * @returns {boolean}\n   */\n  this.isConsentRequired = function () {\n    return configConsentRequired;\n  };\n\n  /**\n   * If the user has given consent previously and this consent was remembered, it will return the number\n   * in milliseconds since 1970/01/01 which is the date when the user has given consent. Please note that\n   * the returned time depends on the users local time which may not always be correct.\n   *\n   * @returns {number|string}\n   */\n  this.getRememberedConsent = function () {\n    var value = cookieManager.getCookie(cookieManager.CONSENT_COOKIE_NAME);\n    if (cookieManager.getCookie(cookieManager.CONSENT_REMOVED_COOKIE_NAME)) {\n      // if for some reason the consent_removed cookie is also set with the consent cookie, the\n      // consent_removed cookie overrides the consent one, and we make sure to delete the consent\n      // cookie.\n      if (value) {\n        cookieManager.deleteCookie(\n          cookieManager.CONSENT_COOKIE_NAME,\n          cookieManager.configCookiePath,\n          cookieManager.configCookieDomain,\n        );\n      }\n      return null;\n    }\n\n    if (!value || value === 0) {\n      return null;\n    }\n    return value;\n  };\n\n  /**\n   * Detects whether the user has given consent previously.\n   *\n   * @returns {boolean}\n   */\n  this.hasRememberedConsent = function () {\n    return !!this.getRememberedConsent();\n  };\n\n  /**\n   * When called, no tracking request will be sent to the eave server until you have called `setConsentGiven()`\n   * unless consent was given previously AND you called {@link rememberConsentGiven()} when the user gave their\n   * consent.\n   *\n   * This may be useful when you want to implement for example a popup to ask for consent before tracking the user.\n   * Once the user has given consent, you should call {@link setConsentGiven()} or {@link rememberConsentGiven()}.\n   *\n   * If you require consent for tracking personal data for example, you should first call\n   * `_paq.push([\'requireConsent\'])`.\n   *\n   * If the user has already given consent in the past, you can either decide to not call `requireConsent` at all\n   * or call `_paq.push([\'setConsentGiven\'])` on each page view at any time after calling `requireConsent`.\n   *\n   * When the user gives you the consent to track data, you can also call `_paq.push([\'rememberConsentGiven\', optionalTimeoutInHours])`\n   * and for the duration while the consent is remembered, any call to `requireConsent` will be automatically ignored until you call `forgetConsentGiven`.\n   * `forgetConsentGiven` needs to be called when the user removes consent for tracking. This means if you call `rememberConsentGiven` at the\n   * time the user gives you consent, you do not need to ever call `_paq.push([\'setConsentGiven\'])`.\n   */\n  this.requireConsent = function () {\n    configConsentRequired = true;\n    configHasConsent = this.hasRememberedConsent();\n    if (!configHasConsent) {\n      // we won\'t call this.disableCookies() since we don\'t want to delete any cookies just yet\n      // user might call `setConsentGiven` next\n      cookieManager.configCookiesDisabled = true;\n    }\n    // eave.addPlugin might not be defined at this point, we add the plugin directly also to make JSLint happy\n    // We also want to make sure to define an unload listener for each tracker, not only one tracker.\n    globalThis.eave.coreConsentCounter++;\n    globalThis.eave.plugins[\n      "CoreConsent" + globalThis.eave.coreConsentCounter\n    ] = {\n      unload: function () {\n        if (!configHasConsent) {\n          // we want to make sure to remove all previously set cookies again\n          cookieManager.deleteCookies();\n        }\n      },\n    };\n  };\n\n  /**\n   * Call this method once the user has given consent. This will cause all tracking requests from this\n   * page view to be sent. Please note that the given consent won\'t be remembered across page views. If you\n   * want to remember consent across page views, call {@link rememberConsentGiven()} instead.\n   *\n   * It will also automatically enable cookies if they were disabled previously.\n   *\n   * @param {boolean} [setCookieConsent=true] Internal parameter. Defines whether cookies should be enabled or not.\n   */\n  this.setConsentGiven = function (setCookieConsent) {\n    configHasConsent = true;\n    if (!configBrowserFeatureDetection) {\n      this.enableBrowserFeatureDetection();\n    }\n    if (!configEnableCampaignParameters) {\n      this.enableCampaignParameters();\n    }\n\n    cookieManager.deleteCookie(\n      cookieManager.CONSENT_REMOVED_COOKIE_NAME,\n      cookieManager.configCookiePath,\n      cookieManager.configCookieDomain,\n    );\n\n    var i, requestType;\n    for (i = 0; i < consentRequestsQueue.length; i++) {\n      requestType = typeof consentRequestsQueue[i][0];\n      if (requestType === "string") {\n        sendRequest(\n          consentRequestsQueue[i][0],\n          configTrackerPause,\n          consentRequestsQueue[i][1],\n        );\n      } else if (requestType === "object") {\n        sendBulkRequest(consentRequestsQueue[i][0], configTrackerPause);\n      }\n    }\n    consentRequestsQueue = [];\n\n    // we need to enable cookies after sending the previous requests as it will make sure that we send\n    // a ping request if needed. Cookies are only set once we call `getRequest`. Above only calls sendRequest\n    // meaning no cookies will be created unless we called enableCookies after at least one request has been sent.\n    // this will cause a ping request to be sent that sets the cookies and also updates the newly generated visitorId\n    // on the server.\n    // If the user calls setConsentGiven before sending any tracking request (which usually is the case) then\n    // nothing will need to be done as it only enables cookies and the next tracking request will set the cookies\n    // etc.\n    if (!_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isDefined(setCookieConsent) || setCookieConsent) {\n      this.setCookieConsentGiven();\n    }\n  };\n\n  /**\n   * Calling this method will remember that the user has given consent across multiple requests by setting\n   * a cookie. You can optionally define the lifetime of that cookie in hours using a parameter.\n   *\n   * When you call this method, we imply that the user has given consent for this page view, and will also\n   * imply consent for all future page views unless the cookie expires (if timeout defined) or the user\n   * deletes all their cookies. This means even if you call {@link requireConsent()}, then all requests\n   * will still be tracked.\n   *\n   * Please note that this feature requires you to set the `cookieDomain` and `cookiePath` correctly and requires\n   * that you do not disable cookies. Please also note that when you call this method, consent will be implied\n   * for all sites that match the configured cookieDomain and cookiePath. Depending on your website structure,\n   * you may need to restrict or widen the scope of the cookie domain/path to ensure the consent is applied\n   * to the sites you want.\n   *\n   * @param {int} hoursToExpire After how many hours the consent should expire. By default the consent is valid\n   *                          for 30 years unless cookies are deleted by the user or the browser prior to this\n   */\n  this.rememberConsentGiven = function (hoursToExpire) {\n    if (hoursToExpire) {\n      hoursToExpire = hoursToExpire * 60 * 60 * 1000;\n    } else {\n      hoursToExpire = 30 * 365 * 24 * 60 * 60 * 1000;\n    }\n    var setCookieConsent = true;\n    // we currently always enable cookies if we remember consent cause we don\'t store across requests whether\n    // cookies should be automatically enabled or not.\n    this.setConsentGiven(setCookieConsent);\n    var now = new Date().getTime();\n    cookieManager.setCookie(\n      cookieManager.CONSENT_COOKIE_NAME,\n      now,\n      hoursToExpire,\n      cookieManager.configCookiePath,\n      cookieManager.configCookieDomain,\n      cookieManager.configCookieIsSecure,\n      cookieManager.configCookieSameSite,\n    );\n  };\n\n  /**\n   * Calling this method will remove any previously given consent and during this page view no request\n   * will be sent anymore ({@link requireConsent()}) will be called automatically to ensure the removed\n   * consent will be enforced. You may call this method if the user removes consent manually, or if you\n   * want to re-ask for consent after a specific time period. You can optionally define the lifetime of\n   * the CONSENT_REMOVED_COOKIE_NAME cookie in hours using a parameter.\n   *\n   * @param {int} hoursToExpire After how many hours the CONSENT_REMOVED_COOKIE_NAME cookie should expire.\n   * By default the consent is valid for 30 years unless cookies are deleted by the user or the browser\n   * prior to this\n   */\n  this.forgetConsentGiven = function (hoursToExpire) {\n    if (hoursToExpire) {\n      hoursToExpire = hoursToExpire * 60 * 60 * 1000;\n    } else {\n      hoursToExpire = 30 * 365 * 24 * 60 * 60 * 1000;\n    }\n\n    cookieManager.deleteCookie(\n      cookieManager.CONSENT_COOKIE_NAME,\n      cookieManager.configCookiePath,\n      cookieManager.configCookieDomain,\n    );\n    cookieManager.setCookie(\n      cookieManager.CONSENT_REMOVED_COOKIE_NAME,\n      new Date().getTime(),\n      hoursToExpire,\n      cookieManager.configCookiePath,\n      cookieManager.configCookieDomain,\n      cookieManager.configCookieIsSecure,\n      cookieManager.configCookieSameSite,\n    );\n    this.forgetCookieConsentGiven();\n    this.requireConsent();\n  };\n\n  /**\n   * Returns true if user is opted out, false if otherwise.\n   *\n   * @returns {boolean}\n   */\n  this.isUserOptedOut = function () {\n    return !configHasConsent;\n  };\n\n  /**\n   * Alias for forgetConsentGiven(). After calling this function, the user will no longer be tracked,\n   * (even if they come back to the site).\n   */\n  this.optUserOut = this.forgetConsentGiven;\n\n  /**\n   * Alias for rememberConsentGiven(). After calling this function, the current user will be tracked.\n   */\n  this.forgetUserOptOut = function () {\n    // we can\'t automatically enable cookies here as we don\'t know if user actually gave consent for cookies\n    this.setConsentGiven(false);\n  };\n\n  /**\n   * enable protocol file: format tracking\n   */\n  this.enableFileTracking = function () {\n    configFileTracking = true;\n  };\n\n  /**\n   * Set eave tracking cookies as necessary and setup the in-memory _eaveContext.\n   */\n  this.setTrackingCookies = function () {\n    // read eave cookies into ctx\n    var ctxCookie = cookieManager.getCookie(CONTEXT_COOKIE_NAME);\n    if (ctxCookie) {\n      _eaveContext = JSON.parse(ctxCookie);\n    }\n\n    // set visitor_id if need\n    setVisitorId();\n\n    // save ctx cookie in case it hasnt been saved already\n    saveContext();\n  };\n\n  /**\n   * Mark performance metrics as available, once onload event has finished\n   */\n  _helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.trackCallbackOnLoad(function () {\n    setTimeout(function () {\n      performanceAvailable = true;\n    }, 0);\n  });\n\n  globalThis.eave.eave.trigger("TrackerSetup", [this]);\n\n  globalThis.eave.eave.addPlugin("TrackerVisitorIdCookie" + uniqueTrackerId, {\n    // if no tracking request was sent we refresh the visitor id cookie on page unload\n    unload: function () {\n      if (supportsClientHints() && !clientHintsResolved) {\n        clientHintsResolved = true;\n        processClientHintsQueue(); // ensure possible queued request are sent out\n      }\n\n      if (!hasSentTrackingRequestYet) {\n        setVisitorId();\n        // this will set the referrer attribution cookie\n        detectReferrerAttribution();\n      }\n    },\n  });\n}\n\n\n//# sourceURL=webpack://eave-tracing-client/./src/tracker.mjs?')},"./src/visibility.mjs":
/*!****************************!*\
  !*** ./src/visibility.mjs ***!
  \****************************/(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVisible: () => (/* binding */ isVisible)\n/* harmony export */ });\n/* harmony import */ var _globals_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.mjs */ "./src/globals.mjs");\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.mjs */ "./src/helpers.mjs");\n\n\n\n/**\n * Author: Jason Farrell\n * Author URI: http://useallfive.com/\n *\n * Description: Checks if a DOM element is truly visible.\n * Package URL: https://github.com/UseAllFive/true-visibility\n * License: MIT (https://github.com/UseAllFive/true-visibility/blob/master/LICENSE.txt)\n */\nfunction isVisible(node) {\n  if (!node) {\n    return false;\n  }\n\n  //-- Cross browser method to get style properties:\n  function _getStyle(el, property) {\n    if (globalThis.eave.windowAlias.getComputedStyle) {\n      return globalThis.eave.documentAlias.defaultView.getComputedStyle(\n        el,\n        null,\n      )[property];\n    }\n    if (el.currentStyle) {\n      return el.currentStyle[property];\n    }\n  }\n\n  function _elementInDocument(element) {\n    element = element.parentNode;\n\n    while (element) {\n      if (element === globalThis.eave.documentAlias) {\n        return true;\n      }\n      element = element.parentNode;\n    }\n    return false;\n  }\n\n  /**\n   * Checks if a DOM element is visible. Takes into\n   * consideration its parents and overflow.\n   *\n   * @param (el)      the DOM element to check if is visible\n   *\n   * These params are optional that are sent in recursively,\n   * you typically won\'t use these:\n   *\n   * @param (t)       Top corner position number\n   * @param (r)       Right corner position number\n   * @param (b)       Bottom corner position number\n   * @param (l)       Left corner position number\n   * @param (w)       Element width number\n   * @param (h)       Element height number\n   */\n  function _isVisible(el, t, r, b, l, w, h) {\n    var p = el.parentNode,\n      VISIBLE_PADDING = 1; // has to be visible at least one px of the element\n\n    if (!_elementInDocument(el)) {\n      return false;\n    }\n\n    //-- Return true for document node\n    if (9 === p.nodeType) {\n      return true;\n    }\n\n    //-- Return false if our element is invisible\n    if (\n      "0" === _getStyle(el, "opacity") ||\n      "none" === _getStyle(el, "display") ||\n      "hidden" === _getStyle(el, "visibility")\n    ) {\n      return false;\n    }\n\n    if (\n      !_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isDefined(t) ||\n      !_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isDefined(r) ||\n      !_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isDefined(b) ||\n      !_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isDefined(l) ||\n      !_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isDefined(w) ||\n      !_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isDefined(h)\n    ) {\n      t = el.offsetTop;\n      l = el.offsetLeft;\n      b = t + el.offsetHeight;\n      r = l + el.offsetWidth;\n      w = el.offsetWidth;\n      h = el.offsetHeight;\n    }\n\n    if (\n      node === el &&\n      (0 === h || 0 === w) &&\n      "hidden" === _getStyle(el, "overflow")\n    ) {\n      return false;\n    }\n\n    //-- If we have a parent, let\'s continue:\n    if (p) {\n      //-- Check if the parent can hide its children.\n      if (\n        "hidden" === _getStyle(p, "overflow") ||\n        "scroll" === _getStyle(p, "overflow")\n      ) {\n        //-- Only check if the offset is different for the parent\n        if (\n          //-- If the target element is to the right of the parent elm\n          l + VISIBLE_PADDING > p.offsetWidth + p.scrollLeft ||\n          //-- If the target element is to the left of the parent elm\n          l + w - VISIBLE_PADDING < p.scrollLeft ||\n          //-- If the target element is under the parent elm\n          t + VISIBLE_PADDING > p.offsetHeight + p.scrollTop ||\n          //-- If the target element is above the parent elm\n          t + h - VISIBLE_PADDING < p.scrollTop\n        ) {\n          //-- Our target element is out of bounds:\n          return false;\n        }\n      }\n      //-- Add the offset parent\'s left/top coords to our element\'s offset:\n      if (el.offsetParent === p) {\n        l += p.offsetLeft;\n        t += p.offsetTop;\n      }\n      //-- Let\'s recursively check upwards:\n      return _isVisible(p, t, r, b, l, w, h);\n    }\n    return true;\n  }\n\n  return _isVisible(node);\n}\n\n\n//# sourceURL=webpack://eave-tracing-client/./src/visibility.mjs?')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/eave-client.mjs")})();