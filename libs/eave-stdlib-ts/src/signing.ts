import { EaveOrigin, ExternalOrigin } from "./eave-origins.js";
import { sharedConfig } from "./config.js";
import { KeyManagementServiceClient } from '@google-cloud/kms';
import { CRC32C } from '@google-cloud/storage';
import crypto from 'crypto';
import { InvalidChecksumError } from "./exceptions.js";

const KMS_KEYRING_LOCATION = 'global';
const KMS_KEYRING_NAME = 'primary';

enum SigningAlgorithm {
  RS256 = 'RS256',
  ES256 = 'ES256',
}

type SigningKeyDetails = {
  id: string;
  version: string;
  algorithm: SigningAlgorithm;
}

const SIGNING_KEYS: { [key: string]: SigningKeyDetails } = {
  [EaveOrigin.eave_api]: {
    id: "eave-api-signing-key",
    version: "1",
    algorithm: SigningAlgorithm.ES256,
  },
  [EaveOrigin.eave_www]: {
    id: "eave-www-signing-key",
    version: "1",
    algorithm: SigningAlgorithm.ES256,
  },
  // This key was generated by Google, and is used to sign requests between the GitHub App and the Eave Core API.
  [EaveOrigin.eave_github_app]: {
    id: "eave-github-app-signing-key-02",
    version: "1",
    algorithm: SigningAlgorithm.ES256,
  },
  [EaveOrigin.eave_slack_app]: {
    id: "eave-slack-app-signing-key",
    version: "1",
    algorithm: SigningAlgorithm.ES256,
  },
  [EaveOrigin.eave_atlassian_app]: {
    id: "eave-atlassian-app-signing-key",
    version: "1",
    algorithm: SigningAlgorithm.ES256,
  },
  // This key was downloaded from GitHub, and then imported into KMS. It is used to sign requests between Eave and GitHub.
  [ExternalOrigin.github_api_client]: {
    id: "eave-github-app-signing-key-01",
    // TODO: clean up this hack to change versions in prod/ dev
    version: sharedConfig.googleCloudProject === "eave-production" ? '2' : "1",
    algorithm: SigningAlgorithm.RS256,
  },
}

function getKey(signer: string): SigningKeyDetails {
  const keyDetails = SIGNING_KEYS[signer];
  if (keyDetails === undefined) {
    throw Error(`No signing key details found for ${signer}`);
  }
  return keyDetails;
}

/**
 * Signs the data with GCP KMS and returns base64-encoded signature
 * 
 * @param signingKey key to sign the data payload with
 * @param data payload to sign using the `signingKey`
 */
export async function signBase64(signingKey: SigningKeyDetails, data: string | Buffer): string {
  const kmsClient = new KeyManagementServiceClient();
  const keyVersionName = kmsClient.cryptoKeyVersionPath(
    sharedConfig.googleCloudProject,
    KMS_KEYRING_LOCATION,
    KMS_KEYRING_NAME,
    signingKey.id,
    signingKey.version,
  );

  let messageBytes: Buffer;
  if (typeof data === 'string') {
    // this byte encoding must match the python `bytes` type in order
    // to not break signing validation in the python core_api middleware
    messageBytes = Buffer.from(data, 'utf8');
  } else {
    messageBytes = data;
  }
  const digest = crypto.createHash('sha256').update(messageBytes).digest();
  const digestCrc32c = generateChecksum(digest);

  const signedResponse = await kmsClient.asymmetricSign({
    name: keyVersionName,
    digest: { 'sha256': digest },
    digestCrc32c,
  });

  if (signedResponse === undefined || !signedResponse.verified || signedResponse.name !== keyVersionName) {
    throw new InvalidChecksumError('KMS checksum failed');
  }

  return signedResponse.signature.toString('base64');
}

function generateChecksum(data: Buffer): IInt64Value {
  // TODO:
}

function validateChecksumOrExcption(data: Buffer, checksum: number): void {
  // TODO:
}