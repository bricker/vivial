import { EaveOrigin, ExternalOrigin } from "./eave-origins.js";
import { sharedConfig } from "./config.js";
import { KeyManagementServiceClient, protos } from '@google-cloud/kms';
import crc32c from 'fast-crc32c';
import crypto from 'crypto';
import { InvalidChecksumError, InvalidSignatureError } from "./exceptions.js"; 

const KMS_KEYRING_LOCATION = 'global';
const KMS_KEYRING_NAME = 'primary';

enum SigningAlgorithm {
  RS256 = 'RS256',
  ES256 = 'ES256',
}

type SigningKeyDetails = {
  id: string;
  version: string;
  algorithm: SigningAlgorithm;
}

const SIGNING_KEYS: { [key: string]: SigningKeyDetails } = {
  [EaveOrigin.eave_api]: {
    id: "eave-api-signing-key",
    version: "1",
    algorithm: SigningAlgorithm.ES256,
  },
  [EaveOrigin.eave_www]: {
    id: "eave-www-signing-key",
    version: "1",
    algorithm: SigningAlgorithm.ES256,
  },
  // This key was generated by Google, and is used to sign requests between the GitHub App and the Eave Core API.
  [EaveOrigin.eave_github_app]: {
    id: "eave-github-app-signing-key-02",
    version: "1",
    algorithm: SigningAlgorithm.ES256,
  },
  [EaveOrigin.eave_slack_app]: {
    id: "eave-slack-app-signing-key",
    version: "1",
    algorithm: SigningAlgorithm.ES256,
  },
  [EaveOrigin.eave_atlassian_app]: {
    id: "eave-atlassian-app-signing-key",
    version: "1",
    algorithm: SigningAlgorithm.ES256,
  },
  // This key was downloaded from GitHub, and then imported into KMS. It is used to sign requests between Eave and GitHub.
  [ExternalOrigin.github_api_client]: {
    id: "eave-github-app-signing-key-01",
    // TODO: clean up this hack to change versions in prod/ dev
    version: sharedConfig.googleCloudProject === "eave-production" ? '2' : "1",
    algorithm: SigningAlgorithm.RS256,
  },
}

export function getKey(signer: string): SigningKeyDetails {
  const keyDetails = SIGNING_KEYS[signer];
  if (keyDetails === undefined) {
    throw Error(`No signing key details found for ${signer}`);
  }
  return keyDetails;
}

/**
 * Signs the data with GCP KMS and returns base64-encoded signature
 * 
 * @param signingKey key to sign the data payload with
 * @param data payload to sign using the `signingKey`
 */
export async function signBase64(
  signingKey: SigningKeyDetails,
  data: string | Buffer
): Promise<string> {
  const kmsClient = new KeyManagementServiceClient();
  const keyVersionName = kmsClient.cryptoKeyVersionPath(
    sharedConfig.googleCloudProject,
    KMS_KEYRING_LOCATION,
    KMS_KEYRING_NAME,
    signingKey.id,
    signingKey.version,
  );

  let messageBytes: Buffer;
  if (typeof data === 'string') {
    // this byte encoding must match the python `bytes` type in order
    // to not break signing validation in the python core_api middleware
    messageBytes = Buffer.from(data, 'utf8');
  } else {
    messageBytes = data;
  }
  const digest = crypto.createHash('sha256').update(messageBytes).digest();
  // const digestCrc32c = generateChecksum(digest);

  const [signedResponse] = await kmsClient.asymmetricSign({
    name: keyVersionName,
    digest: { 'sha256': digest },
    // digestCrc32c: digestCrc32c, // TODO: make this work??
  });

  if (signedResponse.signature === null || signedResponse.signature === undefined || !signedResponse.verifiedDataCrc32c || signedResponse.name !== keyVersionName) {
    throw new InvalidChecksumError('KMS signing failed');
  }

  validateChecksumOrExcption(
    Buffer.from(signedResponse.signature),
    parseInt(<any>signedResponse.signatureCrc32c?.value!, 10)
  );

  return Buffer.from(signedResponse.signature.valueOf()).toString('base64');
}

function generateChecksum(data: Buffer): protos.google.protobuf.IInt64Value {
  const checksum = crc32c.calculate(data);
  return <any>checksum;
}

function validateChecksumOrExcption(data: Buffer, checksum: number): void {
  if (generateChecksum(data) !== checksum) {
    throw new InvalidChecksumError('CRC32C checksums did not match');
  }
}

export async function verifySignatureOrException(
  signingKey: SigningKeyDetails,
  message: string | Buffer,
  signature: string | Buffer,
): Promise<boolean> {
  let messageBytes: Buffer;
  if (typeof message === 'string') {
    // this byte encoding must match the python `bytes` type in order
    // to not break signing validation in the python core_api middleware
    messageBytes = Buffer.from(message, 'utf8');
  } else {
    messageBytes = message;
  }
  const signatureString = Buffer.from(signature).toString('base64');
  const kmsClient = new KeyManagementServiceClient();

  const keyVersionName = kmsClient.cryptoKeyVersionPath(
    sharedConfig.googleCloudProject,
    KMS_KEYRING_LOCATION,
    KMS_KEYRING_NAME,
    signingKey.id,
    signingKey.version,
  );

  const digest = crypto.createHash('sha256').update(messageBytes).digest();

  const [kmsPublicKey] = await kmsClient.getPublicKey({
    name: keyVersionName
  });

  if (!kmsPublicKey.pem) {
    throw new InvalidSignatureError('KMS public key was unexpectedly null');
  }

  let isVerified = false;
  let signatureVerification;

  switch (signingKey.algorithm) {
    case SigningAlgorithm.RS256:
      if (kmsPublicKey.algorithm !== protos.google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm[protos.google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA256]) {
        throw new InvalidChecksumError('Public key algorithm did not match');
      }
      signatureVerification = crypto.createVerify('sha256');
      signatureVerification.update(digest);
      signatureVerification.end();
      isVerified = signatureVerification.verify(
        kmsPublicKey.pem,
        signatureString,
        'base64',
      );
      break;
    case SigningAlgorithm.ES256:
      if (kmsPublicKey.algorithm !== protos.google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm[protos.google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.EC_SIGN_P256_SHA256]) {
        throw new InvalidChecksumError('Public key algorithm did not match');
      }
      signatureVerification = crypto.createVerify('sha256');
      signatureVerification.update(digest);
      signatureVerification.end();
      isVerified = signatureVerification.verify(
        kmsPublicKey.pem,
        signatureString,
        'base64',
      );
      break;
    default:
      throw new InvalidSignatureError(`Unsupported algorithm: ${signingKey.algorithm}`);
  }

  if (!isVerified) {
    throw new InvalidSignatureError('Signature failed verification')
  }
  return isVerified;
}